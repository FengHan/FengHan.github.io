
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>hanfeng.name</title>
  <meta name="author" content="HanFeng">

  
  <meta name="description" content="前言 事务特性是关系型数据库在各个行业领域中成为关键数据存储最主要工具的一大法宝，可以说是数据库安身立命之本，当然也包括MySQL。无论是应用开发人员还是DBA，学习掌握事务的使用和基本原理，是更好地使用和管理数据库的必由之径。 掌握事物的特性要达到什么样的标准呢？如下标准： &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://fenghan.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="hanfeng.name" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2a48f7616c9cd39ec6c4c06ddbd5cbea";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">hanfeng.name</a></h1>
  
    <h2>I am a software engineer with interests in web applications.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="fenghan.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/19/mysql-transaction-and-storange-engine/">MySQL事务与存储引擎</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-19T21:15:51+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>9:15 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>前言</h1>

<p><strong>事务</strong>特性是关系型数据库在各个行业领域中成为关键数据存储最主要工具的一大法宝，可以说是数据库安身立命之本，当然也包括MySQL。无论是应用开发人员还是DBA，学习掌握事务的使用和基本原理，是更好地使用和管理数据库的必由之径。</p>

<p>掌握事物的特性要达到什么样的标准呢？如下标准：</p>

<ol>
<li>事务的主要用处和基本特征</li>
<li>事务隔离级别的含义及影响</li>
<li>什么是MySQL的存储引擎，以及主要存储引擎有哪些</li>
<li>MySQL主要存储引擎的特点和适用范围</li>
<li>InnoDB存储引擎特点和优势</li>
</ol>


<h1>数据库事务</h1>

<h3>什么是事务？</h3>

<p>老张给老王转账100元。要分为两个update语句，一个语句给老张减去100元，另外一个语句给老王加上一百元。而计算系统总是不能持续稳定的运行，线上会有各种各样的故障，而这个故障恰好发生在两个SQL之间，那么这100元就废了。事务就是为了避免这样的事情发生。</p>

<ul>
<li>一系列有序的数据库操作

<ul>
<li>要么全部成功</li>
<li>要么全部回退到操作状态</li>
<li>中间状态对其它连接不可见</li>
</ul>
</li>
<li>事务的基本操作

<ul>
<li>start transaction; 开始事务  （begin）</li>
<li>commit; 提交（全部完成）</li>
<li>rollback; 回滚（回到初始状态）</li>
</ul>
</li>
</ul>


<p>宕机后，没有成功的数据都会回滚。</p>

<p>事务的中继点 savepoint</p>

<p>允许事务开启后，在事务的中段进行多次保存点的保存，在回滚的时候可以回滚到任意一个保存点，而不是选择将整个事务全部回滚。而我们提交的时候，只能将我们事务中的所有操作提交，而不能提交到任意一个保存点。</p>

<p>savepoint a1;
rollback to a1;</p>

<p>线上不经常使用savepoint</p>

<h3>自动提交</h3>

<ul>
<li>autocommit 可以在session级别设置</li>
<li>每个DML操作都自动提交(就是update, delete,insert 操作)</li>
<li>DDL永远都是自动提交，无法通过rollback回滚。(就是修改表结构的那些语句，DDL之前的DML语句， 也都会随着DDL的提交而永久持续化到数据库上。)  简单来说DDL没有后悔药吃。</li>
</ul>


<p>因为在每个insert语句后，自动加了一个commit;</p>

<pre><code>mysql&gt; show global variables like '%autocommit%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
</code></pre>

<p>mysql> set session autocommit = 0;</p>

<h3>事务的四个基本属性（ACID）</h3>

<ul>
<li>原子性（Atomicity）</li>
<li>一致性 (Consistency)</li>
<li>隔离性(Isolation)</li>
<li><p>持久性(Durability)</p>

<h4>事务的原子性</h4></li>
<li><p>包含在事务中的操作要么全部执行，要么都不执行</p></li>
<li>中途数据库或应用发生异常，未提交的事务都应该被回滚</li>
</ul>


<h4>事务的一致性</h4>

<ul>
<li>数据的正确性，合理性，完整性</li>
<li>数据一致性应该符合应用需要规则

<ul>
<li>余额不能是负数？ （int no zero）</li>
<li>交易对象必须先有账号？ (主外键约束)</li>
<li>用户账号不能重复？ （添加唯一索引）</li>
</ul>
</li>
<li>事务的结果需要满足数据的一致性约束</li>
</ul>


<h4>事务的持久性</h4>

<ul>
<li>提交完成的事务对数据库的影响必须是永久性的

<ul>
<li>数据库异常不会丢失事务更新</li>
<li>通常认为成功写入磁盘的数据即为持久化成功</li>
</ul>
</li>
</ul>


<h4>事务的持久化的实现</h4>

<p>挑战： 数据库的高性能。并不是修改一个数据，就在磁盘上马上改掉。因为数据库里的数据散步在各地。而机械磁盘的随机写是相当缓慢的过程。为保证较高效率。修改数据，不会马上记录在磁盘上，先被保存在事务日志中（顺序同步刷新，磁盘对顺序写是相当优秀的，然后异步的慢慢的刷新到磁盘上。宕机时，通过事务日志回放来保证数据持久化。</p>

<h4>事务的隔离性</h4>

<ul>
<li>数据库事务在提交完成前，中间的任何数据变化对其他的事务都是不可见的</li>
</ul>


<h4>数据库隔离现象</h4>

<ul>
<li>脏读 Dirty Read 事务B读到事务A尚未提交的数据变更</li>
<li>不可重复读 NonRepeatable Read  B事务由于A事务的提交，查询数据时，看到2种不同的结果</li>
<li>幻读 Phantom Read 幻读 （不可重复读和幻读都针对事务B能否读到事务A已经提交的变更）</li>
</ul>


<h4>数据库隔离等级</h4>

<ul>
<li>Read uncommitted 未提交读</li>
<li>Read committed   已提交读</li>
<li>Repeatable read 可重复读</li>
<li>Serializable   可串行化

<h4>MySQL的事务隔离级别</h4></li>
<li>InnoDB默认标记为可重复读（Repeatabe read）</li>
<li>InnoDB并不是标准定义上的可重复读</li>
<li><p>InnoDB默认在可重复读的基础上避免幻读
show global variables like &lsquo;%iso%&rsquo;;</p>

<h4>MySQL的事务隔离级别</h4></li>
<li><p>InnoDB默认标记为可重复读（Repeatable read）</p></li>
<li>InnoDB并不是标准意义上的可重复读</li>
<li>InnoDB默认在可重复读的基础上避免幻读</li>
</ul>


<p>set global tx_isolation = &lsquo;REPEATABLE-READ&rsquo;;</p>

<p>set global tx_isolation = &lsquo;SERIALIZABLE&rsquo;;
实验：</p>

<ul>
<li>未提交读: 有脏读
  set global tx_isolation = &lsquo;READ-UNCOMMITTED&rsquo;;</li>
<li>已提交读：没有脏读， 存在幻读和不可重复读
  set global tx_isolation = &lsquo;READ-COMMITTED&rsquo;;</li>
<li>可重复读
  set global tx_isolation = &lsquo;REPEATABLE-READ&rsquo;;</li>
</ul>


<p>不可重复读: B事务由于A事务update的提交，B事务看到两种不同的数据。
幻读: 事务B由于事务A insert 的提交，B   事务看到了之前不存在的数据。</p>

<ol>
<li>不可重复读针对（delete，update操作）</li>
<li>幻读针对insert操作</li>
</ol>


<h4>MySQL的事务隔离级别的设置</h4>

<ul>
<li>可在global/session 下分别设置事务的隔离级别</li>
<li>建议使用Read committed(同Oracle)</li>
<li>或者建议使用默认的MySQL设置Repeatable read
  -隔离级别Serializable   可串行化对线上的并发性能有影响，不会在线上设置</li>
</ul>


<h3>事务与并发写</h3>

<ul>
<li>某个正在更新的记录在提交或回滚前不能被其他事务同时更新(? update 前加排它锁X?)</li>
<li>事务修改某个记录时，会先获得这条记录的锁，其它事务会进行等待。A修改完成，会将锁释放。然后B和C会获得这把锁</li>
<li>btw,所有对数据库记录的修改都是串行的，不存在并发的概念</li>
</ul>


<h3>事务回滚的实现</h3>

<ul>
<li>回滚段（rollback segment）与数据前像</li>
</ul>


<h1>存储引擎概述</h1>

<h2>MySQL 程序层次架构</h2>

<ul>
<li>内存实例

<ul>
<li>服务层（上层）</li>
<li>存储引擎层（上层数据和上层SQL语句经过处理之后，交给存储引擎层，由存储引擎层决定如何将它记录在磁盘上）</li>
</ul>
</li>
<li>存储引擎</li>
</ul>


<h2>什么是存储引擎</h2>

<p>举例：书记员记录
书记员就是<strong>服务层</strong>，
而书记员的笔就是<strong>存储引擎</strong>（文字，图标，流程图。决定以何种格式记录。）</p>

<h2>MySQL 存储引擎</h2>

<ul>
<li>有多种方案，可拔插，可修改存储引擎。</li>
<li><strong>基于表</strong>选择使用何种存储引擎</li>
</ul>


<p>show engines;</p>

<h1>InnoDB存储引擎</h1>

<ul>
<li>索引组织表</li>
<li>支持事务</li>
<li>锁的粒度比较小，支持行级锁</li>
<li>有自己的数据块缓存</li>
<li>日志持久化</li>
<li><strong>稳定可靠，性能好，线上尽量使用InnoDB</strong>
MySQL5.5之后的默认存储引擎，我们线上绝大部分的数据都会放到InnoDB存储引擎中。

<h2>InnoDB 存储引擎架构</h2></li>
<li>InnoDB缓存池：内存空间包括： 数据块缓存 Buffer pool(更高效的操作数据文件)，日志缓存，double write缓存</li>
<li>后台线程：将内存中的数据块刷新到磁盘上，将日志写到磁盘上，监控</li>
<li>磁盘上的文件： 数据文件， redo log

<h2>MyISAM 存储引擎</h2></li>
<li>堆表</li>
<li>不支持事务</li>
<li>只维护索引缓存池， 表数据缓存交给操作系统</li>
<li>锁的力度比较大，导致并发性能非常查</li>
<li>数据文件可以直接拷贝，偶尔可能用上</li>
<li>不建议线上业务数据使用
Mysql直到5.1开始，都是MySQL的默认存储引擎
MyISAM 只能有一个连接修改数据，对数据的并发性造成很大的影响，这是被淘汰的主要原因。
系统初始化的表是MyISAM,因为不需要经常的修改和并发性操作，所以没有问题。</li>
</ul>


<h2>Memory存储引擎</h2>

<ul>
<li>数据全内存存放，无法持久化</li>
<li>性能较高</li>
<li>不支持事务</li>
<li>适合偶尔作为临时表使用</li>
<li>create temporary table tmp(id int) engine = memory;</li>
<li>temporary临时表只针对当前这个连接生效，不是全局的。</li>
</ul>


<h2>BlackHole存储引擎</h2>

<ul>
<li>数据不做任何存储-</li>
<li>利用MySQL Replicate，充当日志服务器</li>
<li>在MySQL Replicate 环境中充当代理主

<h2>TokuDB</h2></li>
<li>分形数存储结构</li>
<li>支持事务</li>
<li>行锁</li>
<li>压缩效率较高</li>
<li>适合大批量insert的场景

<h2>MySQL Cluster</h2></li>
<li>多主分布式集群</li>
<li>数据节点间冗余，高可用</li>
<li>支持事务</li>
<li>设计易于扩展</li>
<li>面向未来，线上慎用</li>
</ul>


<p>alter table m ENGINE = innodb;</p>

<h2>InnoDB物理文件</h2>

<ol>
<li>系统表空间：ibdata1  一个实例一个　（innodb_data_home_dir）</li>
<li>日志文件：ib_logfile0/1 一个实例两个（可以配置） (innodb_log_group_home_dir)</li>
<li>表定义文件：　表名.frm 每个表一个 (Schema目录下)</li>
<li>表数据文件：　表名.ibd 如果innodb_file_per_table = 1，则每个表一个(Schema目录下)
ibdata1存放了：</li>
<li>回滚段</li>
<li>所有InnoDB表元数据信息（不能想MyISAM通过拷贝数据来做表迁移。如果发生移动，ibdata1中存储信息和数据文件实际存在位置不一致，就无法打开这张表）</li>
<li>Double write, insert buffer dump等等</li>
</ol>


<p>自动扩展机制
show global variables like &lsquo;%innodb%&rsquo;;</p>

<p>参数innodb_autoextend_increment 100M 或者稍微大一点是比较合适的大小。太小的话，会造成系统表空间频繁的扩展，因为每次扩展的量不够。如果设置太大的话，会造成每次扩展的效率非常慢，在扩展期间。很多因为回滚段不够的事务将被hand住。因此建议100M或者稍微大些比较合适。
innodb_file_per_table 设为1， 表定义和表数据文件会单独存放。否者会和ibdata1放在一起。
innodb_log_file_size 100M
innodb_log_file_in_group 2  和性能相关，如果写操作过多（insert,delete,update），可以将这两个参数调大。</p>

<ul>
<li>索引组织表（聚簇表）</li>
<li>根据表逻辑主键排序</li>
<li><p>数据节点每页16k （根节点，枝节点，叶节点）</p></li>
<li><p>根据主键寻址速度很快</p></li>
<li>主键值递增的insert插入效率较好</li>
<li>主键随机insert插入效率较差</li>
</ul>


<p>因此， InnoDB表必须指定主键，建议使用自增</p>

<h2>InnoDB内存缓存</h2>

<ul>
<li>数据的读写需要经过缓存</li>
<li>数据以整页（16k）为单位读到缓存中</li>
<li>缓存中的数据以LRU策略换出（最少使用策略）</li>
<li>IO效率高，性能好。（利用缓存池减少了物理IO）
innodb_buffer_pool_size 根据总物理内存设置。 在启动实例的时候设置</li>
</ul>


<h2>InnoDB数据持久化</h2>

<ul>
<li>事务日志实时持久化</li>
<li>内存变化数据（脏数据）增量异步刷出到磁盘</li>
<li>实例故障靠重放日志恢复</li>
<li>性能好，可靠，恢复快

<h2>InnoDB行级锁</h2></li>
<li>写不阻塞读</li>
<li>不同行之间的写互相不阻塞</li>
<li>并发性能好

<h2>InnoDB事务支持</h2>

<p>事务ACID特性的完整支持
A 回滚段失败回滚
C 支持主外键约束
I 事务版本 + 回滚端 = MVCC
D 事务日志持久化</p></li>
</ul>


<p>默认可重复读隔离级别，可调整</p>

<h1>InnoDB事务锁</h1>

<h2>什么是计算机程序锁</h2>

<ul>
<li>控制对共享资源进行并发访问</li>
<li>保护数据的完整性和一致性</li>
</ul>


<h2>什么是数据库锁</h2>

<ul>
<li>事务锁 保护数据库逻辑内容， 持续时间较长</li>
<li><p>latch/mutex 保护内存数据结构， 用于临界资源的争抢，时间短
数据库事务并发：（一个串行化的过程）
更新丢失</p>

<h3>事务锁的力度</h3></li>
<li><p>行锁 InnoDB, Oracle</p></li>
<li>页锁 SQL Server； 存在锁升级的情况</li>
<li>表锁 MyISAM, Memory; 影响并发性

<h3>数据库加锁操作</h3>

<p>select 语句不加任何锁，也不会被任何事务阻塞锁。
读的隔离性由MVCC确保</p></li>
</ul>


<h3>InnoDB锁模式互斥</h3>

<ul>
<li>shared lock 读锁是共享的

<ul>
<li>手动： select * from test lock in share mode ;</li>
<li>自动： insert 前</li>
</ul>
</li>
<li>exclusive lock 写锁是排他的

<ul>
<li>自动： select * from test lock for update;</li>
<li>手动: update 和delete前</li>
</ul>
</li>
<li>一般select语句不加任何锁，也不会被任何事务阻塞</li>
</ul>


<p>等待时间，由系统参数决定
show global variables like &lsquo;%lock_wait%&rsquo;;</p>

<h4>锁粒度</h4>

<ul>
<li>table lock</li>
<li>row lock</li>
</ul>


<p>lock for update  (exclusive lock)</p>

<h2>InnoDB锁机制</h2>

<h2>InnoDB锁实现与注意事项</h2>

<h2>死锁</h2>

<h2>业务加锁</h2>

<h1>参考链接</h1>

<p><a href="http://blog.csdn.net/hguisu/article/details/7106342">MySQL架构</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/12/drupal101/">Drupal101</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-12T22:39:48+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:39 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>前言</h1>

<p>入职新公司，开始学习Drupal。立志成为Drupal专家</p>

<h1>Drupal101</h1>

<ul>
<li>创始人 Dries Buytaert博客 <a href="http://buytaert.net/">http://buytaert.net/</a></li>
<li>学习资源 <a href="https://drupalize.me">drupalize.me</a></li>
</ul>


<h4>What is Drupal</h4>

<ul>
<li>CMS

<ul>
<li>CMF</li>
</ul>
</li>
<li></li>
</ul>


<h4>Who uses Drupal</h4>

<ul>
<li><a href="http://drupalshowcase.com/">Drupal Showcase</a></li>
<li><a href="https://www.drupal.org/case-studies">drupal.org</a></li>
</ul>


<h4>Major features with site building</h4>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/10/19/mysql-transaction-and-storange-engine/">MySQL事务与存储引擎</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/12/drupal101/">Drupal101</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/16/mysql-storage-engine/">MySQL存储引擎</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/14/mysql-db-object/">MySQL数据库对象与应用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/12/performance-test/">高性能产品的必由之路—性能测试工具</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/10/mysql-master-slave/">MySQL主从复制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/10/mysql-index/">MySQL索引</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/09/mysql-foundation/">MySQL Foundation</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/09/learn-laravel-from-scratch/">Laravel5 基础</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/09/05/csrf/">Cross Site Request Forgery</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - HanFeng -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
