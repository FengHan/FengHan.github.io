<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[hanfeng.name]]></title>
  <link href="http://fenghan.github.io/atom.xml" rel="self"/>
  <link href="http://fenghan.github.io/"/>
  <updated>2015-08-29T16:14:39+08:00</updated>
  <id>http://fenghan.github.io/</id>
  <author>
    <name><![CDATA[HanFeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SCRUM敏捷式开发（Agile）思维整理]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/29/agile/"/>
    <updated>2015-08-29T12:33:45+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/29/agile</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>今天看到朋友圈里关于<a href="www.teambition.com">teambition</a>团队协作工具的介绍。</p>

<p>由此联想到了以前公司的SCRUM敏捷式开发。这里整理一下敏捷式团队开发的一些思绪。</p>

<h1>SCRUM</h1>

<p><img src="http://images.cnblogs.com/cnblogs_com/taven/201010/2010-10-17_202832.png" alt="" /></p>

<p>就如上图(图片为网络搜寻)所看到的，一个超大的白板上规矩的排满了各种纸条。每个纸条上写着各种任务。如果谁对这个任务感兴趣，就在这个纸条上写上自己的名字。为了便于说明，我假设了一个场景进行阐述。</p>

<h4>周一上午</h4>

<p>IT经理已经和总经理进行了讨论。IT 经理说：</p>

<ol>
<li><p>上周，市场部门已经提前跟我说过，国庆节来了，我们是一个电商网站，要做出一些活动，所以们这周会给3个月内未购买过产品的用户发电子邮件。这个任务包含了前端HTML和后端PHP的一些逻辑。</p></li>
<li><p>我们的网站要有一个法语的版本，所以我们在接下来的这两个星期会考虑我们的数据库设计。</p></li>
</ol>


<p>&hellip;（省略若干任务）</p>

<h4>周一下午</h4>

<p>IT部门的10个人聚集在会议室。打算做两件事情：</p>

<ol>
<li><p>讨论上周的任务完成情况，当然在一般的情况下，这些任务是都完成了的。Review一下成果。</p></li>
<li><p>讨论IT经理上午和总经理谈得任务，把每条任务进行逐行分解。并把任务平均分配到2个team上。接下来把任务打印出来。贴到白板上。正如上图所见，左面第一列的每一个方格子内是一系列相关的任务，这是打算是打算要这两个星期要做的事情。</p></li>
</ol>


<h3>周二上午10点</h3>

<p>每天上午，IT部门的10个人站在这块白班前面，把自己今天打算要做的任务纸条上写下自己的名字，然后挪动到中间的格子里。叙说一下我对这个任务的看法，打算怎么做，预估多长时间能够昨晚。</p>

<h3>周三上午</h3>

<p>每天早上10点，IT部的人都会站在这块白板前面，对写下名字的任务叙说3件事情：</p>

<ol>
<li>我昨天做了什么</li>
<li>我遇到了哪些困难</li>
<li>我今天打算做些什么</li>
</ol>


<h3>周四上午</h3>

<p>这里叙说一下为什么站在白板前面，而不是坐在会议室里，因为这样站着效率跟高效，10分钟就能够讨论结束。其实每天早上的这个会议叫做Sprint会议。</p>

<p>今天有人已经完成了任务，他会把任务纸条放在最右边的那栏里，表示任务已经完成。</p>

<h2>总结：</h2>

<p>OK, 这就是我执行了2年的SCRUM敏捷式开发的流程。我是一个执行者的流程来看待这件事件。它的优点：</p>

<ol>
<li>任务清楚，明确，一切围绕着目标。</li>
<li>中途加入的临时任务如果不是特别紧急、重要会安排到下周。</li>
</ol>


<p>缺点：
1. 每天时间满满的一个任务接着一个任务，时间久了会有些疲惫。</p>

<p>每一段工作任务都会会学到很多东西，把它记录下来，总结下来，为下一家公司发光发热。</p>

<p>这有一个网上的SCRUM可以看看<a href="http://home.leangoo.com/">leangoo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何成为高级程序员]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/28/senior-programmer/"/>
    <updated>2015-08-28T08:00:02+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/28/senior-programmer</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>高级程序员都干些什么呢？怎样才能成为高级程序员呢？其实初级或刚入行的朋友喜欢问这样的问题。可能想把作为下一个奋斗的目标吧。下面是微信账号“威哥干Java”的看法。</p>

<p>一个项目好比画了两个圈，内外镶嵌，高级程序员负责内圈代码，初级程序员负责外圈代码。想要成为高级程序员，你就得往内圈挤。</p>

<p>从专业的角度上有三点：</p>

<ol>
<li>确定开发团队、技术路线和技术架构，为关键模块设计技术实现，能够满足长期发展的业务需要。</li>
<li>能参与系统调研，需求分析。负责概要设计、详细设计， 开发计划等编制并实施。负责核心内码通用模块功能实现，解决一些技术问题。</li>
<li>负责提升团队技术能力，协同项目经理进行项目开发，并实现重要的功能，指导和培养团队的成员。</li>
</ol>


<p>满足3个必备条件：</p>

<ol>
<li>具备看官方英文文档的能力。</li>
<li>上专业顶级的社区。</li>
<li>成为Github重度感染者。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[缓存]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/26/cache/"/>
    <updated>2015-08-26T16:26:59+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/26/cache</id>
    <content type="html"><![CDATA[<h3>缓存的类型</h3>

<ul>
<li>局域网缓存</li>
<li>网络缓存</li>
<li>硬盘缓存</li>
<li>内存缓存</li>
<li>数据库缓存</li>
<li>Opcode缓存</li>
<li>客户端浏览器缓存</li>
</ul>


<h3>opcode</h3>

<p>Opcode是一种PHP脚本编译后的中间语言</p>

<ul>
<li>opcache php5.5 默认安装</li>
<li>xcache  php5.4</li>
<li>php 5.2 zned optimization 被淘汰了。</li>
<li>wincache windows下</li>
<li>APC  PHP5.4  （PS: 上一家公司安装了APC）</li>
</ul>


<p>APCU xcache wincache 支持php API调用 （默认情况下 效率高于memcache）</p>

<h4>客户端浏览器缓存</h4>

<p>客户端缓存 （浏览器缓存） 静态资源引用公共服务器资源</p>

<p>把图片放在多个域名下，可以多线程加载图片 例如pc1.domain.com pc2.domain.com</p>

<p>xxx.com/abc.js?t=1234343 开发测试的时候，用这种方法防止浏览器缓存。给静态资源加时间戳带尾巴。</p>

<p>在发行产品的时候带版本号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[水平分表]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/26/fen-biao/"/>
    <updated>2015-08-26T16:21:34+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/26/fen-biao</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>学习分库、分表的一记录，后期整理，添加示例。</p>

<h1>正文</h1>

<p>数据库分表与分库的实现方法：</p>

<p>tb_user_0  &hellip; tb_user_1 &hellip;.tb_user_2 &hellip;. tb_user_3</p>

<hr />

<p>当多张表具有完全相同的数据结构时，我们认为这些表示对一个实体数据的横向切分。</p>

<p>每张表都可以有自己的id
但是所有切分出来的表必须具备全局uid
分表后要按照某个元素（通常全局id）进行某种算法的计算，得到表后缀。</p>

<p>id生成器。（用redis做id在断电的情况下有风险），通常用mysql</p>

<p>uuid 得到一个字符串</p>

<p>自建索引</p>

<p>当数据库大了，分表是必然的。分表之后，建索引是必然的。</p>

<p>将全局id进行一次md5将得到一个由16进制数值组成的32位字符串。 数据越多越均匀。分成15张表，</p>

<p>或分成256张表。</p>

<p>分成80张： FF = 255 255%80 取余数。分多少张表，就余多少。</p>

<hr />

<p>如果只是做简单切分的时候后，我们会遇到问题：</p>

<ol>
<li>当我们需要将这些数据进行统计与分析的时候，不能使用聚合函数</li>
<li><p>当我们查询某条数据时，我们必须要知道我要查询的数据在哪一张表里，否则我就需要查询所有的表来查找结果。</p></li>
<li><p>当我插入数据的时候，我必须尽可能的让每张表的负载均匀</p></li>
<li>当我要修改数据的时候，我必须明确我要修改的数据在哪里。</li>
</ol>


<p>在不同的时期分表，会产生不同的问题。</p>

<ol>
<li>项目启动阶段就进行分表</li>
<li>项目启动阶段没有分表，而是在项目进行到积累了一定数据量以后再进行分表</li>
<li>项目之前就进行切分过表，但是被切分后的表经过长时间运行，又产生了大量数据，需要再次分表</li>
</ol>


<p>。</p>

<p>合理的分表不单单能解决单张表数据量过大的问题，还能优化我们的业务逻辑。</p>

<p>tb_product_store_sh
tb_product_store_bj
tb_product_store_hubei</p>

<p>基于区域位置的分表，非常适合做类似库存，商户信息，工商管理等有着明显区域性的数据分表。</p>

<p>基于IP地址的分表， 用于统计与分析数据。访问日志。
（几十万的数据开始考虑分表。）
当数据达到100多万的时候，就要考虑分表。</p>

<p>按时间分表，
日志。
财务报表。
绩效考核。</p>

<p>工资流水、销售业绩、出纳凭证等记录，按年份来分表。</p>

<p>考勤记录  销售业绩
个人考勤记录 签单记录  按月分表比较适合</p>

<p>季度、半年度、部门业绩 工资资产 等</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL主从配置及读写分离]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/23/mysql-master-slave/"/>
    <updated>2015-08-23T21:53:41+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/23/mysql-master-slave</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>以前在公司的时候，公司配了MySQL主从，在线上用PHPMyAdmin查看从库信息，但只给了读权限，用于查看线上信息。今天记录一下MySQL主从的搭建过程。（我使用的是MariaDb5.5）</p>

<h2>Notice</h2>

<p>在用户不多、并发不大、mysql服务器在同一个局域网内，MySQL主从是没有问题的。</p>

<p>主从数据库缺点：</p>

<ol>
<li>因为开启了bin log日志，所以会有性能开销。</li>
<li>在实时性非常高的情况下，做了读写分离就不行。因为单线程同步需要花时间，时间上不允许。</li>
</ol>


<h1>MySQL主从配置</h1>

<ol>
<li>mysql的版本相同， mysql主从同源，即具有相同的库、表及记录。</li>
<li>数据迁移的时候，从库的版本高于主库。</li>
<li><p>把主库从库都停掉。因为打包主库的时候会花很长时间，这时如果主库还有文件写入，很容易出错。</p>

<p> cd /var/lib/
 tar zcvf mysql.tar.gz ./mysql</p>

<p> scp mysql.tar.gz vagrant@192.168.33.10:/tmp</p></li>
<li><p>配置/etc/mysql/my.cnf</p>

<p> server-id               = 1
 log_bin                 = /var/log/mysql/mysql-bin.log
 expire_logs_days        = 10
 max_binlog_size         = 100M      每个bin log文件最大的大小</p></li>
</ol>


<p>开启log_bin日志，性能就会降低。没修改一条数据，就会写入文件。硬盘不大的情况下，会写满数据库</p>

<p>要放到msyql有权限的目录里。</p>

<p>我们的目的是用从库修复主库。
靠从库的bin_log来恢复主机。</p>

<p>写bin_log性能降低，但因为我们做了主从，我们靠读多个从库来提高并发量。</p>

<p>让从库能够通过tcp 来连接主库，
5. 为从库专门准备一个用户。</p>

<pre><code>create user 'slave_1'@'%' IDENTIFIED BY 'abcd' ;
grant replication slave  on *.* to 'slave_1'@'%';
或者一条命令
GRANT REPLICATION SLAVE ON *.* to 'mysync'@'%' identified by 'q123456'; 
</code></pre>

<ol>
<li><p>通过  SHOW MASTER STATUS; 显示当前主库的binlog文件与文件位置，我们需要将这个位置记录下来</p>

<p>   SHOW MASTER STATUS;</p></li>
</ol>


<p>连接到从库   开启主从同步</p>

<pre><code>CHANGE MASTER TO MASTER_HOST = '192.168.33.12' ,MASTER_USER='slave_2' ,MASTER_PASSWORD = '1234' ,MASTER_LOG_FILE ='mysql-bin.000002', MASTER_LOG_POS=973
</code></pre>

<p> 不想同步系统库可以选择忽略系统库</p>

<pre><code>binlog_ignore_db        = mysql
</code></pre>

<p>SALVE命令</p>

<pre><code>START SLAVE
STOP  SLAVE
SHOW SLAVE STATUS\G
</code></pre>

<p>我在安装的时候遇到的错误：
<a href="http://serverfault.com/questions/586651/mysql-refuses-to-accept-remote-connections">MySQL refuses to accept remote connections</a></p>

<p>解决方法：</p>

<pre><code>sudo netstat -ntlup | grep mysql
tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN      127018/mysqld
</code></pre>

<p>修改/etc/mysql/my.cnf</p>

<pre><code>bind-address = 0.0.0.0
</code></pre>

<h1>读写分离</h1>

<p>主库创建新用户</p>

<pre><code>GRANT all privileges  ON tiny.* to 'michael'@'%' identified by '1234'; 
flush privileges;
</code></pre>

<p>从库创建新用户，只给读的权限。</p>

<pre><code>GRANT SELECT  ON tiny.* to 'michael2'@'%' identified by '1234'; 

flush privileges;
</code></pre>

<h3>代码</h3>

<p>代码我放到了我的GitHub上，我自己写了一个MVC的简易框架。这样，框架的任何一个部分我都了解，大大节约了我写代码示例的时间。然后学习优秀框架的思想，继续维护我的框架。</p>

<p><a href="https://github.com/hildalove/tiny/blob/master/Tiny/Proxy/Proxy.php">代理模式</a></p>

<p><a href="https://github.com/hildalove/tiny/blob/master/Tiny/Service/Factory.php">获取数据库实例</a></p>

<p><a href="https://github.com/hildalove/tiny/blob/master/App/Controller/Mysql.php">控制器</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]PHP程序员的技术成长规划]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/23/php-develop/"/>
    <updated>2015-08-23T21:32:55+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/23/php-develop</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>按照了解的很多PHP/LNMP程序员的发展轨迹，结合个人经验体会，抽象出很多程序员对未来的迷漫，特别对技术学习的盲目和慌乱，简单梳理了这个每个阶段PHP程序员的技术要求，来帮助很多PHP程序做对照设定学习成长目标。</p>

<p>本文按照目前主流技术做了一个基本的梳理，整个是假设PHP程序员不是基础非常扎实的情况进行的设定，并且所有设定都非常具体明确清晰，可能会让人觉得不适，请理解仅代表一家之言。（未来技术变化不在讨论范围）</p>

<h1>第一阶段：基础阶段（基础PHP程序员）</h1>

<p><strong>重点</strong>：把LNMP搞熟练（核心是安装配置基本操作）</p>

<p><strong>目标</strong>：能够完成基本的LNMP系统安装，简单配置维护；能够做基本的简单系统的PHP开发；能够在PHP中型系统中支持某个PHP功能模块的开发。
时间：完成本阶段的时间因人而异，有的成长快半年一年就过了，成长慢的两三年也有。</p>

<h4>1.Linux：</h4>

<p>基本命令、操作、启动、基本服务配置（包括rpm安装文件，各种服务配置等）；会写简单的shell脚本和awk/sed 脚本命令等。</p>

<h4>2.Nginx：</h4>

<p>做到能够安装配置nginx+php，知道基本的nginx核心配置选项，知道 server/fastcgi_pass/access_log 等基础配置，目标是能够让nginx+php_fpm顺利工作。</p>

<h4>3.MySQL：</h4>

<p>会自己搭建mysql，知道基本的mysql配置选项；知道innodb和myisam的区别，知道针对InnoDB和MyISAM两个引擎的不同配置选项；知道基本的两个引擎的差异和选择上面的区别；能够纯手工编译搭建一个MySQL数据库并且配置好编码等正常稳定运行；核心主旨是能够搭建一个可运行的MySQL数据库。</p>

<h4>4.PHP：</h4>

<p>基本语法数组、字符串、数据库、XML、Socket、GD/ImageMgk图片处理等等；熟悉各种跟MySQL操作链接的api（mysql/mysqli/PDO)，知道各种编码问题的解决；知道常规熟练使用的PHP框架（ThinkPHP、Zendframework、Yii、Yaf等）；了解基本MVC的运行机制和为什么这么做，稍微知道不同的PHP框架之间的区别；能够快速学习一个MVC框架。能够知道开发工程中的文件目录组织，有基本的良好的代码结构和风格，能够完成小系统的开发和中型系统中某个模块的开发工作。</p>

<h4>5.前端：</h4>

<p>如果条件时间允许，可以适当学习下 HTML/CSS/JS 等相关知识，知道什么web标准，div+css的web/wap页面模式，知道HTML5和HTML4的区别；了解一些基本的前端只是和JS框架（jQuery之类的）；了解一些基本的JavaScript编程知识；（本项不是必须项，如果有时间，稍微了解一下是可以的，不过不建议作为重点，除非个人有强烈兴趣）</p>

<h4>6.系统设计：</h4>

<p>能够完成小型系统的基本设计，包括简单的数据库设计，能够完成基本的：浏览器 -> Nginx+PHP -> 数据库 架构的设计开发工作；能够支撑每天几十万到数百万流量网站的开发维护工作；</p>

<h1>第二阶段：提高阶段 （中级PHP程序员）</h1>

<p><strong>重点</strong>：提高针对LNMP的技能，能够更全面的对LNMP有熟练的应用。</p>

<p><strong>目标</strong>：能够随时随地搭建好LNMP环境，快速完成常规配置；能够追查解决大部分遇到的开发和线上环境的问题；能够独立承担中型系统的构架和开发工作；能够在大型系统中承担某个中型模块的开发工作；</p>

<h4>1. Linux:</h4>

<p>在第一阶段的基础上面，能够流畅的使用Shell脚本来完成很多自动化的工作；awk/sed/perl 也操作的不错，能够完成很多文本处理和数据统计等工作；基本能够安装大部分非特殊的Linux程序（包括各种库、包、第三方依赖等等，比如MongoDB/Redis/Sphinx/Luncene/SVN之类的）；了解基本的Linux服务，知道如何查看Linux的性能指标数据，知道基本的Linux下面的问题跟踪等。</p>

<h4>2. Nginx:</h4>

<p>在第一阶段的基础上面，了解复杂一些的Nginx配置；包括 多核配置、events、proxy_pass，sendfile/tcp_*配置，知道超时等相关配置和性能影响；知道nginx除了web server，还能够承担代理服务器、反向静态服务器等配置；知道基本的nginx配置调优；知道如何配置权限、编译一个nginx扩展到nginx；知道基本的nginx运行原理（master/worker机制，epoll），知道为什么nginx性能比apache性能好等知识；</p>

<h4>3. MySQL/MongoDB：</h4>

<p>在第一阶段的基础上面，在MySQL开发方面，掌握很多小技巧，包括常规SQL优化（group by/order by/rand优化等）；除了能够搭建MySQL，还能够冷热备份MySQL数据，还知道影响innodb/myisam性能的配置选项（比如key_buffer/query_cache/sort_buffer/innodb_buffer_pool_size/innodb_flush_log_at_trx_commit等），也知道这些选项配置成为多少值合适；另外也了解一些特殊的配置选项，比如  知道如何搭建mysql主从同步的环境，知道各个binlog_format的区别；知道MySQL的性能追查，包括slow_log/explain等，还能够知道基本的索引建立处理等知识；原理方面了解基本的MySQL的架构（Server+存储引擎），知道基本的InnoDB/MyISAM索引存储结构和不同（聚簇索引，B树）；知道基本的InnoDB事务处理机制；了解大部分MySQL异常情况的处理方案（或者知道哪儿找到处理方案）。条件允许的情况，建议了解一下NoSQL的代表MongoDB数据库，顺便对比跟MySQL的差别，同事能够在合适的应用场景安全谨慎的使用MongoDB，知道基本的PHP与MongoDB的结合开发。</p>

<h4>4. Redis/Memcached：</h4>

<p>在大部分中型系统里面一定会涉及到缓存处理，所以一定要了解基本的缓存；知道Memcached和Redis的异同和应用场景，能够独立安装 Redis/Memcached，了解Memcahed的一些基本特性和限制，比如最大的value值，知道PHP跟他们的使用结合；Redis了解基本工作原理和使用，了解常规的数据类型，知道什么场景应用什么类型，了解Redis的事务等等。原理部分，能够大概了解Memcached的内存结构（slab机制），redis就了解常用数据类型底层实现存储结构（SDS/链表/SkipList/HashTable）等等，顺便了解一下Redis的事务、RDB、AOF等机制更好</p>

<h4>5. PHP：</h4>

<p>除了第一阶段的能力，安装配置方面能够随意安装PHP和各种第三方扩展的编译安装配置；了解php-fpm的大部分配置选项和含义（如max_requests/max_children/request_terminate_timeout之类的影响性能的配置），知道mod_php/fastcgi的区别；在PHP方面已经能够熟练各种基础技术，还包括各种深入些的PHP，包括对PHP面向对象的深入理解/SPL/语法层面的特殊特性比如反射之类的；在框架方面已经阅读过最少一个以上常规PHP MVC框架的代码了，知道基本PHP框架内部实现机制和设计思想；在PHP开发中已经能够熟练使用常规的设计模式来应用开发（抽象工厂/单例/观察者/命令链/策略/适配器 等模式）；建议开发自己的PHP MVC框架来充分让开发自由化，让自己深入理解MVC模式，也让自己能够在业务项目开发里快速升级；熟悉PHP的各种代码优化方法，熟悉大部分PHP安全方面问题的解决处理；熟悉基本的PHP执行的机制原理（Zend引擎/扩展基本工作机制）；</p>

<h4>6. C/C++：</h4>

<p>开始涉猎一定的C/C++语言，能够写基本的C/C++代码，对基本的C/C++语法熟悉（指针、数组操作、字符串、常规标准API）和数据结构（链表、树、哈希、队列）有一定的熟悉下；对Linux下面的C语言开发有基本的了解概念，会简单的makefile文件编写，能够使用简单的GCC/GDB的程序编译简单调试工作；对基本的网络编程有大概了解。（本项是为了向更高层次打下基础）</p>

<h4>7. 前端：</h4>

<p>在第一阶段的基础上面，熟悉基本的HTTP协议（协议代码200/300/400/500，基本的HTTP交互头）；条件允许，可以在深入写出稍微优雅的HTML+CSS+JavaScript，或者能够大致简单使用某些前端框架（jQuery/YUI/ExtJS/RequireJS/BootStrap之类）；如果条件允许，可以深入学习JavaScript编程，比如闭包机制、DOM处理；再深入些可以读读jQuery源码做深入学习。（本项不做重点学习，除非对前端有兴趣）</p>

<h4>8. 系统设计：</h4>

<p>能够设计大部分中型系统的网站架构、数据库、基本PHP框架选型；性能测试排查处理等；能够完成类似：浏览器 -> CDN(Squid) -> Nginx+PHP -> 缓存 -> 数据库 结构网站的基本设计开发维护；能够支撑每天数百万到千万流量基本网站的开发维护工作；</p>

<h1>第三阶段：高级阶段 （高级PHP程序员）</h1>

<p><strong>重点</strong> ：除了基本的LNMP程序，还能够在某个方向或领域有深入学习。（纵深维度发展）</p>

<p><strong>目标</strong>：除了能够完成基本的PHP业务开发，还能够解决大部分深入复杂的技术问题，并且可以独立设计完成中大型的系统设计和开发工作；自己能够独立hold深入某个技术方向，在这块比较专业。（比如在MySQL、Nginx、PHP、Redis等等任一方向深入研究）</p>

<h4>1. Linux：</h4>

<p>除了第二阶段的能力，在Linux下面除了常规的操作和性能监控跟踪，还能够使用很多高级复杂的命令完成工作（watch/tcpdump/starce/ldd/ar等)；在shell脚本方面，已经能够编写比较复杂的shell脚本（超过500行）来协助完成很多包括备份、自动化处理、监控等工作的shell；对awk/sed/perl 等应用已经如火纯青，能够随意操作控制处理文本统计分析各种复杂格式的数据；对Linux内部机制有一些了解，对内核模块加载，启动错误处理等等有个基本的处理；同时对一些其他相关的东西也了解，比如NFS、磁盘管理等等；</p>

<h4>2. Nginx:</h4>

<p>在第二阶段的基础上面，已经能够把Nginx操作的很熟练，能够对Nginx进行更深入的运维工作，比如监控、性能优化，复杂问题处理等等；看个人兴趣，更多方面可以考虑侧重在关于Nginx工作原理部分的深入学习，主要表现在阅读源码开始，比如具体的master/worker工作机制，Nginx内部的事件处理，内存管理等等；同时可以学习Nginx扩展的开发，可以定制一些自己私有的扩展；同时可以对Nginx+Lua有一定程度的了解，看看是否可以结合应用出更好模式；这个阶段的要求是对Nginx原理的深入理解，可以考虑成为Nginx方向的深入专业者。</p>

<h4>3. MySQL/MongoDB：</h4>

<p>在第二阶段的基础上面，在MySQL应用方面，除了之前的基本SQL优化，还能够在完成一些复杂操作，比如大批量数据的导入导出，线上大批量数据的更改表结构或者增删索引字段等等高危操作；除了安装配置，已经能够处理更多复杂的MySQL的问题，比如各种问题的追查，主从同步延迟问题的解决、跨机房同步数据方案、MySQL高可用架构等都有涉及了解；对MySQL应用层面，对MySQL的核心关键技术比较熟悉，比如事务机制（隔离级别、锁等）、对触发器、分区等技术有一定了解和应用；对MySQL性能方面，有包括磁盘优化（SAS迁移到SSD）、服务器优化（内存、服务器本身配置）、除了二阶段的其他核心性能优化选项（innodb_log_buffer_size/back_log/table_open_cache/thread_cache_size/innodb_lock_wait_timeout等）、连接池软件选择应用，对show *（show status/show profile）类的操作语句有深入了解，能够完成大部分的性能问题追查；MySQL备份技术的深入熟悉，包括灾备还原、对Binlog的深入理解，冷热备份，多IDC备份等；在MySQL原理方面，有更多了解，比如对MySQL的工作机制开始阅读部分源码，比如对主从同步（复制）技术的源码学习，或者对某个存储引擎（MyISAM/Innodb/TokuDB）等等的源码学习理解，如果条件允许，可以参考CSV引擎开发自己简单的存储引擎来保存一些数据，增强对MySQL的理解；在这个过程，如果自己有兴趣，也可以考虑往DBA方向发展。MongoDB层面，可以考虑比如说在写少读多的情况开始在线上应用MongoDB，或者是做一些线上的数据分析处理的操作，具体场景可以按照工作来，不过核心是要更好的深入理解RMDBS和NoSQL的不同场景下面的应用，如果条件或者兴趣允许，可以开始深入学习一下MongoDB的工作机制。</p>

<h4>4. Redis/Memcached：</h4>

<p>在第二阶段的基础上面，能够更深入的应用和学习。因为Memcached不是特别复杂，建议可以把源码进行阅读，特别是内存管理部分，方便深入理解；Redis部分，可以多做一些复杂的数据结构的应用（zset来做排行榜排序操作/事务处理用来保证原子性在秒杀类场景应用之类的使用操作）；多涉及aof等同步机制的学习应用，设计一个高可用的Redis应用架构和集群；建议可以深入的学习一下Redis的源码，把在第二阶段积累的知识都可以应用上，特别可以阅读一下包括核心事件管理、内存管理、内部核心数据结构等充分学习了解一下。如果兴趣允许，可以成为一个Redis方面非常专业的使用者。</p>

<h4>5. PHP：</h4>

<p>作为基础核心技能，我们在第二阶段的基础上面，需要有更深入的学习和应用。从基本代码应用上面来说，能够解决在PHP开发中遇到95%的问题，了解大部分PHP的技巧；对大部分的PHP框架能够迅速在一天内上手使用，并且了解各个主流PHP框架的优缺点，能够迅速方便项目开发中做技术选型；在配置方面，除了常规第二阶段会的知识，会了解一些比较偏门的配置选项（php auto_prepend_file/auto_append_file），包括扩展中的一些复杂高级配置和原理（比如memcached扩展配置中的memcache.hash_strategy、apc扩展配置中的apc.mmap_file_mask/apc.slam_defense/apc.file_update_protection之类的）；对php的工作机制比较了解，包括php-fpm工作机制（比如php-fpm在不同配置机器下面开启进程数量计算以及原理），对zend引擎有基本熟悉（vm/gc/stream处理），阅读过基本的PHP内核源码（或者阅读过相关文章），对PHP内部机制的大部分核心数据结构（基础类型/Array/Object）实现有了解，对于核心基础结构（zval/hashtable/gc）有深入学习了解；能够进行基本的PHP扩展开发，了解一些扩展开发的中高级知识（minit/rinit等），熟悉php跟apache/nginx不同的通信交互方式细节（mod_php/fastcgi）；除了开发PHP扩展，可以考虑学习开发Zend扩展，从更底层去了解PHP。</p>

<h4>6. C/C++：</h4>

<p>在第二阶段基础上面，能够在C/C++语言方面有更深入的学习了解，能够完成中小型C/C++系统的开发工作；除了基本第二阶段的基础C/C++语法和数据结构，也能够学习一些特殊数据结构（b-tree/rb-tree/skiplist/lsm-tree/trie-tree等）方便在特殊工作中需求；在系统编程方面，熟悉多进程、多线程编程；多进程情况下面了解大部分多进程之间的通信方式，能够灵活选择通信方式（共享内存/信号量/管道等）；多线程编程能够良好的解决锁冲突问题，并且能够进行多线程程序的开发调试工作；同时对网络编程比较熟悉，了解多进程模型/多线程模型/异步网络IO模型的差别和选型，熟悉不同异步网络IO模型的原理和差异（select/poll/epoll/iocp等），并且熟悉常见的异步框架（ACE/ICE/libev/libevent/libuv/Boost.ASIO等）和使用，如果闲暇也可以看看一些国产自己开发的库（比如muduo）；同时能够设计好的高并发程序架构（leader-follow/master-worker等）；了解大部分C/C++后端Server开发中的问题（内存管理、日志打印、高并发、前后端通信协议、服务监控），知道各个后端服务RPC通信问题（struct/http/thirft/protobuf等）；能够更熟络的使用GCC和GDB来开发编译调试程序，在线上程序core掉后能够迅速追查跟踪解决问题；通用模块开发方面，可以积累或者开发一些通用的工具或库（比如异步网络框架、日志库、内存池、线程池等），不过开发后是否应用要谨慎，省的埋坑去追bug；</p>

<h4>7. 前端：</h4>

<p>深入了解HTTP协议（包括各个细致协议特殊协议代码和背后原因，比如302静态文件缓存了，502是nginx后面php挂了之类的）；除了之前的前端方面的各种框架应用整合能力，前端方面的学习如果有兴趣可以更深入，表现形式是，可以自己开发一些类似jQuery的前端框架，或者开发一个富文本编辑器之类的比较琐碎考验JavaScript功力；</p>

<h4>8. 其他领域语言学习：</h4>

<p>在基础的PHP/C/C++语言方面有基本积累，建议在当前阶段可以尝试学习不同的编程语言，看个人兴趣爱好，脚本类语言可以学学 Python/Ruby 之类的，函数式编程语言可以试试 Lisp/Haskell/Scala/Erlang 之类的，静态语言可以试试 Java/Golang，数据统计分析可以了解了解R语言，如果想换个视角做后端业务，可以试试 Node.js还有前面提到的跟Nginx结合的Nginx_Lua等。学习不同的语言主要是提升自己的视野和解决问题手段的差异，比如会了解除了进程/线程，还有轻量级协程；比如在跨机器通信场景下面，Erlang的解决方案简单的惊人；比如在不想选择C/C++的情况下，还有类似高效的Erlang/Golang可用等等；主要是提升视野。</p>

<h4>9. 其他专业方向学习：</h4>

<p>在本阶段里面，会除了基本的LNMP技能之外，会考虑一些其他领域知识的学习，这些都是可以的，看个人兴趣和长期的目标方向。目前情况能够选择的领域比较多，比如、云计算（分布式存储、分布式计算、虚拟机等），机器学习（数据挖掘、模式识别等，应用到统计、个性化推荐），自然语言处理（中文分词等），搜索引擎技术、图形图像、语音识别等等。除了这些高大上的，也有很多偏工程方面可以学习的地方，比如高性能系统、移动开发（Android/IOS）、计算机安全、嵌入式系统、硬件等方向。</p>

<ol>
<li>系统设计：
系统设计在第二阶段的基础之上，能够应用掌握的经验技能，设计出比较复杂的中大型系统，能够解决大部分线上的各种复杂系统的问题，完成类似 浏览器 -> CDN -> 负载均衡 ->接入层 -> Nginx+PHP -> 业务缓存 -> 数据库 -> 各路复杂后端RPC交互（存储后端、逻辑后端、反作弊后端、外部服务） -> 更多后端 酱紫的复杂业务；能够支撑每天数千万到数亿流量网站的正常开发维护工作。</li>
</ol>


<h1>第四阶段：架构阶段 （架构师）</h1>

<p>ps: 暂时不展开讨论，等下次专门撰文来描述补充本部分内容</p>

<p>第五阶段：专家阶段（方向领域专家）
ps：高大上，这块不展开讨论 ^_^</p>

<p>第六阶段：科学家阶段
ps：高大上，这块不展开讨论 ^_^</p>

<p>转载：<a href="http://blog.csdn.net/heiyeshuwu">黑夜路人</a>的博客</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant的网络设置]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/22/vagrant-network/"/>
    <updated>2015-08-22T14:34:46+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/22/vagrant-network</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>今天要做Mysql主从配置，就需要两台Ubuntu的服务器，所以先要研究下Vagrant的网络配置。</p>

<p>Vagrant有三种网络配置</p>

<ol>
<li>Forwarded port</li>
<li>Private network</li>
<li>Public network</li>
</ol>


<h1>Private Network</h1>

<p>我的需求是两台Ubutu在同一网段，并且都访问主机和外部网络。所以我选择private network。 它的缺点是外部网络无法访问。</p>

<p>设定语法为：</p>

<pre><code>config.vm.network "private_network", ip: "192.168.50.4"
</code></pre>

<p>配置hostname</p>

<pre><code>config.vm.hostname = "master"
</code></pre>

<h1>参考链接</h1>

<p><a href="http://www.williamsang.com/archives/2401.html?utm_source=tuicool#private">Vagrant网络配置</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[负载计算方法及不同语言开发解决性能问题的思想等]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/21/performance/"/>
    <updated>2015-08-21T14:52:36+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/21/performance</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>当项目复杂度和用户数提高的时候，我们常常会遇到以下问题：卡、 挂、 数据备份、 数据分析、 安全、 24小时在线、 多平台、 多端、 跨地域、 实时性强。</p>

<p>总结起来就是以下4个方面：</p>

<ol>
<li>性能问题</li>
<li>交互问题</li>
<li>安全问题</li>
<li>可持续发展与维护</li>
</ol>


<h1>性能计算</h1>

<h3>不同语言开发解决性能问题的思想</h3>

<ol>
<li><strong>PHP -> 多进程</strong></li>
</ol>


<p>PHP通常是和Apache一起来工作，将PHP作为Apache的一个模块来使用，或者采用FastCGI方式通过FPM与web容器通信。我们的每一个用户的请求都将使用一个进程来处理用户请求。</p>

<ol>
<li><strong>JAVA -> 多线程</strong></li>
</ol>


<p>单个进程中同时有多个函数在运行，我们就认为这个应用时多线程的。</p>

<ol>
<li><strong>NodeJs -> 单进程单线程</strong></li>
</ol>


<p>Nignx 与 nodejs jetty 提升效率的方法相同。</p>

<p>都是 异步&amp;非阻塞。</p>

<h4>阻塞</h4>

<p>Apache接收到用户的请求 -> 创建php进程处理请求 -> php通过Http协议解析获取用户提交数据 -> 进行数据过滤与加工 -> (接收用户上传的文件) ->
(对图片缩放/给图片加水印) -> 将数据插入到数据库  -> 等待数据处理完成  -> 加载模板 -> 输出页面 -> 结束进程 -> 回收资源</p>

<p>PHP是单线程的，所以要等待用户上传文件、等待对图片处理、等待插入数据库的结果。一直在等待，所以耗时间。而nodejs是基于事件的编程、非阻塞，效率高。</p>

<h1>高负载项目优化</h1>

<h4>IO  Input/Output</h4>

<ul>
<li>磁盘IO</li>
<li>网络IO</li>
<li>数据库IO</li>
</ul>


<h4>性能测试</h4>

<ul>
<li>php 系能测试</li>
<li>mysql读写性能测试</li>
<li>文件 读写性能测试</li>
</ul>


<h4>测试工具</h4>

<ul>
<li>Apache ab</li>
<li>Apache JMeter</li>
</ul>


<h2>负载的计算方法</h2>

<ul>
<li>网络连接最大并发数 B</li>
<li>单次请求的处理时间  dt</li>
<li>用户n秒请求一次</li>
<li>发摩擦系数s ： 一般 0.65</li>
<li>负载 = B/dt * n</li>
</ul>


<p>例子：</p>

<ul>
<li>网络连接最大并发数 B = 1000 次</li>
<li>单次请求的处理时间  dt = 3秒</li>
<li>用户30秒请求一次 n = 30秒</li>
<li>发摩擦系数s ： 一般 0.65</li>
<li>每秒能处理的请求数 = 1000次 /3秒</li>
<li>负载 = 每秒能处理的请求数 * 30秒 * 0.65 = 6500</li>
</ul>


<p>总结：</p>

<ol>
<li>负载 就是ＷEB服务能够支持的最大访问人数，不卡，不Down机。它取决于3点（最重要的）：网络最大连接数、单次请求处理时间 和 用户多少秒请求一次。</li>
<li>对网络连接最大并发数 B 起决定性作用的依次是带宽、内存、CPU、操作系统。</li>
<li>减少单次处理请求时间，对程序员说很困难。</li>
<li>提高用户请求一次的时间是一个有效的办法，所以一个好的网页交互师很重要。比说增加验证码、提示框等。</li>
</ol>


<h4>集群：</h4>

<p>在同一个项目，多台服务器一起工作</p>

<h1>数据库优化原理</h1>

<ol>
<li>优化第一条：针对查询建索引。where条件要匹配索引，叫做命中索引。</li>
</ol>


<p>问： 索引为什么会加速查询？</p>

<p>答：因为添加索引，会优化搜索算法，使用了二叉树、平衡二叉树、红黑树升级的算法。建立索引，查询速度会集合倍提高。 牺牲了写入数据的效率，换来了查询的速度。但因为我们大部分都是查询，写入的少。性能不会凭空产生</p>

<p>容器：内存中可以用来保存其他对象的对象，比如链表、数组、hashmap</p>

<p>资源：应用程序从内存意外的地方读取或写入数据的对象成为资源，比如网络，比如磁盘文件。涉及资源IO的程序通常速度都会比较慢。</p>

<p>结果集： 自己是个容器，从结果集获取数据的本质是一种资源，也是一个集合，不能有重复。（<strong>结果集是一个保存指向数据库资源指针的集合</strong>）</p>

<p>当多个条件查询的时候，and条件表示左右两个条件搜索到的结果集做交集。
如果使用or连接两个条件，左右两个条件搜索的结果做并集。</p>

<p>selec &hellip; limit 0, 20;</p>

<p>遍历结果集，从数据库文件里面取。</p>

<p>select &hellip; where id = 1;</p>

<p>   &hellip;.</p>

<p>select &hellip;. where id = 20;</p>

<p>分页的作用：让每一次数据查询返回的结果集可控。</p>

<p>数据的查询一定要分页。</p>

<p>当写入大于查询的时候，要去索引，去掉只剩下一个id。</p>

<h3>读写差异定制</h3>

<p>数据库主从，主库没有索引，从库加索引。数据库的主从原理是根据主库的日志，把主库的bin log日志再从新执行一遍，这叫读写差异定制。</p>

<h3>自建索引</h3>

<p>如果是单个数据库。</p>

<p>建立索引越多-> 插入一条数据时间长->锁表时间长 -> 其他记录等待时间长
并发的时候， 堵车撞车几率就大。就容易让数据库挂掉。</p>

<p>不锁表，MySQL的连接数也会增加，满了。PHP连不上mYSQL, Nginx连不上mysql，会报502。索引越多越糟糕</p>

<p>user  基本表
user_index   保存搜索条件。</p>

<p>一台机器，专门用来保存数据。另一台数据用来保存索引。
或者一个库用来保存数据，另一个库来保存索引。</p>

<p>每天固定时间建立索引。</p>

<p>这叫做<strong>异步建索引</strong></p>

<h4>sphinx</h4>

<p>爬数据库的爬虫，为我们的数据库建立索引。</p>

<p>能够大幅提升性能，对小说站，资讯站很有用。但是优缺点：不是实时索引。</p>

<h4>redis索引</h4>

<p>微博 把索引放到了redis里面，建立实时索引。</p>

<p>插入数据的时候，把索引写到redis里面。 查询数据，从redis里把满足用户的id查询出来。再查mysql数据库。 每一条索引都命中id，效率会特别高。</p>

<p>list可以保存索引，hash缓存对象，set用来交并集处理。所以，redis有建立索引和保存数据的作用。</p>

<p>redis：1.数据结构支持（消息队列） 2. 缓存 3. 索引（要存储到数据库）</p>

<h4>　笛卡尔集</h4>

<p>Ａ　Ｂ　Ｃ　三个表</p>

<p>Ａ表搜索１０条记录找到１条，Ｂ表搜索到５条记录找到１条，Ｃ表搜索５条记录。</p>

<p>连表的话，会搜索１００条记录。</p>

<p>根据业务逻辑做优化。</p>

<h3>分表分库</h3>

<ul>
<li>横向： 横切一刀， 表的数据被分成两部分。</li>
<li>纵向： 刷刷两刀，一个表的字段减少。</li>
</ul>


<p>优化最求：所有的事情可控。</p>

<p>小规模分表、大规模分库。</p>

<p><strong>横向切表</strong>
tb_user</p>

<p>tb_usser0</p>

<p>tb_usser1</p>

<p>tb_usser2</p>

<p>tb_usser3</p>

<p><strong>纵向且表，表重构</strong></p>

<p>tb_user_login</p>

<p>tb_user_info</p>

<p>tb_user_account</p>

<p>多主多从。
多主一从。
互为主从。</p>

<h3>MongDb</h3>

<p>支持平行扩容和分片</p>

<p>高性能、高并发、海量扩容</p>

<p>js + mongodb: 效率高、速度快、并发高、数据扩容方便</p>

<h1>Mysql主从配置</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker灵雀云]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/21/alauda/"/>
    <updated>2015-08-21T02:24:30+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/21/alauda</id>
    <content type="html"><![CDATA[<p>今晚把博客迁移到了<a href="http://alauda.cn">灵雀云</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Redis实现消息队列]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/20/redis-message-queue/"/>
    <updated>2015-08-20T22:40:48+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/20/redis-message-queue</id>
    <content type="html"><![CDATA[<h1>目标</h1>

<ol>
<li>用户注册时，将注册信息（例如用户名、密码、邮箱等）Push到Redis的List里。</li>
<li>用PHP-CLI脚本，读取队列的消息，存取到数据库。</li>
</ol>


<p>代码如下：</p>

<ul>
<li><a href="https://github.com/hildalove/tiny/blob/master/Tiny/MessageQueue/PHPMQ.php">PHPMQ CLASS</a></li>
<li><a href="https://github.com/hildalove/tiny/blob/master/Tiny/MessageQueue/UserMQ.php">UserMQ CLASS</a></li>
<li><a href="https://github.com/hildalove/tiny/blob/master/App/Controller/MQ.php">user reg Controller</a></li>
<li><a href="https://github.com/hildalove/tiny/blob/master/cron/user_mq.php">PHP-CLI CRON</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Phpredis小结]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/19/phpredis/"/>
    <updated>2015-08-19T15:28:13+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/19/phpredis</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>PHP 安装redis有两种方法，这篇文章所阐述的内容是以扩展的方式安装phpredis</p>

<h1>Redis</h1>

<pre><code>apt-get install redis-server
apt-get install php5-redis
</code></pre>

<p>我们通过 apt-get安装的扩展配置将出现在  /etc/php5/mods-available</p>

<p>把将要启用的模块的配置文件做一个软连接到
/etc/php5/apache2/conf.d  (LAMP/LNAMP) <br/>
/etc/php5/fpm/conf.d (LNMP )</p>

<p>通常情况系统会帮我们做好软连接.</p>

<p>redis的应用场景：
1. 用户访问量
2. 用户活跃度，每日的访问量 setbit
3. 存储Session</p>

<p>提供内存缓存
数据结构</p>

<p>postgress 做集群和横向扩容的时候比较麻烦</p>

<p>用redis的hash和list做索引，用mysql做数据存储
自建索引（hash list）</p>

<p>用list记录用户访问页面，堆栈</p>

<p>首页做缓存，放到redis里面</p>

<h2>redis高级数据结构 bitmaps 和 HyperLogLogs</h2>

<p>php单进程的
请求结束后，进程回收。
只能够保证每次请求连接一次redis</p>

<h2>新的数据结构</h2>

<p>bitmaps,
HyperLogLogs: 占用少量内容，</p>

<p>计算内存消耗，计算CPU消耗</p>

<p><strong>性能和开销</strong></p>

<p>一天人均15次，每天100万用户访问。
每次用户访问都写入日志。
用户的每一次会话都产生一次id</p>

<p>目标：搭建每日访问100万用户的网站架构。</p>

<p>Redis的Pub/Sub</p>

<h3>redis3.0</h3>

<p>系统必须装有gcc</p>

<p>redis 3.0安装
wget <a href="http://download.redis.io/releases/redis-3.0.0.tar.gz">http://download.redis.io/releases/redis-3.0.0.tar.gz</a></p>

<p>tar -zxvf redis-3.0.0.tar.gz
cd redis-3.0.0
make
make install</p>

<p>编译好的文件默认在src目录中</p>

<h1>Todo</h1>

<p>写一个phpredis的类，有以下要求：
1. 单例模式，只实例化一次Redis
2. 封装connect, auth, 选择哪个库</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建自己的PHP开发框架]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/17/buid-your-own-php-framework/"/>
    <updated>2015-08-17T17:24:04+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/17/buid-your-own-php-framework</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>想要搭建一个自己的PHP框架，需要哪些功能呢？</p>

<ul>
<li>单一入口</li>
<li>类的自动加载</li>
<li>MVC</li>
<li>易于配置</li>
<li>有电子商务相关的接口：购物车，订单，支付</li>
</ul>


<h1>如何实现</h1>

<h3>单一入口</h3>

<p>nginx配置</p>

<pre><code>location / {
    try_files $uri $uri/ /index.php?/$uri;
}
</code></pre>

<ol>
<li>将uri全部定向到index.php</li>
<li>在入口文件，实现路由分发，实化例Ccontroller类，然后调用方法。</li>
</ol>


<h3>类的自动加载</h3>

<ol>
<li>维护命名空间与绝对路径的映射</li>
<li>使用spl_autoload_register注册函数，当调用不存在的类时，自动加载。</li>
</ol>


<h3>MVC</h3>

<ol>
<li>每个Controller继承一个Controoler，在这个类中实现存储数据和include模板文件</li>
<li>用工厂模式和注册树模式来实例化对应的Model类</li>
</ol>


<h3>易于配置</h3>

<ol>
<li>定义Config类实现\ArrayAccess， 然后加载config目录下的所有文件。也是用注册树和工厂模式。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Composer自动加载的原理]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/17/composer-autoload/"/>
    <updated>2015-08-17T15:29:35+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/17/composer-autoload</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>当PHP引擎试图实例化未知类的操作时，就会调用<strong>autoload(),并将类名当做字符串传递给它。但</strong>autoload()有个缺点，就是 一个进程中只能定义一次。这是就可以使用spl_autoload_register()函数。它可以把函数注册到__autoload队列中. 现在我们来看看composer是如何实现自动加载的。</p>

<p>composer.json 文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;autoload&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;classmap&quot;</span> <span class="p">:</span> <span class="p">[</span>
</span><span class='line'>            <span class="s2">&quot;app/controllers&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="s2">&quot;app/models&quot;</span>
</span><span class='line'>        <span class="p">]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们composer dump-autoload的时候，文件/vendor/composer/autoload_clasmap.php会把类名和绝对地址做个想射。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="nv">$vendorDir</span> <span class="o">=</span> <span class="nb">dirname</span><span class="p">(</span><span class="nb">dirname</span><span class="p">(</span><span class="k">__FILE__</span><span class="p">));</span>
</span><span class='line'><span class="nv">$baseDir</span> <span class="o">=</span> <span class="nb">dirname</span><span class="p">(</span><span class="nv">$vendorDir</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="k">array</span><span class="p">(</span>
</span><span class='line'>    <span class="s1">&#39;Article&#39;</span> <span class="o">=&gt;</span> <span class="nv">$baseDir</span> <span class="o">.</span> <span class="s1">&#39;/app/models/Article.php&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;BaseController&#39;</span> <span class="o">=&gt;</span> <span class="nv">$baseDir</span> <span class="o">.</span> <span class="s1">&#39;/app/controllers/BaseController.php&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;HomeController&#39;</span> <span class="o">=&gt;</span> <span class="nv">$baseDir</span> <span class="o">.</span> <span class="s1">&#39;/app/controllers/HomeController.php&#39;</span><span class="p">,</span>
</span><span class='line'><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>首页index.php调用composer的autoload文件</p>

<pre><code>require '../vendor/autoload.php';
</code></pre>

<p>会调用ComposerAutoloaderInit类的静态方法getLoader(）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="o">&lt;?</span><span class="nx">php</span>
</span><span class='line'><span class="k">require_once</span> <span class="nx">__DIR__</span> <span class="o">.</span> <span class="s1">&#39;/composer&#39;</span> <span class="o">.</span> <span class="s1">&#39;/autoload_real.php&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="nx">ComposerAutoloaderInita488c85ce5c077906f9c1829b6492f6b</span><span class="o">::</span><span class="na">getLoader</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>verdor/composer/目录下有四个配置文件：</p>

<ul>
<li>autoload_classmap.php：  要加载的class映射</li>
<li>autoload_files.php：     要加载的文件</li>
<li>autoload_namespaces.php：    psr-0标准</li>
<li>psr4.php：                   psr-4标准</li>
</ul>


<p>getLoader(）这个方法会先把这些配置文件放到ClassLoader的私有属性中。</p>

<p>然后通过$loader->register(true);来调用spl_autoload_register()</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">public</span> <span class="k">function</span> <span class="nf">register</span><span class="p">(</span><span class="nv">$prepend</span> <span class="o">=</span> <span class="k">false</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nb">spl_autoload_register</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">&#39;loadClass&#39;</span><span class="p">),</span> <span class="k">true</span><span class="p">,</span> <span class="nv">$prepend</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>spl_autoload_register()把loadClass()方法注册到了autoload队列中,然后当PHP引擎试图实例化未知类的操作时，就会根据类名和命名空间加载这个类文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">public</span> <span class="k">function</span> <span class="nf">loadClass</span><span class="p">(</span><span class="nv">$class</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nv">$file</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">findFile</span><span class="p">(</span><span class="nv">$class</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">includeFile</span><span class="p">(</span><span class="nv">$file</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h1>psr-0 与psr - 4 的不同</h1>

<ol>
<li>PSR-4中，在类名中使用下划线没有任何特殊含义。而PSR-0则规定类名中的下划线_会被转化成目录分隔符。</li>
<li>composer的PSR-4带来更简洁的文件结构。</li>
<li>参考：<a href="http://segmentfault.com/a/1190000000380008">PSR-4——新鲜出炉的PHP规范</a></li>
</ol>


<p>总结：
1. 命名空间前缀对应相应的文件夹
2. 类名和文件名相同，文件后缀为PHP</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Composer搭建自己的PHP框架]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/15/php-framework-hilda/"/>
    <updated>2015-08-15T08:45:27+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/15/php-framework-hilda</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>今天参照<a href="http://lvwenhan.com/php/410.html">教程</a>，使用Composer来搭建自己的框架。</p>

<p>我给它起了一个名字叫做Hilda PHP Framework.</p>

<p>通过构建这样的微型框架，有利于我们学习框架的自动加载、单入口文件、MVC的原理，因为需要什么，就加载什么。这样，自己的框架就像搭积木一样完成了，避免了重复发明轮子的烦恼。</p>

<h2>Hilda特性：</h2>

<ul>
<li>单入口文件</li>
<li>MVC架构</li>
<li>微型路由，基于<a href="https://packagist.org/packages/codingbean/macaw">codingbean/macaw</a></li>
<li>数据库的ORM 采用 <a href="http://laravel-china.org/docs/5.0/eloquent">Eloquent</a></li>
</ul>


<h1>安装方法</h1>

<p>它的Github地址为：<a href="https://github.com/FengHan/hilda">https://github.com/FengHan/hilda</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis数据结构类型2]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/14/redis-datastructure2/"/>
    <updated>2015-08-14T14:02:41+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/14/redis-datastructure2</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本文记录是极客学院 <a href="http://www.jikexueyuan.com/course/1693_1.html?ss=2">Redis系列课程</a>的文字记录</p>

<p><a href="http://redisdoc.com/">文档</a>
<a href="http://redisdesktop.com/download">Redis Desktop Manager</a></p>

<h1>集合类型与有序集合类型</h1>

<h3>集合类型概述</h3>

<p>Set， string类型的无序集合，不允许有重复元素。通过hash table实现，可以取并集、交集、差集，可以实现sns中好友推荐和blog的tag功能。</p>

<p>底层实现： 整数集合（都是整数值，数量不超过512），字典。</p>

<p>存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择。</p>

<p>集合还提供了判断某个成员是否在一个set集合内的接口。</p>

<p>sadd srem spop
- sadd key member 返回值，成功的数量
- srem key member 返回值，删除的的数量， 可删除多个
- spop key 随机弹出一个元素，返回弹出的元素</p>

<h2>获取</h2>

<ul>
<li>smembers key  查看元素</li>
<li>srandmember key count  count>0 返回不重复， count &lt; 0,可能重复</li>
<li>SISMEMBER key member  集合中是否存在key</li>
<li>SCARD member  统计集合个数</li>
</ul>


<p>运算命令
- SDIFF A B 差集， 所有属于A，不属于B; 1 2 3， 2 3 4 => 1
- SINTER A B  交集  所有属于A, 且属于B
- SUNION A B  并集
- SDIFFSTORE  不会返回结果，而是会存储在dest结果中</p>

<h2>Redis 有序集合类型概述</h2>

<p>Sorted Sort
底层实现：</p>

<ul>
<li>压缩列表（数量不超过128，且小于64字节）、</li>
<li>跳跃表（skiplist）</li>
</ul>


<p>需要有序的，不重复的，可以选择它。 可以构建优先级的队列。</p>

<p>有序集合类型与列表的比较，相同点：</p>

<ul>
<li>二者都是有序的。</li>
<li>二者都可以获得某一范围的元素。</li>
</ul>


<p>不同点：</p>

<ul>
<li>列表通过链表实现，获取靠近两端的数据速度快，适合“新鲜事”和“日志”。</li>
<li>有序集合使用散列表和跳跃表实现，读取中间数据速度也快。</li>
<li>列表不能简单的调整元素的位置，而有序集可以。</li>
<li>有序集合比列表类型更耗内存。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx错误信息汇总]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/14/nginx-error-msg/"/>
    <updated>2015-08-14T12:18:19+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/14/nginx-error-msg</id>
    <content type="html"><![CDATA[<h3>Nginx服务器返回403</h3>

<p>开了Astrill VPN, 关闭Astrill，即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用百度脑图来准备面试]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/14/interview-prepare/"/>
    <updated>2015-08-14T11:03:37+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/14/interview-prepare</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>要开始找工作了，用百度脑图来整理了一下项目经验和PHP相关知识
<a href="http://naotu.baidu.com/viewshare.html?shareId=axpmx5cuomos">点此</a></p>

<h3>关于MindMapper</h3>

<p>以前做脑图一直用MindMapper，我觉得它的优点：</p>

<ol>
<li>样子好看</li>
<li>快捷键好用，可以不用动鼠标，就完成脑图</li>
</ol>


<p>缺点：</p>

<ol>
<li>付费软件</li>
<li>没有中文版，第三方汉化包做得不好，中文写着写着顺序就乱了</li>
<li>不便于分享，以前写的很多脑图，现在都不知道放在那里了</li>
<li>生成的脑图，需要用专门的软件打开，为了一个脑图，要安装软件，费时</li>
</ol>


<h3>　百度脑图的优点：</h3>

<ol>
<li>开源，源代码放在了GitHub上</li>
<li>快捷键好用</li>
<li>便于分享</li>
<li>样子还不错</li>
<li>用浏览器随时可更改，便于维护
６. 百度 FEX 团队的 f-cube 小组（原 UEditor 小组）维护，靠谱</li>
<li>左下角有整个文件的预览，对内容较多的脑图很有帮助</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/13/sort/"/>
    <updated>2015-08-13T19:50:20+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/13/sort</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本文是记录北京大学在Coursera上的《高级数据结构与算法》的课程。</p>

<p><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/lecture/J5sEw/pai-xu-wen-ti-de-ji-ben-gai-nian">排序</a></p>

<h3>基本概念</h3>

<ul>
<li>序列 Sequence:线性表 :有记录组成</li>
<li>记录 Record： 结点，进行排序的基本单位</li>
<li>关键码Key： 唯一确定记录的一个或多个域</li>
<li>排序码 Sort Key： 作为排序运算依据的一个或多个域</li>
</ul>


<p>排序：</p>

<ul>
<li>将序列中的记录 Record 按照排序码顺序排列起来</li>
<li>排序码Sort Key域的值具有不减（或不增）的顺序</li>
</ul>


<p>内排序：</p>

<ul>
<li>整个排序过程在内存中完成</li>
</ul>


<p>&lt;=  不减序</p>

<blockquote><p>= 不增序</p></blockquote>

<p>正序</p>

<p>逆序</p>

<p>稳定性：</p>

<ul>
<li>存在多个具有相同排序码的记录</li>
<li>排序后这些记录的相对次序保持不变</li>
</ul>


<p>稳定性的证明： 形式证明</p>

<p>不稳定的证明： 反例说明</p>

<p>衡量标准：</p>

<ul>
<li>时间代价： 记录比较和移动的次数</li>
<li>空间代价</li>
<li>算法本身的复杂度</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Phpstorm]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/12/phpstorm/"/>
    <updated>2015-08-12T08:35:25+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/12/phpstorm</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本文是<a href="https://laracasts.com/series/how-to-be-awesome-in-phpstorm/episodes/2">Laracasts的phpstorm视频教程</a>的文字记录版</p>

<p>注意事项：本文所述快捷键和你的会不同，是我自定义的，我已将配置文件放到了<a href="https://github.com/FengHan/phpstorm">Github/PHPstorm</a></p>

<h3>Hello</h3>

<p>Google  phpstorm eap (easy access platform)</p>

<h3>Minimalism 精简IDE</h3>

<ul>
<li>Ctrl + 1 打开关闭侧边栏  : Way的习惯是尽可能的关闭</li>
<li>Navicat -> Class   打开类</li>
<li>Navicat -> Symbol 打开函数</li>
<li>View  -> Start Button 隐藏状态栏 ; Way 不需要它</li>
<li>View -> NavigationBar 隐藏导航；Way从来不用它</li>
<li><p>View ->  Toolbar  隐藏工具栏 ；Way都用快捷键</p></li>
<li><p>File-> Settings-> 搜索Breadcrumbs ，隐藏它，重启phpstorm</p></li>
<li><p>File-> Settings->Colors &amp; Fonts</p></li>
<li>Save AS : demo-theme，</li>
<li>size： 15  字体大小
line： spacing： 1.4 字间距</li>
<li><a href="http://daylerees.github.io/">http://daylerees.github.io/</a>查看主题</li>
<li><p><a href="https://github.com/daylerees/colour-schemes">https://github.com/daylerees/colour-schemes</a></p>

<p>  顺便介绍一下phpstorm主题安装方法：</p>

<p>  1、下载主题安装包：以icls结尾的文件，把安装包文件复制到config目录</p>

<p>  C:\Users\Administrator.WebIde90\config\colors
  wget <a href="https://raw.githubusercontent.com/daylerees/colour-schemes/master/jetbrains/earthsong.icls">https://raw.githubusercontent.com/daylerees/colour-schemes/master/jetbrains/earthsong.icls</a>
  注：这里以window系统为例。
  2、重启phpstorm</p>

<p>  3、File->Settings->Colors&amp;Fonts，选择相应的主题包，即可。</p></li>
<li><p>右键单击 文件名top， tap placement ，勾选none</p></li>
</ul>


<h3>Color IDE</h3>

<p>HELP -> FIND ACTION  搜索plugins -> configure plugins
Brower rpositersies 搜索Colors -> 选择color ide 安装</p>

<h3>Two Important Keybindings</h3>

<ul>
<li>两个重要的按键</li>
<li>一个是 Navicat -> file</li>
<li><p>另一个是  Navicat -> file structure</p></li>
<li><p>File -> settings -> keymap -> save as michaele&rsquo;s key</p></li>
<li><p>File -> settings -> keymap -> 点击搜索小图标 -> 输入键盘组合</p></li>
</ul>


<p>双击 -> remore ctrl + shift + o</p>

<p>我自定义的快捷键</p>

<ul>
<li><p>alt + p -> open file</p></li>
<li><p>alt + r -> file structure</p></li>
<li>alt + e ->  recent files</li>
<li>alt + o -> class</li>
<li><p>alt + t -> Refactor this</p></li>
<li><p>alt + shift + a -> enter action or option name</p></li>
<li>alt + shift + o -> sylbol</li>
<li>alt + n -> new file</li>
<li>ctrl + w 关闭页面</li>
<li><p>alt + , 设置</p></li>
<li><p>ctrl + w 关闭当前页面</p></li>
<li><p>ctrl + 1</p></li>
</ul>


<h3>Create New Files Quickly</h3>

<p>alt + 向上箭头  和 alt + n 快捷键在快速的创建文件</p>

<h3>Custom File Templates</h3>

<p>Ctrl + ，  file and code templates</p>

<h3>Live Templates</h3>

<p>double shift 然后， 输入 live template ，选择 save as 进行设置</p>

<p>textfield设置
    <!-- $VALUE$ Form Input -->
    <div class="form-group"></p>

<pre><code>&lt;/div&gt;
</code></pre>

<p>还要设置Edit attributes</p>

<h3>Custom Formatting</h3>

<ul>
<li><p>Alt + Shift + F 格式化代码</p></li>
<li><p>Code Style -> PHP -> Other -> Align key value styles</p></li>
<li><p>convert null to low case</p></li>
<li><p>convert true/false to low case</p></li>
</ul>


<h3>Refactoring: Name and Method</h3>

<p>Refactor this: Ctrl + Alt + Shift + R</p>

<h3>Refactoring: Pull Up</h3>

<p>用快捷键 将子类中的方法移动到父类中。
Alt + t -> Refactor this 然后输入 up</p>

<h3>Refactoring: Extract Interface</h3>

<h2>phpStorm的编码格式</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP设计模式]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/11/php-patterns/"/>
    <updated>2015-08-11T16:59:07+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/11/php-patterns</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<ul>
<li><p>本文是慕课网《大话PHP设计模式》的文字记录</p></li>
<li><p>视频内容：<a href="http://www.imooc.com/view/236">大话PHP设计模式</a></p></li>
<li><a href="https://github.com/FengHan/php_pattern/">GitHub代码</a></li>
</ul>


<h3>目标：</h3>

<ul>
<li>掌握PHP各类设计模式</li>
<li>具备设计纯面向对象框架和系统的能力</li>
</ul>


<h3>编辑器的选择</h3>

<p>PHP IDE 建议使用phpstorm, 因为适合PHP面向对象的开发</p>

<h3>选择编程字体</h3>

<p>因为1, l, i  o,O,0 不好区分</p>

<ol>
<li>必须选择等宽字体</li>
<li>常见的等宽编程字体包括Courier New, Consolas.</li>
<li>推荐使用 Source Code pro, 是有Adobe公司专门为程序员设计，免费开源。</li>
</ol>


<p>PHPstorm在File -> Settings -> Editor -> Colors &amp; Fonts -> Font 先Save As, 再更改</p>

<h3>命名空间与 autoload</h3>

<p>开发符合PSR-0规范的基础框架</p>

<ol>
<li>全部使用命名空间</li>
<li>所有PHP文件必须自动载入，不能有include/require</li>
<li>单一入口</li>
</ol>


<p>PSR-0规范被PSR-4规范代替（2014.10</p>

<ul>
<li><a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md">PSR-4 English</a></li>
<li><a href="http://segmentfault.com/a/1190000002521658">PSR-4 中文</a></li>
</ul>


<p>一个关于 文件路径 自动加载 的规范</p>

<ol>
<li><p>“命名空间前缀”，其必须与至少一个“文件基目录”相对应；</p></li>
<li><p>末尾的类名必须与对应的以 .php 为后缀的文件同名。</p></li>
</ol>


<p><a href="http://www.bubuko.com/infodetail-557809.html">一个遵循PSR-4的文件autoload的例子</a></p>

<h3>PHP面向对象的高级特性</h3>

<h4>SPL库的使用（php标准库） PHP5.5</h4>

<ol>
<li>SplStack, SplQueue, SplHeap, SplFixedArray</li>
</ol>


<h4>魔术方法</h4>

<ol>
<li><strong>get </strong>set</li>
<li><strong>call </strong>callStatic</li>
<li>__toString</li>
<li>__invoke  将一个对象当做函数使用</li>
</ol>


<h3>11种PHP设计模式</h3>

<ol>
<li>工厂模式： 工厂方法或类生成对象，而不是在代码中直接new</li>
<li>单例模式： 使某个类的对象仅允许创建一个</li>
<li>注册模式： 全局共享和交换对象</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">class</span> <span class="nc">Database</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">protected</span> <span class="k">static</span> <span class="nv">$db</span><span class="p">;</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">function</span> <span class="nf">__construct</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">getInstance</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="k">empty</span><span class="p">(</span><span class="nx">self</span><span class="o">::</span><span class="nv">$db</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">self</span><span class="o">::</span><span class="nv">$db</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">self</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">self</span><span class="o">::</span><span class="nv">$db</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>工厂模式的好处：
1. 工厂里被实例化的类，类名可修改，参数可调</p>

<p>单例模式说明：</p>

<ol>
<li>__construct 的可见性为 protectd 或 privated，防止被实例化</li>
<li>方法getInstance为静态方法（static），ps：静态方法内，只能调用静态属性。静态属性类似于函数的全部变量。</li>
<li>静态属性$db的可见性为private或protected.</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">class</span> <span class="nc">Register</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">protected</span> <span class="k">static</span> <span class="nv">$objests</span><span class="p">;</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">set</span><span class="p">(</span><span class="nv">$alias</span><span class="p">,</span> <span class="nv">$object</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="o">::</span><span class="nv">$objests</span><span class="p">[</span><span class="nv">$alias</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$object</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">get</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">self</span><span class="o">::</span><span class="nv">$objests</span><span class="p">[</span><span class="nv">$name</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">_unset</span><span class="p">(</span><span class="nv">$alias</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nb">unset</span><span class="p">(</span><span class="nx">self</span><span class="o">::</span><span class="nv">$objests</span><span class="p">[</span><span class="nv">$alias</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注册树模式说明：</p>

<ol>
<li>好处： 被注册的对象在任何地方想要调用，不需要再调用工厂模式或单例模式，直接从注册树上拿即可。例如：Register::get(&lsquo;db&rsquo;);</li>
</ol>


<h3>适配器模式</h3>

<ol>
<li>适配器模式，可以将截然不同的函数接口封装成统一的API</li>
<li>example： PHP的数据库操作有mysql，mysqli，pdo3种，可以用适配器模式统一成一致。类似的场景还有cache适配器，将memcache, redis, file, apc等不同的缓存函数，统一成一致。</li>
</ol>


<h3>策略模式</h3>

<p>将一组特定的行为和算法封装成类，以适应默写特定的上下文环境，这种模式就是策略模式。</p>

<p>实际应用举例，例如一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有广告位展示不同的广告。</p>

<p>使用策略模式可以实现Ioc，依赖倒置，控制反转</p>

<p>ps， 不同的支付接口也可以调用策略模式</p>

<h3>数据对象映射模式</h3>

<ol>
<li>数据对象映射模式，是将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作</li>
<li>在代码中实现数据对象映射模式，我们将实现一个ORM类，将复杂的SQL语句映射成对象属性的操作。</li>
<li>结合使用数据对象模式，工厂模式，注册模式</li>
</ol>


<h3>观察者模式</h3>

<ol>
<li>观察者模式(Observer),当一个对象状态发生改变时，依赖它的对象全部收到通知，并自动更新</li>
<li>一个事件发生后，要执行一连串的更新操作。传统的编程方式，就是在时间的代码之后直接加入处理逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要改变事件主体的代码</li>
<li>观察者模式实现了低耦合，非侵入式的通知和更新机制</li>
</ol>


<h3>原型模式</h3>

<ol>
<li>与工厂模式作用类似，都是用来创建对象</li>
<li>与工厂模式实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样就免去了类创建时重复的初始化操作。</li>
<li>原型模式适用于大对象的创建。创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需要内存拷贝即可。</li>
</ol>


<p>ps: 就是使用关键字clone对实例化好的类进行克隆。</p>

<h3>装饰器模式</h3>

<ol>
<li>注释七模式（Decorator），可以动态地添加修改类的功能</li>
<li>一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要一个子类来继承它，并重新实现类的方法</li>
<li>使用装饰器模式，仅需在运行时添加一个装饰器对象极客实现，可以实现最大的灵活性</li>
</ol>


<h3>迭代器模式 iterator</h3>

<ol>
<li>迭代器模式，在不需要了解内部实现的前提下，遍历一个聚合对象内部元素</li>
<li>相比传统的编程模式，迭代器可以隐藏遍历元素所需要的操作。</li>
</ol>


<h3>代理模式</h3>

<ol>
<li>在客户端与实体之间建立一个代理对象（proxy）,客户端对实体进行操作全部委派给代理对象，隐藏实体的具体实现细节。</li>
<li>Proxy 还可以与业务代码分离，部署到另外的服务器。业务代码中通过RPC来委派任务。</li>
<li>典型的应用实例就是读写分离。读去连接从库，写去连接主库。</li>
</ol>


<h3>面向对象鞭策的基本原则</h3>

<ol>
<li>单一原则： 一个类，只做好一件事情。不要用类完成复杂的问题，拆分小的类。</li>
<li>开放封闭：一个类，应该是可扩展的，而不可修改的。对扩展开放，对修改封闭。</li>
<li>依赖倒置： 一个类，不应该依赖另外一个类。每个类对于另外一个类是可以替换的。用依赖注入的方式，例如，A类调用B类，应将B类对象注入给A类。</li>
<li>配置化：尽可能地使用配置，而不是硬编码</li>
<li>面向接口编程：只需关心接口，不需要关心实现。</li>
</ol>


<h2>ＭＶＣ</h2>

<ol>
<li>模型（Model): 数据和存储的封装</li>
<li>视图(View): 展现层的封装，如Web系统中的模板文件</li>
<li>控制器（Controller）： 逻辑层的封装</li>
</ol>


<p>Apache/Nginx URL映射</p>

<p>将所有非静态文件的URL映射到PHP</p>

<h2>配置与设计模式</h2>

<ol>
<li>PHP使用ArrayAccess实现配置文件的加载</li>
<li>在工厂方法读取配置，生成可配置化的对象</li>
<li>使用装饰器模式实现权限验证，模板渲染，JSON串化</li>
<li>使用观察者模式实现数据更新事件的一系列更新操作</li>
<li>使用代理模式实现数据库主从自动切换</li>
</ol>


<h3>更多的设计模式</h3>

<p>在工程中思考并实践</p>
]]></content>
  </entry>
  
</feed>
