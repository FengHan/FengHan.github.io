<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[hanfeng.name]]></title>
  <link href="http://fenghan.github.io/atom.xml" rel="self"/>
  <link href="http://fenghan.github.io/"/>
  <updated>2015-10-27T22:06:34+08:00</updated>
  <id>http://fenghan.github.io/</id>
  <author>
    <name><![CDATA[HanFeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MySQL业务优化与设计]]></title>
    <link href="http://fenghan.github.io/blog/2015/10/26/mysql-optimization-and-design/"/>
    <updated>2015-10-26T21:04:13+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/10/26/mysql-optimization-and-design</id>
    <content type="html"><![CDATA[<h1>MySQL索引查询优化</h1>

<h4>什么是索引</h4>

<p>快速定位要查早的数据 （意义）</p>

<h4>数据库索引查找</h4>

<ul>
<li>全表扫描 vs 索引查找</li>
</ul>


<h4>如何根据首字母找到所在行</h4>

<ul>
<li>二分查找</li>
<li>B+ tree</li>
</ul>


<p>B+tree:  拥有自己的根节点，枝节点和存放数据的页节点，并且整棵树分层存储，上一层数据会存放下一层数据的管理范围，直到最后一层页节点。</p>

<h4>InnoDB表聚簇索引</h4>

<ul>
<li>Clustered Index</li>
<li>Secondary Index</li>
</ul>


<h4>创建索引</h4>

<ul>
<li>单列索引</li>
<li><p>联合索引</p>

<p>  create index idx_test1 on tb_student(name);
  create index idx_test2 on tb_student(name,age);
  （索引中先根据name排序，name相同的情况下，根据age排序）</p>

<h4>索引维护</h4></li>
</ul>


<h4>字段选择性</h4>

<p>某个字段其值得重复程度</p>

<h4>联合索引与前缀查询</h4>

<p>联合索引能为前缀单列，复列查询提供帮助</p>

<h4>长字段上的索引</h4>

<p>InnoDB索引字段UTF8只能渠道767bytes</p>

<ul>
<li>Email类 (idx_mailadd(Mail_addr(30))</li>
<li>住宅类，分拆字段（省，城，区，街道分别存储）

<h4>索引覆盖扫描</h4></li>
<li>最核心SQL考虑索引覆盖</li>
<li>SELECT name FROM tb_user WHERE user_id = ?</li>
<li>KEY idx_uid_name(user_id, name);</li>
<li>不需要回表获取name字段，IO最小，效率最高</li>
<li>线上usernmae, password

<h4>无法使用索引的情况</h4></li>
<li>索引列进行数学运算和函数运算</li>
<li>未含符合索引的前缀字段</li>
<li>前缀通配% 通配符 不能使用索引</li>
<li>where跳进使用not ！=</li>
<li>字段类型匹配</li>
</ul>


<h4>利用索引排序</h4>

<h4>如何确定一个查询走没走索引，走了哪个索引</h4>

<h1>MySQL Schema设计</h1>

<ul>
<li><p>设计数据库的表，索引，以及表和表的关系</p>

<ul>
<li>在数据建模的基础上将关系模型转化为数据库表</li>
<li>满足业务模型需要基础上根据数据库和应用特点优化表结构
（合适的数据类型，约束，索引，增加减少字段，改变关系）</li>
</ul>
</li>
<li><p>满足业务功能需要</p></li>
<li>同性能密切相关</li>
<li>数据库扩展性</li>
<li><p>满足周边需求（统计，迁移等）</p></li>
<li><p>前瞻性</p>

<h4>基于性能的表设计</h4></li>
<li><p>根据查询需要设计好索引</p></li>
<li>根据核心查询需求，适当跳帧光标结构</li>
<li>基于一些特殊业务需求，调整实现方式

<h4>索引</h4></li>
<li>正确使用索引</li>
<li>更新尽可能使用主键或唯一索引</li>
<li>主键尽可能使用自增id字段</li>
<li>核心查询<strong>覆盖扫描</strong>

<h4>反范式，冗余必要字段</h4></li>
</ul>


<h4>拆分大字段</h4>

<h4>分页查询</h4>

<h4>准实时统计</h4>

<h4>分区表与数据淘汰</h4>

<ul>
<li>range分区</li>
<li>适合数据需要定期过期的大表</li>
<li>单个分区扫描迁移数据到历史库避免全表扫描IO开销</li>
<li><p>删除单个分区非常高效</p>

<p>  CREATE TABLE tb_order(
      order_id INT NOT NULL,
      order_date DATE NOT NULL,
  )</p>

<p>  PARTITION BY RANGE (YEAR（order_date)) {
      PARTITION p0 VALUES LESS THAN(2014),
      PARTITION p1 VALUES LESS THAN(2015),
      PARTITION p2 VALUES LESS THAN(2016),
      PARTITION p3 VALUES LESS THAN MAXVALUE,
  }</p></li>
<li><p>list 分区</p>

<ul>
<li>适合将来可能要基于地区，类目等方式垂直拆分数据的方式</li>
<li>清理节点上不要的数据非常高效</li>
</ul>


<p>  CREATE TABLE tb_store(
      id INT NOT NULL,
      store_id varchar(120)
  )
  PARTITION BY LIST(store_id)
  PARTION p_north VALUES IN(3,5,6,9,17)
  PARTION p_east VALUES IN(1,2,10,11,19,20)
  PARTION p_west VALUES IN(4,12,13,14,18)
  PARTION p_central VALUES IN(7,8,15,16)</p></li>
<li>hash 分区

<ul>
<li>适合将来需要做水平拆分的表</li>
<li>清理节点上不要的数据非常高效</li>
</ul>


<p>  CREATE TABLE tb_user_account(
      id INT NOT NULL,
      account_id varchar(120)
  )
  PARTITION BY HASH(id)
  PARTITIONS 24;</p></li>
</ul>


<h4>MySQL分区表的局限</h4>

<ul>
<li>主键和唯一键必须包含在分区字段内</li>
<li>分区字段必须是整数类型，或者加上返回整数的函数</li>
</ul>


<h4>为周边需求额外增加表设计</h4>

<ul>
<li>为后台统计任务增加特殊索引</li>
<li>为数据迁移或统计需求增加时间戳</li>
</ul>


<h4>统计和后台需求</h4>

<ul>
<li>统计运行SQL往往和线上有很大不同

<ul>
<li>利用MySQL一主多从，主从可以建不同的索引的特性将统计分流到特定从库</li>
<li>包括一些特殊用户批量查询等，所有对线上有IO的查询都要读写分离</li>
</ul>
</li>
</ul>


<h4>自动更新时间戳</h4>

<ul>
<li>统计需求经常要求从线上读走增量数据</li>
<li>表的第一个timestamp类型字段在写入时，如果不填值，会自动写入系统时间戳</li>
<li>标的第一个timestamp类型字段每次记录发生更新后都会自动更新</li>
<li>在update_time字段上建索引用于定时导出增量数据</li>
</ul>


<h4>Schema设计与前瞻性</h4>

<ul>
<li>基于历史经验教训，预防和解决同类问题</li>
<li>把折腾DBA够呛的所有Schema改造的原因记录并分析总结</li>
</ul>


<p>例：
- 业务为了用户信息加密做了大改造</p>

<ul>
<li><p>不再删除数据,加入is_deleted标记位，经常给各种表加</p>

<ul>
<li>哪个表具有删除的逻辑</li>
</ul>
</li>
<li><h2>支付类应用后期做了风控改造</h2></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL程序开发]]></title>
    <link href="http://fenghan.github.io/blog/2015/10/21/mysql-programe-development/"/>
    <updated>2015-10-21T20:30:56+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/10/21/mysql-programe-development</id>
    <content type="html"><![CDATA[<h1>目标</h1>

<p>理解掌握字符集的基础知识和使用方法，具备处理常见字符集合的能力</p>

<h1>MySQL字符集</h1>

<h3>字符集基础</h3>

<p>字符集： 数据库中的字符集包含两层含义</p>

<ol>
<li>各种文字和符合的集合，包括各国家文字、标点符号、图形符号、数字等。</li>
<li>字符的编码方式，即二进制数据与字符的映射规则。</li>
</ol>


<h3>字符集 - 分类</h3>

<p>UTF -8 ： 包含世界上数十种的文字系统，使用一至四个字节为每个字符编码。</p>

<p>latin1 ： 不支持汉字。</p>

<p>show character set;</p>

<p>新增字符集
&ndash;with-charset (编译时)</p>

<h3>字符集与字符序</h3>

<p>charset 和collation</p>

<p>collation： 字符序，字符的排序与比较规则，每个字符集都对应的多套字符序。</p>

<p>不同的字符序决定了字符串在比较排序中的精度和性能不同。</p>

<p>show collation;</p>

<ul>
<li>utf8_general_ci 能够排序普通的英文字符，但是德语就不能够排序</li>
<li>utf8_unicode_ci 能够对德语排序，精度更高了，但是性能下降了。</li>
<li>mysql默认 utf8_general_ci</li>
</ul>


<p>mysql的字符序遵从命名惯例：</p>

<ul>
<li>以_ci表示大小写不敏感</li>
<li>以_cs表示大小写敏感</li>
<li>以_bin表示用编码值进行比较

<h3>字符集设置级别</h3></li>
<li>charset 和collation的设置级别
  服务器级别 >> 数据库级 >> 表级 >> 列级</li>
<li><p>服务器
 系统变量(可动态设置)</p>

<pre><code> - character_set_server  :默认的内部操作字符集
 - character_set_system: 系统元数据（字段名）字符集， 就是字段名，表明也可以用中文
</code></pre>

<p> [mysqld]
 character_set_server=utf8
 character_set_system=utf8_general_ci</p></li>
<li><p>数据库级
  CREATE DATABASE db_name CHARACTER_SET latin1 COLLATE latin1_swedish_ci;</p></li>
<li><p>character_set_database: 当前选中数据库的默认集合</p></li>
<li><p>主要影响load data等语句的默认字符集， CREATE DATABASE 的字符集如果不设置，默认使用character_set_server的字符集。</p></li>
<li><p>表级</p></li>
<li><p>CREATE TABLE TB11() DEFAULT CHARSET=utf8 DEFAULT COLLATE=utf8_bin;</p></li>
<li><p>列级
  能设置，不推荐</p>

<h3>数据存储字符集使用规则：</h3></li>
<li>使用列级的CHARACTER SET 设定值；</li>
<li>若列级字符集不存在，则使用对应表级的DEFAULT CHARACTER SET 设定值；</li>
<li>若表级字符集不存在，则使用数据库级的DEFAULT CHARACTER SET 设定值；</li>
<li>若数据库级字符集不存在，则使用服务器级character_set_server设定值。</li>
</ul>


<h4>查看字符集</h4>

<pre><code> show global variables like 'character%';
 show global variables like 'collation%';
</code></pre>

<p>修改字符集</p>

<pre><code>set global character_set_server=utf8; (全局)
alter table xxx convert to character set xxx;(表)
</code></pre>

<p>show  variables like &lsquo;character%&rsquo;; （当前session的）</p>

<h4>客户端连接与字符集</h4>

<ul>
<li>character_set_client:客户端来源数据使用的字符集(这是通知mysql要连接的字符集)</li>
<li>character_set_connection: 连接层字符集（是一个中间层）</li>
<li>character_set_results: 查询结果字符集（返回的数据）</li>
</ul>


<p>set names utf8;
    [mysql]
    default-character-set = utf8</p>

<h4>客户端连接与字符集</h4>

<p>字符集的转换？</p>

<p>问gbk怎么转utf8；</p>

<p>常见乱码原因：
1. 数据存储字符集不能正确编码（不支持）client发来的数据
    client (utf8) -> storage(latin1)
    例如表的字符集为latin1, 你直接插入中文为报错。
2.程序连接使用的字符集与通知mysql的character_set_client等不一致或兼容。
例子：
 alter table stu convert to character set utf8;
 set names utf8;
 使用navicat 设置连接字符为65001 (UTF-8)</p>

<p>要理解乱码的真正原因</p>

<p>即使传过来的是gbk，存储是utf8，也不会乱码；因为msyql内部会做一个转换。但是连接的字符集合和告诉mysql要连接的字符集要一致。</p>

<p>select length(course) from stu;</p>

<p>你好utf8的lengh为6</p>

<ol>
<li>表存储支持中文</li>
<li>连接客户端的字符集合告知mysql要连接的字符集一致。</li>
</ol>


<p>DBA遇到的字符集</p>

<p>load data 用的是character_set_database</p>

<p>文件utf8,character_set_database 是gbk，就会乱码（即文件编码和告诉mysql要连接的编码不一致，就会乱码）</p>

<h4>客户端连接与字符集</h4>

<p>使用建议：</p>

<ol>
<li>创建数据库/表时显示的指定字符集，不使用默认。</li>
<li>连接字符集与数据存储字符集设置一致，推荐使用utf8。(1.减少了一次转换过程 2.便于管理 )</li>
<li>驱动程序连接时，显示指定字符集（set names xxx）</li>
</ol>


<h4>客户端连接与字符集</h4>

<p>mysql PHP API: 连接到数据库以后显示用SET NAMES 语句设置一次连接字符集.</p>

<h4>小结</h4>

<ul>
<li>字符集：表示字符集合字符编码方式</li>
<li>字符的设置级别： server，database，table，coloumn</li>
<li>客户端字符集：乱码产生的原因与解决方式
（字符集设置有三个要素：1.程序连接驱动或客户端的字符集 2，告知mysql连接的字符集 3.数据存储的字符集。 前两个必须设置一致。）</li>
</ul>


<h1>程序连接MySQL</h1>

<h4>程序连接ＭySQL的基本原理</h4>

<pre><code>JDBC 客户端应用
java.sql.* javax.sql.*
驱动程序1 驱动程序2

Oracle MySQL SqlServer 
</code></pre>

<p>首先应用程序调用 标准的JDBC接口，将SQL语句发送给驱动程序，也就是说应用程序是和JDBC的标准接口打交道的。JDBC是由驱动程序提供的类库，用户可以直接引用调用。驱动程序接到SQL语句后，会将之转换成符合数据库通信协议的TCP协议发送给数据库。还能接受数据库的返回结果，然后封装成TCP对象，返回上层程序。</p>

<h3>Java代码示例</h3>

<p>Driver Manager</p>

<p>Driver = DriverManager.getDriver(String URL)</p>

<p>Connection=(Drivermanager.getConnection(String Url))</p>

<p>Statement(执行静态SQL语句接口 = Connection.CreateStatement())</p>

<p>ResultSet(是指向结果集对象的接口= Statement.executeXXX())</p>

<h4>JDBC的使用技巧</h4>

<ol>
<li>Statement 与PreparedStatement的区别
在数据库端<strong>预编译</strong>，效率高，可以防止SQL注入。
效率高：在DB端<strong>生成一个SQL的执行计划</strong>，生成的计划要<strong>解析SQL语句的语法树</strong>，还要进行连接，选<strong>择驱动表</strong>等等的优化，这些都比较费时。</li>
</ol>


<p>PreparedStatement只有在第一次执行这些，以后只要在传参变量中传值给preparedStatement就就可以了。如果数据量过大，就用ps。</p>

<p>2.，对数据库执行一次性存取的时候，用Statement对象进行处理。</p>

<ol>
<li>线上业务推荐使用ps</li>
</ol>


<h4>MySQL Prepare过程</h4>

<p>Prepare Execute DEALLOCATE PREPARE</p>

<p>PREPARE stmt1 FROM &lsquo;SELECT * from test WHERE a = ?&rsquo;;
SET @pc = &lsquo;1&rsquo;;
EXECUTE stmt1 USING @pc;</p>

<p>DEALLOCATE PREPARE stmt1;</p>

<p>只有数据库支持ps才可以</p>

<h4>SQL注入实例：</h4>

<p>$sql = &lsquo;select * from username where name = &rsquo;&ldquo; + $name + &rdquo;&lsquo;and password = &rsquo;&ldquo; + $pw + &rdquo;&lsquo;;</p>

<p>$name = &ldquo;&lsquo; or 1=1&rsquo;&rdquo;;
$pw = &ldquo;&lsquo; or 1=1&rsquo;&rdquo;;</p>

<p>preparedStatement会去查询username 是or 1=1 的数据，</p>

<h4>connection, Statement与ResultSet关闭</h4>

<ul>
<li><p>MySQL服务端为connection, ResultSet维护内存状态，一直不关闭会占用服务端资源</p></li>
<li><p>MySQL最大连接数受max_connections限制，不能无限创建连接，所以用完要及时关闭。</p></li>
<li><p>JDBC关闭后，Result, Statement会自动关闭。但是如果使用连接池将不会关闭，因此推荐主动关闭。</p></li>
</ul>


<p>如果不用JDBC,用连接池的时候；当colose connection的时候，连接池不会close connection， 而是会回收connection，可以复用资源，减少连写的消耗。所以Result, Statement也要手动关闭</p>

<h4>jdbc连接参数的使用</h4>

<p>字符集：
url = &ldquo;jdbc:mysql://localhost:3306/blog_dbo?useUnicode=true&amp;characterENcoding=utf8&rdquo;</p>

<p>超时设置
url = &ldquo;jdbc:mysql://localhost:3306/blog_dbo?connectTimeout=1000$socketTimeout=30000&rdquo;</p>

<ul>
<li>建立连接的超时时间</li>
<li>发一个SQL语句，30秒内不反回就不等待了。</li>
</ul>


<h4>ResultSet游标的使用</h4>

<p>流式读取（流式向前）
setFetchSize()
是设置ResultSet每次向数据库读取的行数，为防止数据返回量过大，将内存爆掉。</p>

<h4>Python</h4>

<p>Python MySQL 驱动：python-mysqldb</p>

<p>apt-get install python-mysqldb</p>

<h1>DAO框架的使用</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL事务与存储引擎]]></title>
    <link href="http://fenghan.github.io/blog/2015/10/19/mysql-transaction-and-storange-engine/"/>
    <updated>2015-10-19T21:15:51+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/10/19/mysql-transaction-and-storange-engine</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p><strong>事务</strong>特性是关系型数据库在各个行业领域中成为关键数据存储最主要工具的一大法宝，可以说是数据库安身立命之本，当然也包括MySQL。无论是应用开发人员还是DBA，学习掌握事务的使用和基本原理，是更好地使用和管理数据库的必由之径。</p>

<p>掌握事物的特性要达到什么样的标准呢？如下标准：</p>

<ol>
<li>事务的主要用处和基本特征</li>
<li>事务隔离级别的含义及影响</li>
<li>什么是MySQL的存储引擎，以及主要存储引擎有哪些</li>
<li>MySQL主要存储引擎的特点和适用范围</li>
<li>InnoDB存储引擎特点和优势</li>
</ol>


<h1>数据库事务</h1>

<h3>什么是事务？</h3>

<p>老张给老王转账100元。要分为两个update语句，一个语句给老张减去100元，另外一个语句给老王加上一百元。而计算系统总是不能持续稳定的运行，线上会有各种各样的故障，而这个故障恰好发生在两个SQL之间，那么这100元就废了。事务就是为了避免这样的事情发生。</p>

<ul>
<li>一系列有序的数据库操作

<ul>
<li>要么全部成功</li>
<li>要么全部回退到操作状态</li>
<li>中间状态对其它连接不可见</li>
</ul>
</li>
<li>事务的基本操作

<ul>
<li>start transaction; 开始事务  （begin）</li>
<li>commit; 提交（全部完成）</li>
<li>rollback; 回滚（回到初始状态）</li>
</ul>
</li>
</ul>


<p>宕机后，没有成功的数据都会回滚。</p>

<p>事务的中继点 savepoint</p>

<p>允许事务开启后，在事务的中段进行多次保存点的保存，在回滚的时候可以回滚到任意一个保存点，而不是选择将整个事务全部回滚。而我们提交的时候，只能将我们事务中的所有操作提交，而不能提交到任意一个保存点。</p>

<p>savepoint a1;
rollback to a1;</p>

<p>线上不经常使用savepoint</p>

<h3>自动提交</h3>

<ul>
<li>autocommit 可以在session级别设置</li>
<li>每个DML操作都自动提交(就是update, delete,insert 操作)</li>
<li>DDL永远都是自动提交，无法通过rollback回滚。(就是修改表结构的那些语句，DDL之前的DML语句， 也都会随着DDL的提交而永久持续化到数据库上。)  简单来说DDL没有后悔药吃。</li>
</ul>


<p>因为在每个insert语句后，自动加了一个commit;</p>

<pre><code>mysql&gt; show global variables like '%autocommit%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
</code></pre>

<p>mysql> set session autocommit = 0;</p>

<h3>事务的四个基本属性（ACID）</h3>

<ul>
<li>原子性（Atomicity）</li>
<li>一致性 (Consistency)</li>
<li>隔离性(Isolation)</li>
<li><p>持久性(Durability)</p>

<h4>事务的原子性</h4></li>
<li><p>包含在事务中的操作要么全部执行，要么都不执行</p></li>
<li>中途数据库或应用发生异常，未提交的事务都应该被回滚</li>
</ul>


<h4>事务的一致性</h4>

<ul>
<li>数据的正确性，合理性，完整性</li>
<li>数据一致性应该符合应用需要规则

<ul>
<li>余额不能是负数？ （int no zero）</li>
<li>交易对象必须先有账号？ (主外键约束)</li>
<li>用户账号不能重复？ （添加唯一索引）</li>
</ul>
</li>
<li>事务的结果需要满足数据的一致性约束</li>
</ul>


<h4>事务的持久性</h4>

<ul>
<li>提交完成的事务对数据库的影响必须是永久性的

<ul>
<li>数据库异常不会丢失事务更新</li>
<li>通常认为成功写入磁盘的数据即为持久化成功</li>
</ul>
</li>
</ul>


<h4>事务的持久化的实现</h4>

<p>挑战： 数据库的高性能。并不是修改一个数据，就在磁盘上马上改掉。因为数据库里的数据散步在各地。而机械磁盘的随机写是相当缓慢的过程。为保证较高效率。修改数据，不会马上记录在磁盘上，先被保存在事务日志中（顺序同步刷新，磁盘对顺序写是相当优秀的，然后异步的慢慢的刷新到磁盘上。宕机时，通过事务日志回放来保证数据持久化。</p>

<h4>事务的隔离性</h4>

<ul>
<li>数据库事务在提交完成前，中间的任何数据变化对其他的事务都是不可见的</li>
</ul>


<h4>数据库隔离现象</h4>

<ul>
<li>脏读 Dirty Read 事务B读到事务A尚未提交的数据变更</li>
<li>不可重复读 NonRepeatable Read  B事务由于A事务的提交，查询数据时，看到2种不同的结果</li>
<li>幻读 Phantom Read 幻读 （不可重复读和幻读都针对事务B能否读到事务A已经提交的变更）</li>
</ul>


<h4>数据库隔离等级</h4>

<ul>
<li>Read uncommitted 未提交读</li>
<li>Read committed   已提交读</li>
<li>Repeatable read 可重复读</li>
<li>Serializable   可串行化

<h4>MySQL的事务隔离级别</h4></li>
<li>InnoDB默认标记为可重复读（Repeatabe read）</li>
<li>InnoDB并不是标准定义上的可重复读</li>
<li><p>InnoDB默认在可重复读的基础上避免幻读
show global variables like &lsquo;%iso%&rsquo;;</p>

<h4>MySQL的事务隔离级别</h4></li>
<li><p>InnoDB默认标记为可重复读（Repeatable read）</p></li>
<li>InnoDB并不是标准意义上的可重复读</li>
<li>InnoDB默认在可重复读的基础上避免幻读</li>
</ul>


<p>set global tx_isolation = &lsquo;REPEATABLE-READ&rsquo;;</p>

<p>set global tx_isolation = &lsquo;SERIALIZABLE&rsquo;;
实验：</p>

<ul>
<li>未提交读: 有脏读
  set global tx_isolation = &lsquo;READ-UNCOMMITTED&rsquo;;</li>
<li>已提交读：没有脏读， 存在幻读和不可重复读
  set global tx_isolation = &lsquo;READ-COMMITTED&rsquo;;</li>
<li>可重复读
  set global tx_isolation = &lsquo;REPEATABLE-READ&rsquo;;</li>
</ul>


<p>不可重复读: B事务由于A事务update的提交，B事务看到两种不同的数据。
幻读: 事务B由于事务A insert 的提交，B   事务看到了之前不存在的数据。</p>

<ol>
<li>不可重复读针对（delete，update操作）</li>
<li>幻读针对insert操作</li>
</ol>


<h4>MySQL的事务隔离级别的设置</h4>

<ul>
<li>可在global/session 下分别设置事务的隔离级别</li>
<li>建议使用Read committed(同Oracle)</li>
<li>或者建议使用默认的MySQL设置Repeatable read
  -隔离级别Serializable   可串行化对线上的并发性能有影响，不会在线上设置</li>
</ul>


<h3>事务与并发写</h3>

<ul>
<li>某个正在更新的记录在提交或回滚前不能被其他事务同时更新(? update 前加排它锁X?)</li>
<li>事务修改某个记录时，会先获得这条记录的锁，其它事务会进行等待。A修改完成，会将锁释放。然后B和C会获得这把锁</li>
<li>btw,所有对数据库记录的修改都是串行的，不存在并发的概念</li>
</ul>


<h3>事务回滚的实现</h3>

<ul>
<li>回滚段（rollback segment）与数据前像</li>
</ul>


<h1>存储引擎概述</h1>

<h2>MySQL 程序层次架构</h2>

<ul>
<li>内存实例

<ul>
<li>服务层（上层）</li>
<li>存储引擎层（上层数据和上层SQL语句经过处理之后，交给存储引擎层，由存储引擎层决定如何将它记录在磁盘上）</li>
</ul>
</li>
<li>存储引擎</li>
</ul>


<h2>什么是存储引擎</h2>

<p>举例：书记员记录
书记员就是<strong>服务层</strong>，
而书记员的笔就是<strong>存储引擎</strong>（文字，图标，流程图。决定以何种格式记录。）</p>

<h2>MySQL 存储引擎</h2>

<ul>
<li>有多种方案，可拔插，可修改存储引擎。</li>
<li><strong>基于表</strong>选择使用何种存储引擎</li>
</ul>


<p>show engines;</p>

<h1>InnoDB存储引擎</h1>

<ul>
<li>索引组织表</li>
<li>支持事务</li>
<li>锁的粒度比较小，支持行级锁</li>
<li>有自己的数据块缓存</li>
<li>日志持久化</li>
<li><strong>稳定可靠，性能好，线上尽量使用InnoDB</strong>
MySQL5.5之后的默认存储引擎，我们线上绝大部分的数据都会放到InnoDB存储引擎中。

<h2>InnoDB 存储引擎架构</h2></li>
<li>InnoDB缓存池：内存空间包括： 数据块缓存 Buffer pool(更高效的操作数据文件)，日志缓存，double write缓存</li>
<li>后台线程：将内存中的数据块刷新到磁盘上，将日志写到磁盘上，监控</li>
<li>磁盘上的文件： 数据文件， redo log

<h2>MyISAM 存储引擎</h2></li>
<li>堆表</li>
<li>不支持事务</li>
<li>只维护索引缓存池， 表数据缓存交给操作系统</li>
<li>锁的力度比较大，导致并发性能非常查</li>
<li>数据文件可以直接拷贝，偶尔可能用上</li>
<li>不建议线上业务数据使用
Mysql直到5.1开始，都是MySQL的默认存储引擎
MyISAM 只能有一个连接修改数据，对数据的并发性造成很大的影响，这是被淘汰的主要原因。
系统初始化的表是MyISAM,因为不需要经常的修改和并发性操作，所以没有问题。</li>
</ul>


<h2>Memory存储引擎</h2>

<ul>
<li>数据全内存存放，无法持久化</li>
<li>性能较高</li>
<li>不支持事务</li>
<li>适合偶尔作为临时表使用</li>
<li>create temporary table tmp(id int) engine = memory;</li>
<li>temporary临时表只针对当前这个连接生效，不是全局的。</li>
</ul>


<h2>BlackHole存储引擎</h2>

<ul>
<li>数据不做任何存储-</li>
<li>利用MySQL Replicate，充当日志服务器</li>
<li>在MySQL Replicate 环境中充当代理主

<h2>TokuDB</h2></li>
<li>分形数存储结构</li>
<li>支持事务</li>
<li>行锁</li>
<li>压缩效率较高</li>
<li>适合大批量insert的场景

<h2>MySQL Cluster</h2></li>
<li>多主分布式集群</li>
<li>数据节点间冗余，高可用</li>
<li>支持事务</li>
<li>设计易于扩展</li>
<li>面向未来，线上慎用</li>
</ul>


<p>alter table m ENGINE = innodb;</p>

<h2>InnoDB物理文件</h2>

<ol>
<li>系统表空间：ibdata1  一个实例一个　（innodb_data_home_dir）</li>
<li>日志文件：ib_logfile0/1 一个实例两个（可以配置） (innodb_log_group_home_dir)</li>
<li>表定义文件：　表名.frm 每个表一个 (Schema目录下)</li>
<li>表数据文件：　表名.ibd 如果innodb_file_per_table = 1，则每个表一个(Schema目录下)
ibdata1存放了：</li>
<li>回滚段</li>
<li>所有InnoDB表元数据信息（不能想MyISAM通过拷贝数据来做表迁移。如果发生移动，ibdata1中存储信息和数据文件实际存在位置不一致，就无法打开这张表）</li>
<li>Double write, insert buffer dump等等</li>
</ol>


<p>自动扩展机制
show global variables like &lsquo;%innodb%&rsquo;;</p>

<p>参数innodb_autoextend_increment 100M 或者稍微大一点是比较合适的大小。太小的话，会造成系统表空间频繁的扩展，因为每次扩展的量不够。如果设置太大的话，会造成每次扩展的效率非常慢，在扩展期间。很多因为回滚段不够的事务将被hand住。因此建议100M或者稍微大些比较合适。
innodb_file_per_table 设为1， 表定义和表数据文件会单独存放。否者会和ibdata1放在一起。
innodb_log_file_size 100M
innodb_log_file_in_group 2  和性能相关，如果写操作过多（insert,delete,update），可以将这两个参数调大。</p>

<ul>
<li>索引组织表（聚簇表）</li>
<li>根据表逻辑主键排序</li>
<li><p>数据节点每页16k （根节点，枝节点，叶节点）</p></li>
<li><p>根据主键寻址速度很快</p></li>
<li>主键值递增的insert插入效率较好</li>
<li>主键随机insert插入效率较差</li>
</ul>


<p>因此， InnoDB表必须指定主键，建议使用自增</p>

<h2>InnoDB内存缓存</h2>

<ul>
<li>数据的读写需要经过缓存</li>
<li>数据以整页（16k）为单位读到缓存中</li>
<li>缓存中的数据以LRU策略换出（最少使用策略）</li>
<li>IO效率高，性能好。（利用缓存池减少了物理IO）
innodb_buffer_pool_size 根据总物理内存设置。 在启动实例的时候设置</li>
</ul>


<h2>InnoDB数据持久化</h2>

<ul>
<li>事务日志实时持久化</li>
<li>内存变化数据（脏数据）增量异步刷出到磁盘</li>
<li>实例故障靠重放日志恢复</li>
<li>性能好，可靠，恢复快

<h2>InnoDB行级锁</h2></li>
<li>写不阻塞读</li>
<li>不同行之间的写互相不阻塞</li>
<li>并发性能好

<h2>InnoDB事务支持</h2>

<p>事务ACID特性的完整支持
A 回滚段失败回滚
C 支持主外键约束
I 事务版本 + 回滚端 = MVCC
D 事务日志持久化</p></li>
</ul>


<p>默认可重复读隔离级别，可调整</p>

<h1>InnoDB事务锁</h1>

<h2>什么是计算机程序锁</h2>

<ul>
<li>控制对共享资源进行并发访问</li>
<li>保护数据的完整性和一致性</li>
</ul>


<h2>什么是数据库锁</h2>

<ul>
<li>事务锁 保护数据库逻辑内容， 持续时间较长</li>
<li><p>latch/mutex 保护内存数据结构， 用于临界资源的争抢，时间短
数据库事务并发：（一个串行化的过程）
更新丢失</p>

<h3>事务锁的力度</h3></li>
<li><p>行锁 InnoDB, Oracle</p></li>
<li>页锁 SQL Server； 存在锁升级的情况</li>
<li>表锁 MyISAM, Memory; 影响并发性

<h3>数据库加锁操作</h3>

<p>select 语句不加任何锁，也不会被任何事务阻塞锁。
读的隔离性由MVCC确保</p></li>
</ul>


<h3>InnoDB锁模式互斥</h3>

<ul>
<li>shared lock 读锁是共享的

<ul>
<li>手动： select * from test lock in share mode ;</li>
<li>自动： insert 前</li>
</ul>
</li>
<li>exclusive lock 写锁是排他的

<ul>
<li>自动： select * from test lock for update;</li>
<li>手动: update 和delete前</li>
</ul>
</li>
<li>一般select语句不加任何锁，也不会被任何事务阻塞</li>
</ul>


<p>等待时间，由系统参数决定
show global variables like &lsquo;%lock_wait%&rsquo;;</p>

<h4>锁粒度</h4>

<ul>
<li>table lock</li>
<li>row lock</li>
</ul>


<p>lock for update  (exclusive lock)</p>

<h2>InnoDB锁机制</h2>

<h2>InnoDB锁实现与注意事项</h2>

<h2>死锁</h2>

<h2>业务加锁</h2>

<h1>参考链接</h1>

<p><a href="http://blog.csdn.net/hguisu/article/details/7106342">MySQL架构</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Drupal101]]></title>
    <link href="http://fenghan.github.io/blog/2015/10/12/drupal101/"/>
    <updated>2015-10-12T22:39:48+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/10/12/drupal101</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>入职新公司，开始学习Drupal。立志成为Drupal专家</p>

<h1>Drupal101</h1>

<ul>
<li>创始人 Dries Buytaert博客 <a href="http://buytaert.net/">http://buytaert.net/</a></li>
<li>学习资源 <a href="https://drupalize.me">drupalize.me</a></li>
</ul>


<h4>What is Drupal</h4>

<ul>
<li>CMS

<ul>
<li>CMF</li>
</ul>
</li>
<li></li>
</ul>


<h4>Who uses Drupal</h4>

<ul>
<li><a href="http://drupalshowcase.com/">Drupal Showcase</a></li>
<li><a href="https://www.drupal.org/case-studies">drupal.org</a></li>
</ul>


<h4>Major features with site building</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL存储引擎]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/16/mysql-storage-engine/"/>
    <updated>2015-09-16T20:01:29+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/16/mysql-storage-engine</id>
    <content type="html"><![CDATA[<h3>什么是MySQL存储引擎</h3>

<p>服务层 - 存储引擎 - 文件系统层</p>

<p>MySQL5.5 以后默认为InnoDB,推荐。</p>

<p>Memory存储引擎，临时表</p>

<h4>MyISAM</h4>

<ul>
<li>堆表（插入性能好）</li>
<li>不支持事务</li>
<li>只维护索引缓存池，表数据缓存交给操作系统（表若很大，浪费内存）</li>
<li>锁粒度较大（表级锁，读写锁，读的时候不允许写，写的时候不允许读）</li>
<li>数据文件可以直接拷贝，备份数据用得上</li>
</ul>


<p>不推荐的原因：1. 不支持事务 2. 锁的颗粒度比较大 3. 表数据缓存交给操作系统，表若很大，浪费内存</p>

<h4>TokuDB</h4>

<p>社区版备份比较麻烦</p>

<h4>MySQL Cluster</h4>

<ul>
<li>多主分布式集群</li>
<li>数据节点间冗余，高可用</li>
<li>支持事务</li>
<li>设计上易于扩展</li>
<li>面向未来，线上慎用</li>
</ul>


<h4>InnoDB</h4>

<ul>
<li>缓存池 +　各种后台线程　＋ 数据文件</li>
</ul>


<p>事务ACID:</p>

<ul>
<li>回滚段失败回滚（A）</li>
<li>支持主外键（C）</li>
<li>事务版本 + 回滚段 = MVCC(I)</li>
<li>事务日志持久化（D）</li>
</ul>


<p>行级别锁：</p>

<ul>
<li>写不阻塞读</li>
<li>不同行间的写相互不阻塞</li>
<li>并发性能好</li>
<li>锁是加在索引上的</li>
</ul>


<p>InnoDB数据块缓存池</p>

<ul>
<li>数据的读写经过缓存</li>
<li>IO效率高，性能好。</li>
</ul>


<p>InnoDB数据文件存储结构：</p>

<ul>
<li>根据主键寻址速度很快</li>
<li>主键值递增的insert插入效率较好</li>
<li>主键随机insert插入效率较好</li>
<li><strong>因此，InnoDB表必须指定主键，建议使用自增数字</strong></li>
</ul>


<p>数据持久化与事务日志</p>

<ul>
<li>事务日志实时持久化</li>
</ul>


<h3>介绍MySQL主要存储引擎的特点及试用场景</h3>

<h3>Innodb存储引擎</h3>

<pre><code>show global variables like "%increment%";

+-----------------------------+-------+
| Variable_name               | Value |
+-----------------------------+-------+
| auto_increment_increment    | 1     |
| auto_increment_offset       | 1     |
| div_precision_increment     | 4     |
| innodb_autoextend_increment | 64    |
+-----------------------------+-------+
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL数据库对象与应用]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/14/mysql-db-object/"/>
    <updated>2015-09-14T11:16:22+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/14/mysql-db-object</id>
    <content type="html"><![CDATA[<h1>MySQL数据类型</h1>

<h4>经验之谈</h4>

<ul>
<li>存储性别、省份、类型等分类信息时，选择TINYINT或者ENUM</li>
<li>BIGINT存储空间更大，INT和BIGINT之间通常选择BIGINT</li>
<li>交易等高精度数据时选择使用DECIMAL</li>
</ul>


<h1>MySQL数据对象</h1>

<p>help create index</p>

<h1>MySQL权限管理</h1>

<ul>
<li><p>Data Privileges</p>

<pre><code>  DATA: SELECT, INSERT, UPDATE, DELETE
</code></pre></li>
<li>Define</li>
<li>Administrator Privileges

<ul>
<li>Shutdown Database</li>
<li>Replication</li>
</ul>
</li>
</ul>


<p>创建一个用户并赋权：</p>

<ul>
<li>使用原生的SQL</li>
<li>更改数据库记录</li>
<li>更简单的方法

<h4>查看用户权限</h4>

show grants;

<h4>如何更改用户的权限</h4></li>
</ul>


<h4>如何更改用户的密码</h4>

<h4>删除用户</h4>

<h4>With Grant Option</h4>

<h4>与权限相关的表</h4>

<ul>
<li>user</li>
<li>db</li>
<li>tables_priv</li>
<li>clomuns_priv

<h5>Mysql 权限验证的过程</h5></li>
</ul>


<h4>MySQL权限上有哪些问题</h4>

<ul>
<li>默认的test库不受权限控制，存在安全风险</li>
<li>mysql_secure_installation</li>
</ul>


<h4>小结</h4>

<ul>
<li>权限相关的操作不要直接操作表，统一使用MySQL命令</li>
<li>使用二进制安装MySQL后，需要重置管理用户（root）的密码</li>
<li>线上数据库不要留test库</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高性能产品的必由之路—性能测试工具]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/12/performance-test/"/>
    <updated>2015-09-12T10:32:58+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/12/performance-test</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>课程笔记：<a href="http://www.imooc.com/learn/278">IMOOC:高性能产品的必由之路—性能测试工具</a>。
昨天面试，问我LNAMP能够承载多少用户，答不知道，所以学习。</p>

<h1>引言</h1>

<ul>
<li>搭建一个网站容易</li>
<li>搭建一个千万用户级的网站没有那么容易

<ul>
<li>横向扩展的能力</li>
<li>数据库的优化</li>
<li>尽量让一台机器能够承载更多的用户请求

<h1>性能测试的指标</h1>

<h4>什么是系统测试</h4></li>
</ul>
</li>
</ul>


<p>性能测试就是通过<strong>技术的手段</strong>模拟大量用户<strong>同时</strong>访问被测应用，观察、记录和分析系统的<strong>各项性能指标</strong>的过程。</p>

<p>性能测试的目标是评估系统的性能瓶颈，预测系统的最大用户负载能力。</p>

<h3>两个关键点</h3>

<ul>
<li>模拟大量并发用户</li>
<li>监控系统负载参数分析系统瓶颈

<h4>性能指标</h4></li>
<li>平均响应时间（TTLB, Time to laster byte）

<ul>
<li>平均每个请求从发送到接收响应的时间</li>
<li>合理的平均响应时间

<ul>
<li>2/5/10原则</li>
<li>非常有吸引力/比较不错/糟糕失败的</li>
</ul>
</li>
<li>平均响应时间的业务影响

<ul>
<li>1秒延迟减少了11%的PV，降低了16%的客户满意度</li>
<li>2秒增加到10秒，会导致38%的页面浏览放弃率</li>
</ul>
</li>
</ul>
</li>
<li>CPU

<ul>
<li> CPU的占用率</li>
</ul>
</li>
<li>内存

<ul>
<li>内存的占用率， 换页数</li>
</ul>
</li>
<li>I/O

<ul>
<li>读写请求数，读写量</li>
</ul>
</li>
<li>带宽

<ul>
<li> 进站出站带宽占用率

<h4>为什么要进行性能测试</h4></li>
</ul>
</li>
<li>能够有效评估系统的性能指标，用于系统的系能评估</li>
<li>能够识别系统的性能瓶颈，协助性能调优</li>
<li>能够指导突发流量承载方案的制定</li>
<li>能够用于系统运维成本的预算

<h4>性能的事的一般分类</h4></li>
<li>负载测试(Load Test)

<ul>
<li>为了验证系统设计符合正常业务负载情况下系统性能表现的测试</li>
<li>开发人员找到内存泄露、连接泄露和系统瓶颈</li>
</ul>
</li>
<li>压力测试（Stress Test）

<ul>
<li>为了验证系统在极端负载情况下的性能表现的测试</li>
</ul>
</li>
</ul>


<h3>性能测试工具</h3>

<ul>
<li>top

<ul>
<li>F 显示字段与排序</li>
<li>h 帮助</li>
<li>VIRT 虚拟内存大小</li>
<li>RES   真实内存大小</li>
<li>SHA 共享内存大小</li>
<li>TIME+ 运行这个进程的时间</li>
<li>查看cpu排序也可以用  SHIFT键+p 或者  大写状态下 P</li>
<li>查看内存排序也可以用  SHIFT键+m 或者  大写状态下 M</li>
</ul>
</li>
<li>top -b -n 1

<ul>
<li>b 所有的都列出来</li>
<li>n 1  ， 只执行一次</li>
</ul>
</li>
<li>sysstat

<ul>
<li>统计系统的各种占用资源</li>
<li>cd /etc/cron.d; cat sysstat</li>
<li>CPU监控</li>
<li>查看是否是内存瓶颈</li>
<li>swap的监控</li>
<li>IO的监控</li>
<li>网络监控

<h3>评估磁盘读写性能极限</h3></li>
</ul>


<p>  fio -filename=/tmp/test -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size 2G -numjobs=10 -runtime=30 -group_reporting -name=mytest13
查看IOPS,我的ssd硬盘，在虚拟机中的ubuntu， read：1348 write：1345</p></li>
</ul>


<h1>Jmeter</h1>

<p>Apache组织开发的开源性能测试工具</p>

<h4>ECSHOP</h4>

<ul>
<li>开源，但商业应用需要付费，功能齐全。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL主从复制]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/10/mysql-master-slave/"/>
    <updated>2015-09-10T10:44:16+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/10/mysql-master-slave</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>之前写过一篇MySQL的主从配置，今天这篇文章涉主要涉及理论。</p>

<h1>什么是主从复制</h1>

<ul>
<li>数据拷贝</li>
<li>准实时</li>
<li>源主节点； 目的-从节点</li>
</ul>


<h1>主从复制的原理</h1>

<h4>复制格式</h4>

<ul>
<li>SRB: Statement Based Replication (原生的语句)</li>
<li>PBR: Row （5.7.7变为默认格式）</li>
<li>MBR: Mixed</li>
</ul>


<p>查看复制格式
        show global variables like &lsquo;binlog_format&rsquo;;</p>

<p>配置文件
    [mysqld]
    binlog_format = ROW</p>

<h1>主从复制的用途</h1>

<ul>
<li>试试灾备，用于故障切换（高可用的切换）</li>
<li>读写分离，提供查询服务</li>
<li>备份，避免影响业务</li>
</ul>


<h2>MySQL主从复制的一些模式</h2>

<ol>
<li>一主一从</li>
<li>主主复制</li>
<li>一主多从</li>
<li>多主依从 （mysql5.7开始支持）</li>
<li>联级复制</li>
</ol>


<h1>主从复制的搭建</h1>

<h3>主从部署的必要条件：</h3>

<ul>
<li>主从开启binlog日志（设置log-bin参数）</li>
<li>主从server-id不同</li>
<li>从库服务器能连通主库</li>
</ul>


<h3>主从部署步骤</h3>

<ul>
<li>备份还原(mysqldump )</li>
<li>授权 （grant replicaton slave on <em>.</em>）</li>
<li>配置复制，并启动 (change master to)</li>
<li><p>查看主从复制信息 (show slave status\G)</p>

<h1>主从复制的问题</h1></li>
<li><p>主库宕机，数据可能丢失</p></li>
<li>从库只有一个sql thread, 主库写压力大，复制很可能延时。</li>
</ul>


<h3>MySQL半同步复制</h3>

<h3>MySQL并行复制</h3>

<ul>
<li>社区版5.6新增</li>
<li>并行是指从库多线程，</li>
<li><p>库级别并应用binlog，同一个数据库更新还是串行的（5.7版并行复制基于事务组）</p>

<p>  set global slave_parallel_workers = 10</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL索引]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/10/mysql-index/"/>
    <updated>2015-09-10T10:07:51+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/10/mysql-index</id>
    <content type="html"><![CDATA[<h4>什么是索引</h4>

<p>索引是值到行位置的映射。索引就是一个目录。</p>

<h4>索引的作用：</h4>

<ul>
<li>提高访问的速度。硬盘IO每秒100到150次的响应。每次10毫秒</li>
<li>实现主键、唯一键逻辑</li>
</ul>


<p>IO是个宝贵的资源，</p>

<h4>索引的使用场景：</h4>

<p>FTS 全表索引</p>

<h4>Mysql中我们可以使用的索引类型：</h4>

<ul>
<li>Btree索引：</li>
<li>B+tree： 平衡二叉树的一种改良</li>
<li>Hash索引 InnoDB</li>
<li>Innodb ： 聚簇索引，</li>
<li>二级索引： 除了主键，用户创建的索引。</li>
</ul>


<h4>索引的代价：</h4>

<p>插入修改删除每个索引都编程一个内部事务，索引越多，事务越长。(增删改)</p>

<h4>索引的优势:</h4>

<ol>
<li>减少查询IO</li>
<li>优化等值查询、范围查询</li>
<li><p>利用有序特性</p>

<p> order by , group byh , distinct, max ,min</p></li>
</ol>


<h4>如何用好索引：</h4>

<ul>
<li><p>依据where查询条件来建立索引：</p>

<pre><code>  select a,b from tab_a where c = ?;  #c上建立索引
</code></pre></li>
<li><p>使用联合索引，而不是多个单列索引。</p>

<pre><code>  select * from tab_a where a = ? AND b = ? 
  #建立a和b的索引， 把一组值作为b+tree 的索引， 在同一个树里，查询速度更高。
</code></pre></li>
<li><p>联合索引， 区分度大的放在前面。</p>

<pre><code>  name,gender 对， 因为name的区分度很大。能够更好地使用b+ TREE来定位节点

  gender,name 错
</code></pre></li>
<li><p>联合索引能为前缀单列，复列查询提供帮助。</p>

<pre><code>  where a = ? 
  wherer a = ? AND b =? 
</code></pre></li>
<li><p>合理创建联合索引，避免冗余。
      abc 包含 a ,ab</p></li>
<li><p>ORDER BY, GROUP BY, DISTINCT 字段添加索引</p></li>
<li><p>用 EXPLAIN 查看语句</p>

<pre><code>  possible_key 可以使用的索引
  key 实际的索引名字  重要
  rows  读的记录行数，才返回的结果 重要。
  typpe   index  扫描完整的索引树， 重要   
  key_len 如果只使用了一部分，为长度。  
  force index  强制使用索引 
  ignore index 
</code></pre>

<h4>其他技巧</h4></li>
<li><p>一个表，控制百万级别。如何达到了一两百G，就可以考虑分库分表了。千万级别，取决于访问方式，left join</p></li>
<li><p>WHERE查询时，  函数不要加在字段上。timestamp > func(1234)。</p></li>
<li><p>外键一般用程序使用。</p></li>
<li><p>什么事优化器： 哪个索引会更快，IO更小。生发语法数，生成一个计划。</p></li>
<li><p>纵向分表，根据业务来拆分。</p></li>
<li><p>等值查询 ，2个范围查询， 不能都覆盖到。联合查询。等值能用一个，范围查询也只能用一个。</p></li>
<li><p>通过表结构设计来避免连表。</p></li>
<li><p>触发器和存储过程不好维护，做运维手段还可以。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL Foundation]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/09/mysql-foundation/"/>
    <updated>2015-09-09T15:25:59+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/09/mysql-foundation</id>
    <content type="html"><![CDATA[<h1>认识MySQL</h1>

<h4>关系与非关系型数据库</h4>

<p>关系型数据库</p>

<ul>
<li>mysql</li>
<li>oracle</li>
<li>sql server</li>
<li>postgresql</li>
</ul>


<p>非关系型数据库</p>

<ul>
<li>hadoop</li>
<li>mongoDB</li>
<li>redis</li>
<li>Cassandra</li>
</ul>


<p>区别：</p>

<p>是否使用SQL语句作为数据操作的方法和方式。</p>

<p>所以关系型数据库又叫做SQL数据库。</p>

<h4>为什么学习MySQL</h4>

<ul>
<li>基于GPL协议</li>
<li>Mysql 最流行 ，开源，但不是最先进的。</li>
<li>互联网企业中占绝对主流地位</li>
</ul>


<p>开发者学习MySQL：</p>

<ul>
<li>学习数据类型的正确使用</li>
<li>学习如何利用索引优化查询效率</li>
<li>了解分区，读写分离特性</li>
<li>了解数据库事务相关特性</li>
</ul>


<p>DBA学习MySQL：</p>

<ul>
<li>学习MySQL体系结构知识</li>
<li>学习日常运维，性能调优，故障排查</li>
<li>虚席数据层架构设计，schema优化知识</li>
</ul>


<h1>轻松安装MySQL</h1>

<p>5.6 <a href="http://www.mysql.com/downloads/">http://www.mysql.com/downloads/</a></p>

<ul>
<li>企业版</li>
<li>集群版</li>
<li>社区版 （免费）

<h4>Windows上安装</h4>

<p>安装包：300M+</p></li>
</ul>


<h4>Linux上安装</h4>

<h4>Ubuntu上安装MySQL</h4>

<pre><code>apt-cache search mysql-server
apt-get install mysql-server-5.6
#查看mysql进程
ps -ef|grep mysqld
#查看mysql状态：版本、运行时间、连接方式、查询统计
sudo /etc/init.d/mysql status
#msyql启动、停止、重启
sudo /etc/init.d/mysql start|stop|restart
</code></pre>

<h1>连接使用MySQL</h1>

<ul>
<li>应用程序驱动</li>
<li>MySQL命令行</li>
<li><p>GUI工具</p>

<p>  #查看mysql-client版本
  mysql -V</p></li>
</ul>


<p>命令行连接MySQL</p>

<ul>
<li><p>Socket连接(本地连接)</p>

<pre><code>  mysql -S/var/run/mysqld/mysqld.sock -uhomestead -p
</code></pre></li>
<li><p>TCP/IP连接（远程连接）</p>

<pre><code>   mysql -h127.0.0.1 -P3306 -uhomestead -p
</code></pre></li>
</ul>


<p>本地连接只能在MySQL服务器上创建，常作为MySQL状态检查，或程序和MySQL部署在一台机器上。</p>

<pre><code>#小技巧
Ctrl + r : 搜索之前敲过的命令
</code></pre>

<h3>两个重要的命令： status, show processlist</h3>

<h4>status</h4>

<p>关注的信息：</p>

<ul>
<li>Server version</li>
<li>characterset: utf8 (Server, Db, Client, Conn)</li>
<li>Uptime

<h4>show processlist</h4></li>
</ul>


<p>help select;</p>

<pre><code>#查看socket文件位置
show global variables like 'socket'
</code></pre>

<ul>
<li>socket权限为777</li>
<li>不要把密码直接输入在命令行里面，存在安全风险。</li>
</ul>


<p>history -c 清楚命令行历史</p>

<h4>常用的图形客户端工具</h4>

<ul>
<li>Navicat</li>
<li><p>MySQLWenkBench</p></li>
<li><p>操作简单，易于上手</p></li>
<li>支出图形化的导入导出</li>
<li>可视化的界面输出</li>
</ul>


<p>总结：</p>

<ol>
<li>应用程序使用API接口连接MySQL</li>
<li>开发工程师可以使用图形工具连接MySQL</li>
<li><strong>命令行工具才是DBA的最爱</strong></li>
</ol>


<h1>SQL语言入门</h1>

<p>DDL :
- CREATE TABLE
- DROP TABLE
- ALTER TABLE</p>

<p>DML:</p>

<ul>
<li>SELECT FROM TABLE</li>
<li>INSERT INTO TABLE</li>
<li>UPDATE TABLE SET</li>
<li>DELETE FROM TABLE</li>
</ul>


<p>DCL:</p>

<ul>
<li>GRANT</li>
<li>REVOKE</li>
</ul>


<p>TCL:</p>

<ul>
<li>COMMIT</li>
<li>ROLLBACK</li>
</ul>


<p><a href="http://www.w3school.com.cn/sql/">SQL教程</a></p>

<h1>认识DBA</h1>

<p>DBA是最后一道屏障，守门员，是业务稳定的基石。</p>

<p>监控线上，保障业务的正常运行。</p>

<p>做好实时性能监控,一旦有长的SQL语句，就会立刻接到报警，然后进行调优。</p>

<h4>小公司</h4>

<ul>
<li>没有专职DBA</li>
<li>但肯定有懂数据库的人</li>
</ul>


<p>大公司：</p>

<ul>
<li>专职DBA</li>
<li>数据存储技术专家</li>
</ul>


<p>互联网业务： 高性能、高可用、可扩展、安全性。</p>

<p>没有DBA就没有稳定的数据库，请求变慢，数据丢失，安全问题，用户投诉，无穷无尽。</p>

<h3>DBA要做哪些工作？</h3>

<ol>
<li>基础运维

<ul>
<li>安全部署</li>
<li>监控</li>
<li>故障处理</li>
</ul>
</li>
<li>安全运维工作

<ul>
<li>数据备份与恢复</li>
<li>安全访问，安全漏洞</li>
<li>审计</li>
</ul>
</li>
<li>性能调优工作

<ul>
<li>数据库优化</li>
<li>容量评估、软硬件升级</li>
</ul>
</li>
<li>开发支持工作

<ul>
<li>存储方案制定(哪些数据放在memcache，减少对数据库的访问)</li>
<li>数据库设计</li>
<li>数据库变更 SQL Review （审核业务SQL，全表扫描的SQL会把数据库跑死）</li>
</ul>
</li>
<li>流程与培训

<ul>
<li>数据库开发规范</li>
<li>运维流程与标准化</li>
<li>业务培训</li>
</ul>
</li>
</ol>


<p>练习：
mysql要做的：</p>

<p>分析MySQL慢日志请求，优化表索引</p>

<h4>DBA需要的技能</h4>

<p>专业技能：
    - 数据库原理
    - Linux与Shell
    - 计算机体系结构
    - 网络原理
    - 数据库系统与操作
    - 服务器硬件
    - 业务架构设计
软技能：</p>

<pre><code>- 责任心、执行力
- 坚韧，抗压（半夜、凌晨工作）
- 学习与沟通能力
- 正直，诚信
- 耐心，注重细节
- 分析能力
- 团队协作
- 
</code></pre>

<p>DBA如何发展？</p>

<ul>
<li>业务架构师（数据存储有深入研究，处理不同业务场景与需求的数据存储）</li>
<li>运维专家（解决mysql的任何问题，帮助数据库更稳定更高效的运行）</li>
<li>数据库研发（改进数据库系统或开发自己的数据库）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel5 基础]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/09/learn-laravel-from-scratch/"/>
    <updated>2015-09-09T11:09:29+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/09/learn-laravel-from-scratch</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>Laravel 5 的很多新功能是来自 Jeffrey Way的 idea,</p>

<p>如: Form Requests, Laravel Elixir, Command bus etc..</p>

<p>所以, 他的这套视频就很有观看的必要
 <a href="https://laracasts.com/series/laravel-5-fundamentals">https://laracasts.com/series/laravel-5-fundamentals</a></p>

<p>现已看完，做下记录</p>

<h2>Laravel5 Foundation</h2>

<h4>需求分析：</h4>

<ol>
<li>Article模块

<ul>
<li>Articles List</li>
<li>Create Article :title , body, published_at, tag</li>
<li>Edit Article</li>
</ul>
</li>
<li>用户登录模块</li>
</ol>


<h4>细节：</h4>

<ol>
<li>Create Article的输入内容，要进行validate，使用Request进行验证。</li>
<li>Create Article成功时，用Flash Message提示。</li>
</ol>


<h4>学习的内容</h4>

<ul>
<li>Composer 的安装与使用</li>
<li>Virtual Box, Vagrant, Homestead安装与使用</li>
<li>Route 路由的使用</li>
<li>Blade  模板文件</li>
<li>.env 开发环境的设置</li>
<li>migration 创建和修改数据库的结构</li>
<li>MVC在Laravel中的工作流</li>
<li>Form表单</li>
<li>Model 中的 Dates : Carbon\Carbon</li>
<li>Model 中的 Scopes : 封装判断条件（例如： article是否发布）</li>
<li>Model 中的 set Attributes : 插入记录时，自动插入（例如时间）</li>
<li>View Partials 视图文件的局部选软</li>
<li>Eloquent  这个很强大，但感觉复杂查询会很麻烦，// todo 继续深入学习</li>
<li>Auth  Laravel5.0 提供了简单的注册、登录和找回密码</li>
<li>Middleware （用处：例如验证是否用户登录）</li>
<li>Many to Many Relation (A article has many tags, and a tag has many articles.)</li>
<li>Tag 选择地时候用了Select2插件</li>
<li>View Partial Always Receive Data (例如首页导航条)</li>
<li>Service Container (又叫 Ioc Container,是Laravel框架的核心所在)</li>
</ul>


<h3>用到的第三方包</h3>

<pre><code>{
    “require” : {
        "barryvdh/laravel-ide-helper": "^2.1",
        "illuminate/html": "^5.0",
        "laracasts/flash": "~1.3",
    }
}
</code></pre>

<ul>
<li>barryvdh/laravel-ide-helper  用来提示Laravel的Facade</li>
<li>illuminate/html Html Form封装了form表单</li>
<li>laracasts/flash Jeffrey Way写的 flash message</li>
</ul>


<p>以上文件放在composer.json中，第二步是在config/app.php配置 provider 和 alias.</p>

<h3>经常用到的命令</h3>

<pre><code>php artisan make:controller --plain
php artisan dump-autoload 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cross Site Request Forgery]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/05/csrf/"/>
    <updated>2015-09-05T17:00:56+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/05/csrf</id>
    <content type="html"><![CDATA[<p>CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。</p>

<h3>CSRF 攻击的防范；</h3>

<ol>
<li><p>加密令牌：web应用程序可以在网页中嵌入一个加密的令牌，所有的请求都包含这个加密令牌，由于跨站请求无法获取这个令牌，所以伪造的请求很容易就被服务器识别；</p></li>
<li><p>Referer头途径：使用web应用程序也可以验证请求来源页面的Referer，然后由于隐私考虑，这个referer经常被客户端过滤；</p></li>
</ol>


<h3>加密令牌</h3>

<p>1.根据 加密参数、用户的session_id(), 时间戳和存放在session中的HASH函数。</p>

<p>把令牌token和时间戳 放到form的hidden里面。</p>

<pre><code>$_SESSION[STOKEN_NAME] = gen_token(); // 随机数
&lt;input type="hideen" value="session_token" value= &lt;?=$_SESSION[STOKEN_NAME]?&gt;
</code></pre>

<p>每次请求的时候，要验证session_token。</p>

<p>参考链接：</p>

<ol>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></li>
<li><a href="https://www.shiyanlou.com/courses/303#">实验楼 - Elgg 系统 CSRF 攻击实验</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xdebug]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/02/xdebug/"/>
    <updated>2015-09-02T22:57:38+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/02/xdebug</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>掌握Xdebug是每一个PHP程序员必备的技能。</p>

<p>当你在使用Yii, ThinkPHP, Laravel框架的时候，你只有了解其系统架构后，才能更好的编写代码。Xdebug能够帮助你更好的调试代码。</p>

<p>安装XDebug在<a href="http://xdebug.org/wizard.php">官网</a>输入你的phpinfo()信息，然后按照它的提示进行安装。</p>

<p><a href="http://xdebug.org/docs/remote">远程调试</a>
<a href="http://aicode.cc/article/362.html">中文文档</a></p>

<pre><code>[xdebug]
zend_extension = /usr/lib/php5/20131226/xdebug.so
xdebug.remote_enable=1
xdebug.remote_host=localhost
xdebug.remote_port=9000
xdebug.remote_connect_back=1
xdebug.remote_autostart=1
xdebug.profiler_enable=1
xdebug.profiler_output_dir="/tmp"
xdebug.idekey=PHPSTORM
</code></pre>

<p>php -v查看是否安装成功</p>

<pre><code>root@homestead:/etc/php5/fpm# php -v
with Xdebug v2.3.3, Copyright (c) 2002-2015, by Derick Rethans
</code></pre>

<p>php &ndash;ini</p>

<p>我在这里遇到了一个坑，因为ubuntu环境下的php配置文件被拆分成多块，要在cli 下使用 php &ndash;ini来查看配置文件的位置。</p>

<p>PHPStrom与Xdebug的结合使用，有一系列的配置。</p>

<p>PHPStrom配置，一个是在PHP SCRIPT, 另一个是PHP WEB APPLICATION.</p>

<h1>后续</h1>

<p>在上面折腾了一番后，原来我使用Laravel提供的Homestead开发环境已经提供了XDebug，已经开启了远程调试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop介绍]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/30/hadoop-intro/"/>
    <updated>2015-08-30T16:22:21+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/30/hadoop-intro</id>
    <content type="html"><![CDATA[<p>慕课网<a href="http://www.imooc.com/learn/391">Hadoop大数据平台架构与实践&ndash;基础篇</a> 的文字记录</p>

<h1>初识Hadoop</h1>

<h2>课程简介</h2>

<h4>介绍的内容：</h4>

<ol>
<li>大数据技术的相关概念</li>
<li>Hadoop的架构和运行机制</li>
<li>实战：Hadoop的安装和配置</li>
<li>实战： Hadoop的开发</li>
</ol>


<h4>学习目标：</h4>

<ol>
<li>掌握大数据存储与处理技术的原理（理论知识）</li>
<li>掌握Hadoop的使用和开发能力（实践能力）</li>
</ol>


<h4>课程学习建议：</h4>

<ol>
<li>书籍：

<ol>
<li>《Hadoop权威指南》</li>
<li>《Hadoop技术详解》</li>
</ol>
</li>
<li>实践很重要，边听边实践</li>
</ol>


<h4>课程预备知识</h4>

<ol>
<li>Linux常用命令</li>
<li>Java编程基础

<h2>Hadoop的前世今生</h2>

<p>单机的系统瓶颈： 存储容量，读写速率，计算效率</p></li>
</ol>


<p>Google大数据技术：
1. MapReduce
2. BigTable
3. GFS</p>

<ul>
<li>革命性的变化1：成本降低，能用PC机，就不用大型机和高端存储。</li>
<li>革命性得变化2： 软件容错硬件故障视为常态，通过软件保证可靠性</li>
<li>革命性的变化3： 简化并行分布式计算，无须控制节点同步和数据交换</li>
</ul>


<p>Google只发表了论文，没有开放源代码。</p>

<p>Hadoop是一个模仿大数据技术的开源实现。</p>

<h2>Hadoop的功能与优势</h2>

<h4>什么是Hadoop</h4>

<p>Hadoop是<strong>开源的</strong>， <strong>分布式存储</strong> + <strong>分布式计算平台</strong>。
<a href="http://hadoop.apache.org/">http://hadoop.apache.org/</a></p>

<p>它包括两个核心组成：</p>

<ul>
<li>HDFS: 分布式文件系统，存储海量的数据</li>
<li>MapReduce: 并行处理框架，实现任务分解和调度</li>
</ul>


<h4>Hadoop可以用来做什么?</h4>

<p>搭建大型数据仓库，PB级数据的存储、处理、分析、统计业务。</p>

<ul>
<li>搜索引擎</li>
<li>商业智能</li>
<li>日志分析</li>
<li>数据挖掘</li>
</ul>


<h4>Hadoop的优势</h4>

<ol>
<li>高扩展</li>
<li>低成本</li>
<li>成熟的生态圈</li>
</ol>


<h4>Hadoop的应用情况</h4>

<ul>
<li>国外： facebook twitter yahoo intel hulu linkedIn</li>
<li>国内： 百度，京东，淘宝，华为，新浪微博，小米，腾讯，网易</li>
</ul>


<p>Hadoop已成为业内大数据平台的首选</p>

<h4>Hadoop的人才需求</h4>

<ol>
<li>Hadoop开发人才</li>
<li>Hadoop运维人才</li>
</ol>


<h2>Haoop的生态系统及版本</h2>

<h4>生态系统</h4>

<ul>
<li>Hive

<ul>
<li>中文：小蜜蜂，不需要Hadoop任务程序，只需要写SQL语句。降低了使用Hadoop的使用门槛</li>
<li>它是基于Hadoop之上的一个数据仓库</li>
</ul>
</li>
<li>HBase 存储结构化数据的分布式数据库。

<ul>
<li>与传动数据相比：放弃事务特性，最求更高的扩展</li>
<li>与HDFS的区别：随机读写和实时访问，实现对表数据的读写功能</li>
</ul>
</li>
<li>zookeeper

<ul>
<li>像动物管理员一样，监控Hadoop集群里面每一个节点的状态。管理配置，维护节点之前的一致性

<h4>版本</h4></li>
</ul>
</li>
</ul>


<p>1.x 与 2.x （现在2.6）</p>

<p>我们选择1.2的版本，因为1.x稳定，且对于新手易于理解容易上手。</p>

<hr />

<h1>Hadoop的核心 - HDFS简介</h1>

<h2>HDFS设计架构</h2>

<ul>
<li>Blocks

<ul>
<li>HDFS的文件被分成块进行存储</li>
<li>HDFS块的默认大小为64M</li>
<li>块是文件存储处理的逻辑单元</li>
</ul>
</li>
<li>NameNode

<ul>
<li>NameNode是管理节点，存放文件元数据</li>
<li>文件与数据块的映射表</li>
<li>数据块（Block）与数据节点(DataNode)的映射表</li>
</ul>
</li>
<li>DataNode

<ul>
<li>用来存放数据块的。</li>
</ul>
</li>
</ul>


<h2>数据管理策略</h2>

<h4>HDFS数据管理与容错</h4>

<p>每个数据块3个副本，分布在两个机架内的三个节点</p>

<h4>心跳检测</h4>

<ul>
<li>DataNode定期向NameNode发送心跳信息</li>
<li>二级NameNode定期同步元数据镜像文件和修改日志， NameNode发生故障时，备胎转正。</li>
</ul>


<h4>HDFS读取文件流程</h4>

<h4>HDFS特点</h4>

<hr />

<h1>Hadoop的核心 - MapReduce简介</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能瓶颈]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/30/performance-bottleneck/"/>
    <updated>2015-08-30T00:10:51+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/30/performance-bottleneck</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>今天和一位搞运维研发的同学聊天，问如何解决300万条订单数据的分析。</p>

<p>答：看性能瓶颈在哪里，<strong>读慢加缓存，写慢加队列</strong></p>

<p>可以研究一下内容：hadoop、spark、分布式数据库hbase，其中Spark利用内存计算会快些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大数据简介]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/29/big-data-intro/"/>
    <updated>2015-08-29T23:47:10+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/29/big-data-intro</id>
    <content type="html"><![CDATA[<p><a href="http://mooc.study.163.com/course/Wiley-1000077001#/info">网易云课堂-大数据简介</a></p>

<h1>大数据的定义</h1>

<p>大数据可以定义为一个巨大的数据集，
在可接受的时间范围内，它可以用来获取、存储、搜索、转换、分析以及可视化相关的信息或数据。</p>

<h1>大数据的三个特性</h1>

<ol>
<li>Volume 容量巨大</li>
<li>Velocity 产生速度快 处理速度快</li>
<li>Variety 种类繁多</li>
</ol>


<p>例子：</p>

<ul>
<li>Twitter每秒产生80M的数量</li>
<li>eBay每天可以实施分析500万交易</li>
<li>产生的数据又各种类型，因为数据的来源不同。数据有结构化数据（database,excel）、半结构化数据(word)和非结构化数据（图片、文件）。</li>
</ul>


<h1>大数据的三个来源</h1>

<ol>
<li>社交</li>
<li>机器   : 例如RFID射频识别信息</li>
<li>交易数据</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SCRUM敏捷式开发（Agile）思维整理]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/29/agile/"/>
    <updated>2015-08-29T12:33:45+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/29/agile</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>今天看到朋友圈里关于<a href="www.teambition.com">teambition</a>团队协作工具的介绍。</p>

<p>由此联想到了以前公司的SCRUM敏捷式开发。这里整理一下敏捷式团队开发的一些思绪。</p>

<h1>SCRUM</h1>

<p><img src="http://images.cnblogs.com/cnblogs_com/taven/201010/2010-10-17_202832.png" alt="" /></p>

<p>就如上图(图片为网络搜寻)所看到的，一个超大的白板上规矩的排满了各种纸条。每个纸条上写着各种任务。如果谁对这个任务感兴趣，就在这个纸条上写上自己的名字。为了便于说明，我假设了一个场景进行阐述。</p>

<h4>周一上午</h4>

<p>IT经理已经和总经理进行了讨论。IT 经理说：</p>

<ol>
<li><p>上周，市场部门已经提前跟我说过，国庆节来了，我们是一个电商网站，要做出一些活动，所以们这周会给3个月内未购买过产品的用户发电子邮件。这个任务包含了前端HTML和后端PHP的一些逻辑。</p></li>
<li><p>我们的网站要有一个法语的版本，所以我们在接下来的这两个星期会考虑我们的数据库设计。</p></li>
</ol>


<p>&hellip;（省略若干任务）</p>

<h4>周一下午</h4>

<p>IT部门的10个人聚集在会议室。打算做两件事情：</p>

<ol>
<li><p>讨论上周的任务完成情况，当然在一般的情况下，这些任务是都完成了的。Review一下成果。</p></li>
<li><p>讨论IT经理上午和总经理谈得任务，把每条任务进行逐行分解。并把任务平均分配到2个team上。接下来把任务打印出来。贴到白板上。正如上图所见，左面第一列的每一个方格子内是一系列相关的任务，这是打算是打算要这两个星期要做的事情。</p></li>
</ol>


<h3>周二上午10点</h3>

<p>每天上午，IT部门的10个人站在这块白班前面，把自己今天打算要做的任务纸条上写下自己的名字，然后挪动到中间的格子里。叙说一下我对这个任务的看法，打算怎么做，预估多长时间能够昨晚。</p>

<h3>周三上午</h3>

<p>每天早上10点，IT部的人都会站在这块白板前面，对写下名字的任务叙说3件事情：</p>

<ol>
<li>我昨天做了什么</li>
<li>我遇到了哪些困难</li>
<li>我今天打算做些什么</li>
</ol>


<h3>周四上午</h3>

<p>这里叙说一下为什么站在白板前面，而不是坐在会议室里，因为这样站着效率跟高效，10分钟就能够讨论结束。其实每天早上的这个会议叫做Sprint会议。</p>

<p>今天有人已经完成了任务，他会把任务纸条放在最右边的那栏里，表示任务已经完成。</p>

<h2>总结：</h2>

<p>OK, 这就是我执行了2年的SCRUM敏捷式开发的流程。我是一个执行者的流程来看待这件事件。它的优点：</p>

<ol>
<li>任务清楚，明确，一切围绕着目标。</li>
<li>中途加入的临时任务如果不是特别紧急、重要会安排到下周。</li>
</ol>


<p>缺点：
1. 每天时间满满的一个任务接着一个任务，时间久了会有些疲惫。</p>

<p>每一段工作任务都会会学到很多东西，把它记录下来，总结下来，为下一家公司发光发热。</p>

<p>这有一个网上的SCRUM可以看看<a href="http://home.leangoo.com/">leangoo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何成为高级程序员]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/28/senior-programmer/"/>
    <updated>2015-08-28T08:00:02+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/28/senior-programmer</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>高级程序员都干些什么呢？怎样才能成为高级程序员呢？其实初级或刚入行的朋友喜欢问这样的问题。可能想把作为下一个奋斗的目标吧。下面是微信账号“威哥干Java”的看法。</p>

<p>一个项目好比画了两个圈，内外镶嵌，高级程序员负责内圈代码，初级程序员负责外圈代码。想要成为高级程序员，你就得往内圈挤。</p>

<p>从专业的角度上有三点：</p>

<ol>
<li>确定开发团队、技术路线和技术架构，为关键模块设计技术实现，能够满足长期发展的业务需要。</li>
<li>能参与系统调研，需求分析。负责概要设计、详细设计， 开发计划等编制并实施。负责核心内码通用模块功能实现，解决一些技术问题。</li>
<li>负责提升团队技术能力，协同项目经理进行项目开发，并实现重要的功能，指导和培养团队的成员。</li>
</ol>


<p>满足3个必备条件：</p>

<ol>
<li>具备看官方英文文档的能力。</li>
<li>上专业顶级的社区。</li>
<li>成为Github重度感染者。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[缓存]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/26/cache/"/>
    <updated>2015-08-26T16:26:59+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/26/cache</id>
    <content type="html"><![CDATA[<h3>缓存的类型</h3>

<ul>
<li>局域网缓存</li>
<li>网络缓存</li>
<li>硬盘缓存</li>
<li>内存缓存</li>
<li>数据库缓存</li>
<li>Opcode缓存</li>
<li>客户端浏览器缓存</li>
</ul>


<h3>opcode</h3>

<p>Opcode是一种PHP脚本编译后的中间语言</p>

<ul>
<li>opcache php5.5 默认安装</li>
<li>xcache  php5.4</li>
<li>php 5.2 zned optimization 被淘汰了。</li>
<li>wincache windows下</li>
<li>APC  PHP5.4  （PS: 上一家公司安装了APC）</li>
</ul>


<p>APCU xcache wincache 支持php API调用 （默认情况下 效率高于memcache）</p>

<h4>客户端浏览器缓存</h4>

<p>客户端缓存 （浏览器缓存） 静态资源引用公共服务器资源</p>

<p>把图片放在多个域名下，可以多线程加载图片 例如pc1.domain.com pc2.domain.com</p>

<p>xxx.com/abc.js?t=1234343 开发测试的时候，用这种方法防止浏览器缓存。给静态资源加时间戳带尾巴。</p>

<p>在发行产品的时候带版本号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[水平分表]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/26/fen-biao/"/>
    <updated>2015-08-26T16:21:34+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/26/fen-biao</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>学习分库、分表的一记录，后期整理，添加示例。</p>

<h1>正文</h1>

<p>数据库分表与分库的实现方法：</p>

<p>tb_user_0  &hellip; tb_user_1 &hellip;.tb_user_2 &hellip;. tb_user_3</p>

<hr />

<p>当多张表具有完全相同的数据结构时，我们认为这些表示对一个实体数据的横向切分。</p>

<p>每张表都可以有自己的id
但是所有切分出来的表必须具备全局uid
分表后要按照某个元素（通常全局id）进行某种算法的计算，得到表后缀。</p>

<p>id生成器。（用redis做id在断电的情况下有风险），通常用mysql</p>

<p>uuid 得到一个字符串</p>

<p>自建索引</p>

<p>当数据库大了，分表是必然的。分表之后，建索引是必然的。</p>

<p>将全局id进行一次md5将得到一个由16进制数值组成的32位字符串。 数据越多越均匀。分成15张表，</p>

<p>或分成256张表。</p>

<p>分成80张： FF = 255 255%80 取余数。分多少张表，就余多少。</p>

<hr />

<p>如果只是做简单切分的时候后，我们会遇到问题：</p>

<ol>
<li>当我们需要将这些数据进行统计与分析的时候，不能使用聚合函数</li>
<li><p>当我们查询某条数据时，我们必须要知道我要查询的数据在哪一张表里，否则我就需要查询所有的表来查找结果。</p></li>
<li><p>当我插入数据的时候，我必须尽可能的让每张表的负载均匀</p></li>
<li>当我要修改数据的时候，我必须明确我要修改的数据在哪里。</li>
</ol>


<p>在不同的时期分表，会产生不同的问题。</p>

<ol>
<li>项目启动阶段就进行分表</li>
<li>项目启动阶段没有分表，而是在项目进行到积累了一定数据量以后再进行分表</li>
<li>项目之前就进行切分过表，但是被切分后的表经过长时间运行，又产生了大量数据，需要再次分表</li>
</ol>


<p>。</p>

<p>合理的分表不单单能解决单张表数据量过大的问题，还能优化我们的业务逻辑。</p>

<p>tb_product_store_sh
tb_product_store_bj
tb_product_store_hubei</p>

<p>基于区域位置的分表，非常适合做类似库存，商户信息，工商管理等有着明显区域性的数据分表。</p>

<p>基于IP地址的分表， 用于统计与分析数据。访问日志。
（几十万的数据开始考虑分表。）
当数据达到100多万的时候，就要考虑分表。</p>

<p>按时间分表，
日志。
财务报表。
绩效考核。</p>

<p>工资流水、销售业绩、出纳凭证等记录，按年份来分表。</p>

<p>考勤记录  销售业绩
个人考勤记录 签单记录  按月分表比较适合</p>

<p>季度、半年度、部门业绩 工资资产 等</p>
]]></content>
  </entry>
  
</feed>
