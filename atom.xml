<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[hanfeng.name]]></title>
  <link href="http://fenghan.github.io/atom.xml" rel="self"/>
  <link href="http://fenghan.github.io/"/>
  <updated>2015-08-21T21:24:07+08:00</updated>
  <id>http://fenghan.github.io/</id>
  <author>
    <name><![CDATA[HanFeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[负载计算方法及不同语言开发解决性能问题的思想等]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/21/performance/"/>
    <updated>2015-08-21T14:52:36+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/21/performance</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>当项目复杂度和用户数提高的时候，我们常常会遇到以下问题：卡、 挂、 数据备份、 数据分析、 安全、 24小时在线、 多平台、 多端、 跨地域、 实时性强。</p>

<p>总结起来就是以下4个方面：</p>

<ol>
<li>性能问题</li>
<li>交互问题</li>
<li>安全问题</li>
<li>可持续发展与维护</li>
</ol>


<h1>性能计算</h1>

<h3>不同语言开发解决性能问题的思想</h3>

<ol>
<li><strong>PHP -> 多线程</strong></li>
</ol>


<p>PHP通常是和Apache一起来工作，将PHP作为Apache的一个模块来使用，或者采用FastCGI方式通过FPM与web容器通信。我们的每一个用户的请求都将使用一个进程来处理用户请求。</p>

<ol>
<li><strong>JAVA -> 多线程</strong></li>
</ol>


<p>单个进程中同时有多个函数在运行，我们就认为这个应用时多线程的。</p>

<ol>
<li><strong>NodeJs -> 单进程单线程</strong></li>
</ol>


<p>Nignx 与 nodejs jetty 提升效率的方法相同。</p>

<p>都是 异步&amp;非阻塞。</p>

<h4>阻塞</h4>

<p>Apache接收到用户的请求 -> 创建php进程处理请求 -> php通过Http协议解析获取用户提交数据 -> 进行数据过滤与加工 -> (接收用户上传的文件) ->
(对图片缩放/给图片加水印) -> 将数据插入到数据库  -> 等待数据处理完成  -> 加载模板 -> 输出页面 -> 结束进程 -> 回收资源</p>

<p>PHP是单线程的，所以要等待用户上传文件、等待对图片处理、等待插入数据库的结果。一直在等待，所以耗时间。而nodejs是基于事件的编程、非阻塞，效率高。</p>

<h1>高负载项目优化</h1>

<h4>IO  Input/Output</h4>

<ul>
<li>磁盘IO</li>
<li>网络IO</li>
<li>数据库IO</li>
</ul>


<h4>性能测试</h4>

<ul>
<li>php 系能测试</li>
<li>mysql读写性能测试</li>
<li>文件 读写性能测试</li>
</ul>


<h4>测试工具</h4>

<ul>
<li>Apache ab</li>
<li>Apache JMeter</li>
</ul>


<h2>负载的计算方法</h2>

<ul>
<li>网络连接最大并发数 B</li>
<li>单次请求的处理时间  dt</li>
<li>用户n秒请求一次</li>
<li>发摩擦系数s ： 一般 0.65</li>
<li>负载 = B/dt * n</li>
</ul>


<p>例子：</p>

<ul>
<li>网络连接最大并发数 B = 1000 次</li>
<li>单次请求的处理时间  dt = 3秒</li>
<li>用户30秒请求一次 n = 30秒</li>
<li>发摩擦系数s ： 一般 0.65</li>
<li>每秒能处理的请求数 = 1000次 /3秒</li>
<li>负载 = 每秒能处理的请求数 * 30秒 * 0.65 = 6500</li>
</ul>


<p>总结：</p>

<ol>
<li>负载 就是ＷEB服务能够支持的最大访问人数，不卡，不Down机。它取决于3点（最重要的）：网络最大连接数、单次请求处理时间 和 用户多少秒请求一次。</li>
<li>对网络连接最大并发数 B 起决定性作用的依次是带宽、内存、CPU、操作系统。</li>
<li>减少单次处理请求时间，对程序员说很困难。</li>
<li>提高用户请求一次的时间是一个有效的办法，所以一个好的网页交互师很重要。比说增加验证码、提示框等。</li>
</ol>


<h4>集群：</h4>

<p>在同一个项目，多台服务器一起工作</p>

<h1>数据库优化原理</h1>

<ol>
<li>优化第一条：针对查询建索引。where条件要匹配索引，叫做命中索引。</li>
</ol>


<p>问： 索引为什么会加速查询？</p>

<p>答：因为添加索引，会优化搜索算法，使用了二叉树、平衡二叉树、红黑树升级的算法。建立索引，查询速度会集合倍提高。 牺牲了写入数据的效率，换来了查询的速度。但因为我们大部分都是查询，写入的少。性能不会凭空产生</p>

<p>容器：内存中可以用来保存其他对象的对象，比如链表、数组、hashmap</p>

<p>资源：应用程序从内存意外的地方读取或写入数据的对象成为资源，比如网络，比如磁盘文件。涉及资源IO的程序通常速度都会比较慢。</p>

<p>结果集： 自己是个容器，从结果集获取数据的本质是一种资源，也是一个集合，不能有重复。（<strong>结果集是一个保存指向数据库资源指针的集合</strong>）</p>

<p>当多个条件查询的时候，and条件表示左右两个条件搜索到的结果集做交集。
如果使用or连接两个条件，左右两个条件搜索的结果做并集。</p>

<p>selec &hellip; limit 0, 20;</p>

<p>遍历结果集，从数据库文件里面取。</p>

<p>select &hellip; where id = 1;</p>

<p>   &hellip;.</p>

<p>select &hellip;. where id = 20;</p>

<p>分页的作用：让每一次数据查询返回的结果集可控。</p>

<p>数据的查询一定要分页。</p>

<p>当写入大于查询的时候，要去索引，去掉只剩下一个id。</p>

<h3>读写差异定制</h3>

<p>数据库主从，主库没有索引，从库加索引。数据库的主从原理是根据主库的日志，把主库的bin log日志再从新执行一遍，这叫读写差异定制。</p>

<h3>自建索引</h3>

<p>如果是单个数据库。</p>

<p>建立索引越多-> 插入一条数据时间长->锁表时间长 -> 其他记录等待时间长
并发的时候， 堵车撞车几率就大。就容易让数据库挂掉。</p>

<p>不锁表，MySQL的连接数也会增加，满了。PHP连不上mYSQL, Nginx连不上mysql，会报502。索引越多越糟糕</p>

<p>user  基本表
user_index   保存搜索条件。</p>

<p>一台机器，专门用来保存数据。另一台数据用来保存索引。
或者一个库用来保存数据，另一个库来保存索引。</p>

<p>每天固定时间建立索引。</p>

<p>这叫做<strong>异步建索引</strong></p>

<h4>sphinx</h4>

<p>爬数据库的爬虫，为我们的数据库建立索引。</p>

<p>能够大幅提升性能，对小说站，资讯站很有用。但是优缺点：不是实时索引。</p>

<h4>redis索引</h4>

<p>微博 把索引放到了redis里面，建立实时索引。</p>

<p>插入数据的时候，把索引写到redis里面。 查询数据，从redis里把满足用户的id查询出来。再查mysql数据库。 每一条索引都命中id，效率会特别高。</p>

<p>list可以保存索引，hash缓存对象，set用来交并集处理。所以，redis有建立索引和保存数据的作用。</p>

<p>redis：1.数据结构支持（消息队列） 2. 缓存 3. 索引（要存储到数据库）</p>

<h4>　笛卡尔集</h4>

<p>Ａ　Ｂ　Ｃ　三个表</p>

<p>Ａ表搜索１０条记录找到１条，Ｂ表搜索到５条记录找到１条，Ｃ表搜索５条记录。</p>

<p>连表的话，会搜索１００条记录。</p>

<p>根据业务逻辑做优化。</p>

<h3>分表分库</h3>

<ul>
<li>横向： 横切一刀， 表的数据被分成两部分。</li>
<li>纵向： 刷刷两刀，一个表的字段减少。</li>
</ul>


<p>优化最求：所有的事情可控。</p>

<p>小规模分表、大规模分库。</p>

<p><strong>横向切表</strong>
tb_user</p>

<p>tb_usser0</p>

<p>tb_usser1</p>

<p>tb_usser2</p>

<p>tb_usser3</p>

<p><strong>纵向且表，表重构</strong></p>

<p>tb_user_login</p>

<p>tb_user_info</p>

<p>tb_user_account</p>

<p>多主多从。
多主一从。
互为主从。</p>

<h3>MongDb</h3>

<p>支持平行扩容和分片</p>

<p>高性能、高并发、海量扩容</p>

<p>js + mongodb: 效率高、速度快、并发高、数据扩容方便</p>

<h1>Mysql主从配置</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker灵雀云]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/21/alauda/"/>
    <updated>2015-08-21T02:24:30+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/21/alauda</id>
    <content type="html"><![CDATA[<p>今晚把博客迁移到了<a href="http://alauda.cn">灵雀云</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Redis实现消息队列]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/20/redis-message-queue/"/>
    <updated>2015-08-20T22:40:48+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/20/redis-message-queue</id>
    <content type="html"><![CDATA[<h1>目标</h1>

<ol>
<li>用户注册时，将注册信息（例如用户名、密码、邮箱等）Push到Redis的List里。</li>
<li>用PHP-CLI脚本，读取队列的消息，存取到数据库。</li>
</ol>


<p>代码如下：</p>

<ul>
<li><a href="https://github.com/hildalove/tiny/blob/master/Tiny/MessageQueue/PHPMQ.php">PHPMQ CLASS</a></li>
<li><a href="https://github.com/hildalove/tiny/blob/master/Tiny/MessageQueue/UserMQ.php">UserMQ CLASS</a></li>
<li><a href="https://github.com/hildalove/tiny/blob/master/App/Controller/MQ.php">user reg Controller</a></li>
<li><a href="https://github.com/hildalove/tiny/blob/master/cron/user_mq.php">PHP-CLI CRON</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Phpredis小结]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/19/phpredis/"/>
    <updated>2015-08-19T15:28:13+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/19/phpredis</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>PHP 安装redis有两种方法，这篇文章所阐述的内容是以扩展的方式安装phpredis</p>

<h1>Redis</h1>

<pre><code>apt-get install redis-server
apt-get install php5-redis
</code></pre>

<p>我们通过 apt-get安装的扩展配置将出现在  /etc/php5/mods-available</p>

<p>把将要启用的模块的配置文件做一个软连接到
/etc/php5/apache2/conf.d  (LAMP/LNAMP) <br/>
/etc/php5/fpm/conf.d (LNMP )</p>

<p>通常情况系统会帮我们做好软连接.</p>

<p>redis的应用场景：
1. 用户访问量
2. 用户活跃度，每日的访问量 setbit
3. 存储Session</p>

<p>提供内存缓存
数据结构</p>

<p>postgress 做集群和横向扩容的时候比较麻烦</p>

<p>用redis的hash和list做索引，用mysql做数据存储
自建索引（hash list）</p>

<p>用list记录用户访问页面，堆栈</p>

<p>首页做缓存，放到redis里面</p>

<h2>redis高级数据结构 bitmaps 和 HyperLogLogs</h2>

<p>php单进程的
请求结束后，进程回收。
只能够保证每次请求连接一次redis</p>

<h2>新的数据结构</h2>

<p>bitmaps,
HyperLogLogs: 占用少量内容，</p>

<p>计算内存消耗，计算CPU消耗</p>

<p><strong>性能和开销</strong></p>

<p>一天人均15次，每天100万用户访问。
每次用户访问都写入日志。
用户的每一次会话都产生一次id</p>

<p>目标：搭建每日访问100万用户的网站架构。</p>

<p>Redis的Pub/Sub</p>

<h3>redis3.0</h3>

<p>系统必须装有gcc</p>

<p>redis 3.0安装
wget <a href="http://download.redis.io/releases/redis-3.0.0.tar.gz">http://download.redis.io/releases/redis-3.0.0.tar.gz</a></p>

<p>tar -zxvf redis-3.0.0.tar.gz
cd redis-3.0.0
make
make install</p>

<p>编译好的文件默认在src目录中</p>

<h1>Todo</h1>

<p>写一个phpredis的类，有以下要求：
1. 单例模式，只实例化一次Redis
2. 封装connect, auth, 选择哪个库</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建自己的PHP开发框架]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/17/buid-your-own-php-framework/"/>
    <updated>2015-08-17T17:24:04+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/17/buid-your-own-php-framework</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>想要搭建一个自己的PHP框架，需要哪些功能呢？</p>

<ul>
<li>单一入口</li>
<li>类的自动加载</li>
<li>MVC</li>
<li>易于配置</li>
<li>有电子商务相关的接口：购物车，订单，支付</li>
</ul>


<h1>如何实现</h1>

<h3>单一入口</h3>

<p>nginx配置</p>

<pre><code>location / {
    try_files $uri $uri/ /index.php?/$uri;
}
</code></pre>

<ol>
<li>将uri全部定向到index.php</li>
<li>在入口文件，实现路由分发，实化例Ccontroller类，然后调用方法。</li>
</ol>


<h3>类的自动加载</h3>

<ol>
<li>维护命名空间与绝对路径的映射</li>
<li>使用spl_autoload_register注册函数，当调用不存在的类时，自动加载。</li>
</ol>


<h3>MVC</h3>

<ol>
<li>每个Controller继承一个Controoler，在这个类中实现存储数据和include模板文件</li>
<li>用工厂模式和注册树模式来实例化对应的Model类</li>
</ol>


<h3>易于配置</h3>

<ol>
<li>定义Config类实现\ArrayAccess， 然后加载config目录下的所有文件。也是用注册树和工厂模式。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Composer自动加载的原理]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/17/composer-autoload/"/>
    <updated>2015-08-17T15:29:35+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/17/composer-autoload</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>当PHP引擎试图实例化未知类的操作时，就会调用<strong>autoload(),并将类名当做字符串传递给它。但</strong>autoload()有个缺点，就是 一个进程中只能定义一次。这是就可以使用spl_autoload_register()函数。它可以把函数注册到__autoload队列中. 现在我们来看看composer是如何实现自动加载的。</p>

<p>composer.json 文件</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='json'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nt">&quot;autoload&quot;</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nt">&quot;classmap&quot;</span> <span class="p">:</span> <span class="p">[</span>
</span><span class='line'>            <span class="s2">&quot;app/controllers&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="s2">&quot;app/models&quot;</span>
</span><span class='line'>        <span class="p">]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当我们composer dump-autoload的时候，文件/vendor/composer/autoload_clasmap.php会把类名和绝对地址做个想射。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="nv">$vendorDir</span> <span class="o">=</span> <span class="nb">dirname</span><span class="p">(</span><span class="nb">dirname</span><span class="p">(</span><span class="k">__FILE__</span><span class="p">));</span>
</span><span class='line'><span class="nv">$baseDir</span> <span class="o">=</span> <span class="nb">dirname</span><span class="p">(</span><span class="nv">$vendorDir</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="k">array</span><span class="p">(</span>
</span><span class='line'>    <span class="s1">&#39;Article&#39;</span> <span class="o">=&gt;</span> <span class="nv">$baseDir</span> <span class="o">.</span> <span class="s1">&#39;/app/models/Article.php&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;BaseController&#39;</span> <span class="o">=&gt;</span> <span class="nv">$baseDir</span> <span class="o">.</span> <span class="s1">&#39;/app/controllers/BaseController.php&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="s1">&#39;HomeController&#39;</span> <span class="o">=&gt;</span> <span class="nv">$baseDir</span> <span class="o">.</span> <span class="s1">&#39;/app/controllers/HomeController.php&#39;</span><span class="p">,</span>
</span><span class='line'><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>首页index.php调用composer的autoload文件</p>

<pre><code>require '../vendor/autoload.php';
</code></pre>

<p>会调用ComposerAutoloaderInit类的静态方法getLoader(）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="o">&lt;?</span><span class="nx">php</span>
</span><span class='line'><span class="k">require_once</span> <span class="nx">__DIR__</span> <span class="o">.</span> <span class="s1">&#39;/composer&#39;</span> <span class="o">.</span> <span class="s1">&#39;/autoload_real.php&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="nx">ComposerAutoloaderInita488c85ce5c077906f9c1829b6492f6b</span><span class="o">::</span><span class="na">getLoader</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>verdor/composer/目录下有四个配置文件：</p>

<ul>
<li>autoload_classmap.php：  要加载的class映射</li>
<li>autoload_files.php：     要加载的文件</li>
<li>autoload_namespaces.php：    psr-0标准</li>
<li>psr4.php：                   psr-4标准</li>
</ul>


<p>getLoader(）这个方法会先把这些配置文件放到ClassLoader的私有属性中。</p>

<p>然后通过$loader->register(true);来调用spl_autoload_register()</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">public</span> <span class="k">function</span> <span class="nf">register</span><span class="p">(</span><span class="nv">$prepend</span> <span class="o">=</span> <span class="k">false</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nb">spl_autoload_register</span><span class="p">(</span><span class="k">array</span><span class="p">(</span><span class="nv">$this</span><span class="p">,</span> <span class="s1">&#39;loadClass&#39;</span><span class="p">),</span> <span class="k">true</span><span class="p">,</span> <span class="nv">$prepend</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>spl_autoload_register()把loadClass()方法注册到了autoload队列中,然后当PHP引擎试图实例化未知类的操作时，就会根据类名和命名空间加载这个类文件。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">public</span> <span class="k">function</span> <span class="nf">loadClass</span><span class="p">(</span><span class="nv">$class</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nv">$file</span> <span class="o">=</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">findFile</span><span class="p">(</span><span class="nv">$class</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">includeFile</span><span class="p">(</span><span class="nv">$file</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Composer搭建自己的PHP框架]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/15/php-framework-hilda/"/>
    <updated>2015-08-15T08:45:27+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/15/php-framework-hilda</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>今天参照<a href="http://lvwenhan.com/php/410.html">教程</a>，使用Composer来搭建自己的框架。</p>

<p>我给它起了一个名字叫做Hilda PHP Framework.</p>

<p>通过构建这样的微型框架，有利于我们学习框架的自动加载、单入口文件、MVC的原理，因为需要什么，就加载什么。这样，自己的框架就像搭积木一样完成了，避免了重复发明轮子的烦恼。</p>

<h2>Hilda特性：</h2>

<ul>
<li>单入口文件</li>
<li>MVC架构</li>
<li>微型路由，基于<a href="https://packagist.org/packages/codingbean/macaw">codingbean/macaw</a></li>
<li>数据库的ORM 采用 <a href="http://laravel-china.org/docs/5.0/eloquent">Eloquent</a></li>
</ul>


<h1>安装方法</h1>

<p>它的Github地址为：<a href="https://github.com/FengHan/hilda">https://github.com/FengHan/hilda</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis数据结构类型2]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/14/redis-datastructure2/"/>
    <updated>2015-08-14T14:02:41+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/14/redis-datastructure2</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本文记录是极客学院 <a href="http://www.jikexueyuan.com/course/1693_1.html?ss=2">Redis系列课程</a>的文字记录</p>

<p><a href="http://redisdoc.com/">文档</a>
<a href="http://redisdesktop.com/download">Redis Desktop Manager</a></p>

<h1>集合类型与有序集合类型</h1>

<h3>集合类型概述</h3>

<p>Set， string类型的无序集合，不允许有重复元素。通过hash table实现，可以取并集、交集、差集，可以实现sns中好友推荐和blog的tag功能。</p>

<p>底层实现： 整数集合（都是整数值，数量不超过512），字典。</p>

<p>存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择。</p>

<p>集合还提供了判断某个成员是否在一个set集合内的接口。</p>

<p>sadd srem spop
- sadd key member 返回值，成功的数量
- srem key member 返回值，删除的的数量， 可删除多个
- spop key 随机弹出一个元素，返回弹出的元素</p>

<h2>获取</h2>

<ul>
<li>smembers key  查看元素</li>
<li>srandmember key count  count>0 返回不重复， count &lt; 0,可能重复</li>
<li>SISMEMBER key member  集合中是否存在key</li>
<li>SCARD member  统计集合个数</li>
</ul>


<p>运算命令
- SDIFF A B 差集， 所有属于A，不属于B; 1 2 3， 2 3 4 => 1
- SINTER A B  交集  所有属于A, 且属于B
- SUNION A B  并集
- SDIFFSTORE  不会返回结果，而是会存储在dest结果中</p>

<h2>Redis 有序集合类型概述</h2>

<p>Sorted Sort
底层实现：</p>

<ul>
<li>压缩列表（数量不超过128，且小于64字节）、</li>
<li>跳跃表（skiplist）</li>
</ul>


<p>需要有序的，不重复的，可以选择它。 可以构建优先级的队列。</p>

<p>有序集合类型与列表的比较，相同点：</p>

<ul>
<li>二者都是有序的。</li>
<li>二者都可以获得某一范围的元素。</li>
</ul>


<p>不同点：</p>

<ul>
<li>列表通过链表实现，获取靠近两端的数据速度快，适合“新鲜事”和“日志”。</li>
<li>有序集合使用散列表和跳跃表实现，读取中间数据速度也快。</li>
<li>列表不能简单的调整元素的位置，而有序集可以。</li>
<li>有序集合比列表类型更耗内存。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx错误信息汇总]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/14/nginx-error-msg/"/>
    <updated>2015-08-14T12:18:19+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/14/nginx-error-msg</id>
    <content type="html"><![CDATA[<h3>Nginx服务器返回403</h3>

<p>开了Astrill VPN, 关闭Astrill，即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用百度脑图来准备面试]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/14/interview-prepare/"/>
    <updated>2015-08-14T11:03:37+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/14/interview-prepare</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>要开始找工作了，用百度脑图来整理了一下项目经验和PHP相关知识
<a href="http://naotu.baidu.com/viewshare.html?shareId=axpmx5cuomos">点此</a></p>

<h3>关于MindMapper</h3>

<p>以前做脑图一直用MindMapper，我觉得它的优点：</p>

<ol>
<li>样子好看</li>
<li>快捷键好用，可以不用动鼠标，就完成脑图</li>
</ol>


<p>缺点：</p>

<ol>
<li>付费软件</li>
<li>没有中文版，第三方汉化包做得不好，中文写着写着顺序就乱了</li>
<li>不便于分享，以前写的很多脑图，现在都不知道放在那里了</li>
<li>生成的脑图，需要用专门的软件打开，为了一个脑图，要安装软件，费时</li>
</ol>


<h3>　百度脑图的优点：</h3>

<ol>
<li>开源，源代码放在了GitHub上</li>
<li>快捷键好用</li>
<li>便于分享</li>
<li>样子还不错</li>
<li>用浏览器随时可更改，便于维护
６. 百度 FEX 团队的 f-cube 小组（原 UEditor 小组）维护，靠谱</li>
<li>左下角有整个文件的预览，对内容较多的脑图很有帮助</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/13/sort/"/>
    <updated>2015-08-13T19:50:20+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/13/sort</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本文是记录北京大学在Coursera上的《高级数据结构与算法》的课程。</p>

<p><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/lecture/J5sEw/pai-xu-wen-ti-de-ji-ben-gai-nian">排序</a></p>

<h3>基本概念</h3>

<ul>
<li>序列 Sequence:线性表 :有记录组成</li>
<li>记录 Record： 结点，进行排序的基本单位</li>
<li>关键码Key： 唯一确定记录的一个或多个域</li>
<li>排序码 Sort Key： 作为排序运算依据的一个或多个域</li>
</ul>


<p>排序：</p>

<ul>
<li>将序列中的记录 Record 按照排序码顺序排列起来</li>
<li>排序码Sort Key域的值具有不减（或不增）的顺序</li>
</ul>


<p>内排序：</p>

<ul>
<li>整个排序过程在内存中完成</li>
</ul>


<p>&lt;=  不减序</p>

<blockquote><p>= 不增序</p></blockquote>

<p>正序</p>

<p>逆序</p>

<p>稳定性：</p>

<ul>
<li>存在多个具有相同排序码的记录</li>
<li>排序后这些记录的相对次序保持不变</li>
</ul>


<p>稳定性的证明： 形式证明</p>

<p>不稳定的证明： 反例说明</p>

<p>衡量标准：</p>

<ul>
<li>时间代价： 记录比较和移动的次数</li>
<li>空间代价</li>
<li>算法本身的复杂度</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Phpstorm]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/12/phpstorm/"/>
    <updated>2015-08-12T08:35:25+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/12/phpstorm</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本文是<a href="https://laracasts.com/series/how-to-be-awesome-in-phpstorm/episodes/2">Laracasts的phpstorm视频教程</a>的文字记录版</p>

<p>注意事项：本文所述快捷键和你的会不同，是我自定义的，我已将配置文件放到了<a href="https://github.com/FengHan/phpstorm">Github/PHPstorm</a></p>

<h3>Hello</h3>

<p>Google  phpstorm eap (easy access platform)</p>

<h3>Minimalism 精简IDE</h3>

<ul>
<li>Ctrl + 1 打开关闭侧边栏  : Way的习惯是尽可能的关闭</li>
<li>Navicat -> Class   打开类</li>
<li>Navicat -> Symbol 打开函数</li>
<li>View  -> Start Button 隐藏状态栏 ; Way 不需要它</li>
<li>View -> NavigationBar 隐藏导航；Way从来不用它</li>
<li><p>View ->  Toolbar  隐藏工具栏 ；Way都用快捷键</p></li>
<li><p>File-> Settings-> 搜索Breadcrumbs ，隐藏它，重启phpstorm</p></li>
<li><p>File-> Settings->Colors &amp; Fonts</p></li>
<li>Save AS : demo-theme，</li>
<li>size： 15  字体大小
line： spacing： 1.4 字间距</li>
<li><a href="http://daylerees.github.io/">http://daylerees.github.io/</a>查看主题</li>
<li><p><a href="https://github.com/daylerees/colour-schemes">https://github.com/daylerees/colour-schemes</a></p>

<p>  顺便介绍一下phpstorm主题安装方法：</p>

<p>  1、下载主题安装包：以icls结尾的文件，把安装包文件复制到config目录</p>

<p>  C:\Users\Administrator.WebIde90\config\colors
  wget <a href="https://raw.githubusercontent.com/daylerees/colour-schemes/master/jetbrains/earthsong.icls">https://raw.githubusercontent.com/daylerees/colour-schemes/master/jetbrains/earthsong.icls</a>
  注：这里以window系统为例。
  2、重启phpstorm</p>

<p>  3、File->Settings->Colors&amp;Fonts，选择相应的主题包，即可。</p></li>
<li><p>右键单击 文件名top， tap placement ，勾选none</p></li>
</ul>


<h3>Color IDE</h3>

<p>HELP -> FIND ACTION  搜索plugins -> configure plugins
Brower rpositersies 搜索Colors -> 选择color ide 安装</p>

<h3>Two Important Keybindings</h3>

<ul>
<li>两个重要的按键</li>
<li>一个是 Navicat -> file</li>
<li><p>另一个是  Navicat -> file structure</p></li>
<li><p>File -> settings -> keymap -> save as michaele&rsquo;s key</p></li>
<li><p>File -> settings -> keymap -> 点击搜索小图标 -> 输入键盘组合</p></li>
</ul>


<p>双击 -> remore ctrl + shift + o</p>

<p>我自定义的快捷键</p>

<ul>
<li><p>alt + p -> open file</p></li>
<li><p>alt + r -> file structure</p></li>
<li>alt + e ->  recent files</li>
<li>alt + o -> class</li>
<li><p>alt + t -> Refactor this</p></li>
<li><p>alt + shift + a -> enter action or option name</p></li>
<li>alt + shift + o -> sylbol</li>
<li>alt + n -> new file</li>
<li>ctrl + w 关闭页面</li>
<li><p>alt + , 设置</p></li>
<li><p>ctrl + w 关闭当前页面</p></li>
<li><p>ctrl + 1</p></li>
</ul>


<h3>Create New Files Quickly</h3>

<p>alt + 向上箭头  和 alt + n 快捷键在快速的创建文件</p>

<h3>Custom File Templates</h3>

<p>Ctrl + ，  file and code templates</p>

<h3>Live Templates</h3>

<p>double shift 然后， 输入 live template ，选择 save as 进行设置</p>

<p>textfield设置
    <!-- $VALUE$ Form Input -->
    <div class="form-group"></p>

<pre><code>&lt;/div&gt;
</code></pre>

<p>还要设置Edit attributes</p>

<h3>Custom Formatting</h3>

<ul>
<li><p>Alt + Shift + F 格式化代码</p></li>
<li><p>Code Style -> PHP -> Other -> Align key value styles</p></li>
<li><p>convert null to low case</p></li>
<li><p>convert true/false to low case</p></li>
</ul>


<h3>Refactoring: Name and Method</h3>

<p>Refactor this: Ctrl + Alt + Shift + R</p>

<h3>Refactoring: Pull Up</h3>

<p>用快捷键 将子类中的方法移动到父类中。
Alt + t -> Refactor this 然后输入 up</p>

<h3>Refactoring: Extract Interface</h3>

<h2>phpStorm的编码格式</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP设计模式]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/11/php-patterns/"/>
    <updated>2015-08-11T16:59:07+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/11/php-patterns</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<ul>
<li><p>本文是慕课网《大话PHP设计模式》的文字记录</p></li>
<li><p>视频内容：<a href="http://www.imooc.com/view/236">大话PHP设计模式</a></p></li>
<li><a href="https://github.com/FengHan/php_pattern/">GitHub代码</a></li>
</ul>


<h3>目标：</h3>

<ul>
<li>掌握PHP各类设计模式</li>
<li>具备设计纯面向对象框架和系统的能力</li>
</ul>


<h3>编辑器的选择</h3>

<p>PHP IDE 建议使用phpstorm, 因为适合PHP面向对象的开发</p>

<h3>选择编程字体</h3>

<p>因为1, l, i  o,O,0 不好区分</p>

<ol>
<li>必须选择等宽字体</li>
<li>常见的等宽编程字体包括Courier New, Consolas.</li>
<li>推荐使用 Source Code pro, 是有Adobe公司专门为程序员设计，免费开源。</li>
</ol>


<p>PHPstorm在File -> Settings -> Editor -> Colors &amp; Fonts -> Font 先Save As, 再更改</p>

<h3>命名空间与 autoload</h3>

<p>开发符合PSR-0规范的基础框架</p>

<ol>
<li>全部使用命名空间</li>
<li>所有PHP文件必须自动载入，不能有include/require</li>
<li>单一入口</li>
</ol>


<p>PSR-0规范被PSR-4规范代替（2014.10</p>

<ul>
<li><a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md">PSR-4 English</a></li>
<li><a href="http://segmentfault.com/a/1190000002521658">PSR-4 中文</a></li>
</ul>


<p>一个关于 文件路径 自动加载 的规范</p>

<ol>
<li><p>“命名空间前缀”，其必须与至少一个“文件基目录”相对应；</p></li>
<li><p>末尾的类名必须与对应的以 .php 为后缀的文件同名。</p></li>
</ol>


<p><a href="http://www.bubuko.com/infodetail-557809.html">一个遵循PSR-4的文件autoload的例子</a></p>

<h3>PHP面向对象的高级特性</h3>

<h4>SPL库的使用（php标准库） PHP5.5</h4>

<ol>
<li>SplStack, SplQueue, SplHeap, SplFixedArray</li>
</ol>


<h4>魔术方法</h4>

<ol>
<li><strong>get </strong>set</li>
<li><strong>call </strong>callStatic</li>
<li>__toString</li>
<li>__invoke  将一个对象当做函数使用</li>
</ol>


<h3>11种PHP设计模式</h3>

<ol>
<li>工厂模式： 工厂方法或类生成对象，而不是在代码中直接new</li>
<li>单例模式： 使某个类的对象仅允许创建一个</li>
<li>注册模式： 全局共享和交换对象</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">class</span> <span class="nc">Database</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">protected</span> <span class="k">static</span> <span class="nv">$db</span><span class="p">;</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">function</span> <span class="nf">__construct</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">getInstance</span><span class="p">()</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="k">empty</span><span class="p">(</span><span class="nx">self</span><span class="o">::</span><span class="nv">$db</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">self</span><span class="o">::</span><span class="nv">$db</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">self</span><span class="p">();</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">self</span><span class="o">::</span><span class="nv">$db</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>工厂模式的好处：
1. 工厂里被实例化的类，类名可修改，参数可调</p>

<p>单例模式说明：</p>

<ol>
<li>__construct 的可见性为 protectd 或 privated，防止被实例化</li>
<li>方法getInstance为静态方法（static），ps：静态方法内，只能调用静态属性。静态属性类似于函数的全部变量。</li>
<li>静态属性$db的可见性为private或protected.</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="k">class</span> <span class="nc">Register</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">protected</span> <span class="k">static</span> <span class="nv">$objests</span><span class="p">;</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">set</span><span class="p">(</span><span class="nv">$alias</span><span class="p">,</span> <span class="nv">$object</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="o">::</span><span class="nv">$objests</span><span class="p">[</span><span class="nv">$alias</span><span class="p">]</span> <span class="o">=</span> <span class="nv">$object</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">get</span><span class="p">(</span><span class="nv">$name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">self</span><span class="o">::</span><span class="nv">$objests</span><span class="p">[</span><span class="nv">$name</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">function</span> <span class="nf">_unset</span><span class="p">(</span><span class="nv">$alias</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="nb">unset</span><span class="p">(</span><span class="nx">self</span><span class="o">::</span><span class="nv">$objests</span><span class="p">[</span><span class="nv">$alias</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注册树模式说明：</p>

<ol>
<li>好处： 被注册的对象在任何地方想要调用，不需要再调用工厂模式或单例模式，直接从注册树上拿即可。例如：Register::get(&lsquo;db&rsquo;);</li>
</ol>


<h3>适配器模式</h3>

<ol>
<li>适配器模式，可以将截然不同的函数接口封装成统一的API</li>
<li>example： PHP的数据库操作有mysql，mysqli，pdo3种，可以用适配器模式统一成一致。类似的场景还有cache适配器，将memcache, redis, file, apc等不同的缓存函数，统一成一致。</li>
</ol>


<h3>策略模式</h3>

<p>将一组特定的行为和算法封装成类，以适应默写特定的上下文环境，这种模式就是策略模式。</p>

<p>实际应用举例，例如一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有广告位展示不同的广告。</p>

<p>使用策略模式可以实现Ioc，依赖倒置，控制反转</p>

<p>ps， 不同的支付接口也可以调用策略模式</p>

<h3>数据对象映射模式</h3>

<ol>
<li>数据对象映射模式，是将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作</li>
<li>在代码中实现数据对象映射模式，我们将实现一个ORM类，将复杂的SQL语句映射成对象属性的操作。</li>
<li>结合使用数据对象模式，工厂模式，注册模式</li>
</ol>


<h3>观察者模式</h3>

<ol>
<li>观察者模式(Observer),当一个对象状态发生改变时，依赖它的对象全部收到通知，并自动更新</li>
<li>一个事件发生后，要执行一连串的更新操作。传统的编程方式，就是在时间的代码之后直接加入处理逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要改变事件主体的代码</li>
<li>观察者模式实现了低耦合，非侵入式的通知和更新机制</li>
</ol>


<h3>原型模式</h3>

<ol>
<li>与工厂模式作用类似，都是用来创建对象</li>
<li>与工厂模式实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样就免去了类创建时重复的初始化操作。</li>
<li>原型模式适用于大对象的创建。创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需要内存拷贝即可。</li>
</ol>


<p>ps: 就是使用关键字clone对实例化好的类进行克隆。</p>

<h3>装饰器模式</h3>

<ol>
<li>注释七模式（Decorator），可以动态地添加修改类的功能</li>
<li>一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要一个子类来继承它，并重新实现类的方法</li>
<li>使用装饰器模式，仅需在运行时添加一个装饰器对象极客实现，可以实现最大的灵活性</li>
</ol>


<h3>迭代器模式 iterator</h3>

<ol>
<li>迭代器模式，在不需要了解内部实现的前提下，遍历一个聚合对象内部元素</li>
<li>相比传统的编程模式，迭代器可以隐藏遍历元素所需要的操作。</li>
</ol>


<h3>代理模式</h3>

<ol>
<li>在客户端与实体之间建立一个代理对象（proxy）,客户端对实体进行操作全部委派给代理对象，隐藏实体的具体实现细节。</li>
<li>Proxy 还可以与业务代码分离，部署到另外的服务器。业务代码中通过RPC来委派任务。</li>
<li>典型的应用实例就是读写分离。读去连接从库，写去连接主库。</li>
</ol>


<h3>面向对象鞭策的基本原则</h3>

<ol>
<li>单一原则： 一个类，只做好一件事情。不要用类完成复杂的问题，拆分小的类。</li>
<li>开放封闭：一个类，应该是可扩展的，而不可修改的。对扩展开放，对修改封闭。</li>
<li>依赖倒置： 一个类，不应该依赖另外一个类。每个类对于另外一个类是可以替换的。用依赖注入的方式，例如，A类调用B类，应将B类对象注入给A类。</li>
<li>配置化：尽可能地使用配置，而不是硬编码</li>
<li>面向接口编程：只需关心接口，不需要关心实现。</li>
</ol>


<h2>ＭＶＣ</h2>

<ol>
<li>模型（Model): 数据和存储的封装</li>
<li>视图(View): 展现层的封装，如Web系统中的模板文件</li>
<li>控制器（Controller）： 逻辑层的封装</li>
</ol>


<p>Apache/Nginx URL映射</p>

<p>将所有非静态文件的URL映射到PHP</p>

<h2>配置与设计模式</h2>

<ol>
<li>PHP使用ArrayAccess实现配置文件的加载</li>
<li>在工厂方法读取配置，生成可配置化的对象</li>
<li>使用装饰器模式实现权限验证，模板渲染，JSON串化</li>
<li>使用观察者模式实现数据更新事件的一系列更新操作</li>
<li>使用代理模式实现数据库主从自动切换</li>
</ol>


<h3>更多的设计模式</h3>

<p>在工程中思考并实践</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP各个版本的新特性]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/11/php_version/"/>
    <updated>2015-08-11T14:19:23+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/11/php_version</id>
    <content type="html"><![CDATA[<p>两年前，公司由PHP5.2 升级到了PHP5.3,此后在PHP5.3上开发了有一年的时间，此后不断的升级，现在记录一些我用到的特性。</p>

<h1>PHP5.3</h1>

<p> PHP5.3一方面在面向对象开发等方面有所加强, 另一方面也增加了不少实用的语法特性和新扩展。</p>

<ol>
<li>支持命名空间</li>
<li>新增两个魔术方法<strong>invoke 和</strong>callStatic</li>
<li>三元符增加了一个快捷方式来书写。</li>
<li>支持闭包</li>
</ol>


<p>命名空间的分隔符为反斜杠\</p>

<p>以函数形式来调用对象时，__invoke()方法将被自动调用。</p>

<p>当尝试调用类中不存在的静态方法时，__callStatic()魔术方法将被自动调用。</p>

<h1>PHP 5.4</h1>

<p>当升级到PHP5.4版本的时候，我们的开发环境有XP全部升级到了WIN7</p>

<ul>
<li>数组简写形式  [1,2,3]  [&lsquo;foo&rsquo; => &lsquo;banana&rsquo;, &lsquo;bar&rsquo; => &lsquo;apple&rsquo;]</li>
<li>内置Web服务器  php -S localhost:8000 -t public</li>
<li>&lt;?=（精简回显语法）现在始终可用，无论 short_tags ini 设置的值为何。</li>
<li><p>PHP 5.4版本将是最后一个支持Windows XP 和 Windows 2003的版本，今后将不再提供针对这些操作系统的二进制包。</p></li>
<li><p>返回数组的函数调用现在可以直接解除引用：</p>

<p>  function fruits() {<br/>
      return [&lsquo;apple&rsquo;, &lsquo;banana&rsquo;, &lsquo;orange&rsquo;];<br/>
  }</p>

<p>  echo fruits()[0]; // Outputs: apple</p></li>
</ul>


<h1>PHP 5.5</h1>

<p>Laravel 框架对PHP的版本要求是大于等于PHP5.5.9</p>

<ul>
<li>不推荐使用 mysql 函数，推荐使用 PDO 或 MySQL</li>
</ul>


<h1>PHP 5.6</h1>

<ul>
<li>命名空间支持常量和函数：</li>
</ul>


<h1>PHP 7</h1>

<p>2015年11月发布</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Homestead搭建本地Laravel开发环境]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/09/laravel-homestead/"/>
    <updated>2015-08-09T15:06:33+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/09/laravel-homestead</id>
    <content type="html"><![CDATA[<h3>环境说明</h3>

<ul>
<li>64bit Win7系统</li>
<li>Git Bash</li>
<li>Vagrant</li>
<li>Virtual Box</li>
</ul>


<h3>约定</h3>

<p>我们要创建一个项目blog，放在/d/sites/blog/目录下面</p>

<h3>安装</h3>

<p>创建项目目录</p>

<pre><code>cd /d/sites
mkdir blog
</code></pre>

<p>下载laravel的box和homestead</p>

<pre><code>vagrant box add laravel/homestead
git clone https://github.com/laravel/homestead.git Homestead
</code></pre>

<p>生成Homestead.yaml 到~/.homestead目录下</p>

<pre><code>cd /d/sites/blog/Homestead/
init.sh
</code></pre>

<p>生成秘钥</p>

<pre><code>ssh-keygen -t rsa -C "you@homestead"
</code></pre>

<p>配置文件 ~/.homestead/Homestead.yaml</p>

<pre><code>---
ip: "192.168.10.10"
memory: 2048
cpus: 1
provider: virtualbox

authorize: ~/.ssh/id_rsa.pub

keys:
    - ~/.ssh/id_rsa

folders:
    - map: d:\sites\blog
      to: /home/vagrant/blog

sites:
    - map: blog.app
      to: /home/vagrant/blog/public

databases:
    - homestead

variables:
    - key: APP_ENV
      value: local

# blackfire:
#     - id: foo
#       token: bar
#       client-id: foo
#       client-token: bar

# ports:
#     - send: 93000
#       to: 9300
#     - send: 7777
#       to: 777
#       protocol: udp
</code></pre>

<h3>Win下添加快捷键</h3>

<pre><code>cd ~
vi .bashrc
alias vm="ssh vagrant@127.0.0.1 -p 2222"

source .bashrc
</code></pre>

<h3>启动虚拟机</h3>

<pre><code>cd /d/sites/blog/Homestead/
vagrant up
</code></pre>

<h3>修改hosts文件</h3>

<h3>虚拟机的mysql</h3>

<pre><code>host: 127.0.0.1
port: 33060
user: homestead
pass: secret
</code></pre>

<h3>虚拟机里的端口转发</h3>

<pre><code>SSH: 2222 -&gt; Forwards To 22
HTTP: 8000 -&gt; Forwards To 80
MySQL: 33060 -&gt; Forwards To 3306
Postgres: 54320 -&gt; Forwards To 5432
</code></pre>

<h3>配置</h3>

<pre><code>php artisan key:generate
</code></pre>

<p>将生成的key复制到config/app.php替换82行的APP_KEY键值。</p>

<h3>参考链接</h3>

<p> <a href="http://www.golaravel.com/laravel/docs/5.1/homestead/">golaravel</a></p>

<p><a href="https://phphub.org/topics/2">phphub.org</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言学习中的难重点]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/29/c-difficult/"/>
    <updated>2015-07-29T23:18:44+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/29/c-difficult</id>
    <content type="html"><![CDATA[<ol>
<li>运算符: 自增、自减运算符</li>
<li>进制： 各种进制转换、原码、反码、补码</li>
<li>数组： 一维数组、二维数组、多维数组</li>
<li>循环： 多重循环的嵌套、排序、查找</li>
<li>函数：递归函数、递归调用</li>
<li>指针：一级指针、多级指针、指针和数组、函数、结构体之间的关系</li>
<li>内存管理： C语言内存管理问题、内存泄露、野指针</li>
<li>有参宏及条件编译</li>
<li>多文件开发： 多文件编译、多文件开发</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[腾讯云主机免费试用]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/27/qcloud/"/>
    <updated>2015-07-27T16:19:32+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/27/qcloud</id>
    <content type="html"><![CDATA[<p>今天免费申请了<a href="http://qcloud.com">腾讯云</a>主机的免费试用15天。
50元的代金券买了两台数据库，并使用了负载均衡。</p>

<p>记录主要操作如下：</p>

<p>修改 /etc/hostname 和 /etc/hosts</p>

<p>配置openssh-server</p>

<p>安装nginx php5-fpm php5-mysql php5-cli</p>

<p>域名A记录和CNAME指向</p>

<p>配置nginx虚拟主机</p>

<p>安装mariadb</p>

<p>安装redis</p>

<p>购买了两台mysql服务器</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 14.04远程登录服务器--ssh的安装和配置]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/27/ssh-server/"/>
    <updated>2015-07-27T15:22:47+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/27/ssh-server</id>
    <content type="html"><![CDATA[<pre><code>sudo apt-get update
sudo apt-get install openssh-server
sudo ps -e |grep ssh

#没有启动，输入
service ssh start
</code></pre>

<p>vi /etc/ssh/sshd_config</p>

<p>把配置文件中的"PermitRootLogin without-password"加一个"#&ldquo;号,把它注释掉&ndash;>再增加一句"PermitRootLogin yes&rdquo;&ndash;>保存，修改成功。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP开发工程师]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/26/learn-php/"/>
    <updated>2015-07-26T22:22:29+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/26/learn-php</id>
    <content type="html"><![CDATA[<p>成为一名PHP开发者要学习哪些内容？</p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/what_shoud_learn_for_phper.jpg" alt="" /></p>

<p>活到老，学到老，作为开发者，要不断地学习，那应该怎样学习呢？</p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/how_to_learn_php.jpg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Composer]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/26/composer/"/>
    <updated>2015-07-26T19:45:50+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/26/composer</id>
    <content type="html"><![CDATA[<p><a href="http://www.phpcomposer.com/composer-the-new-age-of-dependency-manager-for-php/">参考链接</a></p>

<p>全局安装：</p>

<pre><code>$ curl -sS https://getcomposer.org/installer | php
$ mv composer.phar /usr/local/bin/composer
</code></pre>

<p>Composer 中国镜像</p>

<p>采用</p>

<p> <a href="http://pkg.phpcomposer.com/">composer 的全局配置文件</a></p>
]]></content>
  </entry>
  
</feed>
