<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[hanfeng.name]]></title>
  <link href="http://fenghan.github.io/atom.xml" rel="self"/>
  <link href="http://fenghan.github.io/"/>
  <updated>2015-08-15T09:31:02+08:00</updated>
  <id>http://fenghan.github.io/</id>
  <author>
    <name><![CDATA[HanFeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Composer搭建自己的PHP框架]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/15/php-framework-hilda/"/>
    <updated>2015-08-15T08:45:27+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/15/php-framework-hilda</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>今天参照<a href="http://lvwenhan.com/php/410.html">教程</a>，使用Composer来搭建自己的框架。</p>

<p>我给它起了一个名字叫做Hilda PHP Framework.</p>

<p>通过构建这样的微型框架，有利于我们学习框架的自动加载、单入口文件、MVC的原理，因为需要什么，就加载什么。这样，自己的框架就像搭积木一样完成了，避免了重复发明轮子的烦恼。</p>

<h2>Hilda特性：</h2>

<ul>
<li>单入口文件</li>
<li>MVC架构</li>
<li>微型路由，基于<a href="https://packagist.org/packages/codingbean/macaw">codingbean/macaw</a></li>
<li>数据库的ORM 采用 <a href="http://laravel-china.org/docs/5.0/eloquent">Eloquent</a></li>
</ul>


<h1>安装方法</h1>

<p>它的Github地址为：<a href="https://github.com/FengHan/hilda">https://github.com/FengHan/hilda</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis数据结构类型2]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/14/redis-datastructure2/"/>
    <updated>2015-08-14T14:02:41+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/14/redis-datastructure2</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本文记录是极客学院 <a href="http://www.jikexueyuan.com/course/1693_1.html?ss=2">Redis系列课程</a>的文字记录</p>

<p><a href="http://redisdoc.com/">文档</a>
<a href="http://redisdesktop.com/download">Redis Desktop Manager</a></p>

<h1>集合类型与有序集合类型</h1>

<h3>集合类型概述</h3>

<p>Set， string类型的无序集合，不允许有重复元素。通过hash table实现，可以取并集、交集、差集，可以实现sns中好友推荐和blog的tag功能。</p>

<p>底层实现： 整数集合（都是整数值，数量不超过512），字典。</p>

<p>存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择。</p>

<p>集合还提供了判断某个成员是否在一个set集合内的接口。</p>

<p>sadd srem spop
- sadd key member 返回值，成功的数量
- srem key member 返回值，删除的的数量， 可删除多个
- spop key 随机弹出一个元素，返回弹出的元素</p>

<h2>获取</h2>

<ul>
<li>smembers key  查看元素</li>
<li>srandmember key count  count>0 返回不重复， count &lt; 0,可能重复</li>
<li>SISMEMBER key member  集合中是否存在key</li>
<li>SCARD member  统计集合个数</li>
</ul>


<p>运算命令
- SDIFF A B 差集， 所有属于A，不属于B; 1 2 3， 2 3 4 => 1
- SINTER A B  交集  所有属于A, 且属于B
- SUNION A B  并集
- SDIFFSTORE  不会返回结果，而是会存储在dest结果中</p>

<h2>Redis 有序集合类型概述</h2>

<p>Sorted Sort
底层实现：</p>

<ul>
<li>压缩列表（数量不超过128，且小于64字节）、</li>
<li>跳跃表（skiplist）</li>
</ul>


<p>需要有序的，不重复的，可以选择它。 可以构建优先级的队列。</p>

<p>有序集合类型与列表的比较，相同点：</p>

<ul>
<li>二者都是有序的。</li>
<li>二者都可以获得某一范围的元素。</li>
</ul>


<p>不同点：</p>

<ul>
<li>列表通过链表实现，获取靠近两端的数据速度快，适合“新鲜事”和“日志”。</li>
<li>有序集合使用散列表和跳跃表实现，读取中间数据速度也快。</li>
<li>列表不能简单的调整元素的位置，而有序集可以。</li>
<li>有序集合比列表类型更耗内存。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nginx错误信息汇总]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/14/nginx-error-msg/"/>
    <updated>2015-08-14T12:18:19+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/14/nginx-error-msg</id>
    <content type="html"><![CDATA[<h3>Nginx服务器返回403</h3>

<p>开了Astrill VPN, 关闭Astrill，即可</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用百度脑图来准备面试]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/14/interview-prepare/"/>
    <updated>2015-08-14T11:03:37+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/14/interview-prepare</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>要开始找工作了，用百度脑图来整理了一下项目经验和PHP相关知识
<a href="http://naotu.baidu.com/viewshare.html?shareId=axpmx5cuomos">点此</a></p>

<h3>关于MindMapper</h3>

<p>以前做脑图一直用MindMapper，我觉得它的优点：</p>

<ol>
<li>样子好看</li>
<li>快捷键好用，可以不用动鼠标，就完成脑图</li>
</ol>


<p>缺点：</p>

<ol>
<li>付费软件</li>
<li>没有中文版，第三方汉化包做得不好，中文写着写着顺序就乱了</li>
<li>不便于分享，以前写的很多脑图，现在都不知道放在那里了</li>
<li>生成的脑图，需要用专门的软件打开，为了一个脑图，要安装软件，费时</li>
</ol>


<h3>　百度脑图的优点：</h3>

<ol>
<li>开源，源代码放在了GitHub上</li>
<li>快捷键好用</li>
<li>便于分享</li>
<li>样子还不错</li>
<li>用浏览器随时可更改，便于维护
６. 百度 FEX 团队的 f-cube 小组（原 UEditor 小组）维护，靠谱</li>
<li>左下角有整个文件的预览，对内容较多的脑图很有帮助</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/13/sort/"/>
    <updated>2015-08-13T19:50:20+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/13/sort</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本文是记录北京大学在Coursera上的《高级数据结构与算法》的课程。</p>

<p><a href="https://www.coursera.org/learn/gaoji-shuju-jiegou/lecture/J5sEw/pai-xu-wen-ti-de-ji-ben-gai-nian">排序</a></p>

<h3>基本概念</h3>

<ul>
<li>序列 Sequence:线性表 :有记录组成</li>
<li>记录 Record： 结点，进行排序的基本单位</li>
<li>关键码Key： 唯一确定记录的一个或多个域</li>
<li>排序码 Sort Key： 作为排序运算依据的一个或多个域</li>
</ul>


<p>排序：</p>

<ul>
<li>将序列中的记录 Record 按照排序码顺序排列起来</li>
<li>排序码Sort Key域的值具有不减（或不增）的顺序</li>
</ul>


<p>内排序：</p>

<ul>
<li>整个排序过程在内存中完成</li>
</ul>


<p>&lt;=  不减序</p>

<blockquote><p>= 不增序</p></blockquote>

<p>正序</p>

<p>逆序</p>

<p>稳定性：</p>

<ul>
<li>存在多个具有相同排序码的记录</li>
<li>排序后这些记录的相对次序保持不变</li>
</ul>


<p>稳定性的证明： 形式证明</p>

<p>不稳定的证明： 反例说明</p>

<p>衡量标准：</p>

<ul>
<li>时间代价： 记录比较和移动的次数</li>
<li>空间代价</li>
<li>算法本身的复杂度</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Phpstorm]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/12/phpstorm/"/>
    <updated>2015-08-12T08:35:25+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/12/phpstorm</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本文是<a href="https://laracasts.com/series/how-to-be-awesome-in-phpstorm/episodes/2">Laracasts的phpstorm视频教程</a>的文字记录版</p>

<p>注意事项：本文所述快捷键和你的会不同，是我自定义的，我已将配置文件放到了<a href="https://github.com/FengHan/phpstorm">Github/PHPstorm</a></p>

<h3>Hello</h3>

<p>Google  phpstorm eap (easy access platform)</p>

<h3>Minimalism 精简IDE</h3>

<ul>
<li>Ctrl + 1 打开关闭侧边栏  : Way的习惯是尽可能的关闭</li>
<li>Navicat -> Class   打开类</li>
<li>Navicat -> Symbol 打开函数</li>
<li>View  -> Start Button 隐藏状态栏 ; Way 不需要它</li>
<li>View -> NavigationBar 隐藏导航；Way从来不用它</li>
<li><p>View ->  Toolbar  隐藏工具栏 ；Way都用快捷键</p></li>
<li><p>File-> Settings-> 搜索Breadcrumbs ，隐藏它，重启phpstorm</p></li>
<li><p>File-> Settings->Colors &amp; Fonts</p></li>
<li>Save AS : demo-theme，</li>
<li>size： 15  字体大小
line： spacing： 1.4 字间距</li>
<li><a href="http://daylerees.github.io/">http://daylerees.github.io/</a>查看主题</li>
<li><p><a href="https://github.com/daylerees/colour-schemes">https://github.com/daylerees/colour-schemes</a></p>

<p>  顺便介绍一下phpstorm主题安装方法：</p>

<p>  1、下载主题安装包：以icls结尾的文件，把安装包文件复制到config目录</p>

<p>  C:\Users\Administrator.WebIde90\config\colors
  wget <a href="https://raw.githubusercontent.com/daylerees/colour-schemes/master/jetbrains/earthsong.icls">https://raw.githubusercontent.com/daylerees/colour-schemes/master/jetbrains/earthsong.icls</a>
  注：这里以window系统为例。
  2、重启phpstorm</p>

<p>  3、File->Settings->Colors&amp;Fonts，选择相应的主题包，即可。</p></li>
<li><p>右键单击 文件名top， tap placement ，勾选none</p></li>
</ul>


<h3>Color IDE</h3>

<p>HELP -> FIND ACTION  搜索plugins -> configure plugins
Brower rpositersies 搜索Colors -> 选择color ide 安装</p>

<h3>Two Important Keybindings</h3>

<ul>
<li>两个重要的按键</li>
<li>一个是 Navicat -> file</li>
<li><p>另一个是  Navicat -> file structure</p></li>
<li><p>File -> settings -> keymap -> save as michaele&rsquo;s key</p></li>
<li><p>File -> settings -> keymap -> 点击搜索小图标 -> 输入键盘组合</p></li>
</ul>


<p>双击 -> remore ctrl + shift + o</p>

<p>我自定义的快捷键</p>

<ul>
<li><p>alt + p -> open file</p></li>
<li><p>alt + r -> file structure</p></li>
<li>alt + e ->  recent files</li>
<li>alt + o -> class</li>
<li><p>alt + t -> Refactor this</p></li>
<li><p>alt + shift + a -> enter action or option name</p></li>
<li>alt + shift + o -> sylbol</li>
<li>alt + n -> new file</li>
<li>ctrl + w 关闭页面</li>
<li><p>alt + , 设置</p></li>
<li><p>ctrl + w 关闭当前页面</p></li>
<li><p>ctrl + 1</p></li>
</ul>


<h3>Create New Files Quickly</h3>

<p>alt + 向上箭头  和 alt + n 快捷键在快速的创建文件</p>

<h3>Custom File Templates</h3>

<p>Ctrl + ，  file and code templates</p>

<h3>Live Templates</h3>

<p>double shift 然后， 输入 live template ，选择 save as 进行设置</p>

<p>textfield设置
    <!-- $VALUE$ Form Input -->
    <div class="form-group"></p>

<pre><code>&lt;/div&gt;
</code></pre>

<p>还要设置Edit attributes</p>

<h3>Custom Formatting</h3>

<ul>
<li><p>Alt + Shift + F 格式化代码</p></li>
<li><p>Code Style -> PHP -> Other -> Align key value styles</p></li>
<li><p>convert null to low case</p></li>
<li><p>convert true/false to low case</p></li>
</ul>


<h3>Refactoring: Name and Method</h3>

<p>Refactor this: Ctrl + Alt + Shift + R</p>

<h3>Refactoring: Pull Up</h3>

<p>用快捷键 将子类中的方法移动到父类中。
Alt + t -> Refactor this 然后输入 up</p>

<h3>Refactoring: Extract Interface</h3>

<h2>phpStorm的编码格式</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP设计模式]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/11/php-patterns/"/>
    <updated>2015-08-11T16:59:07+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/11/php-patterns</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<ul>
<li><p>本文是慕课网《大话PHP设计模式》的文字记录</p></li>
<li><p>视频内容：<a href="http://www.imooc.com/view/236">大话PHP设计模式</a></p></li>
<li><a href="https://github.com/FengHan/php_pattern/">GitHub代码</a></li>
</ul>


<h3>目标：</h3>

<ul>
<li>掌握PHP各类设计模式</li>
<li>具备设计纯面向对象框架和系统的能力</li>
</ul>


<h3>编辑器的选择</h3>

<p>PHP IDE 建议使用phpstorm, 因为适合PHP面向对象的开发</p>

<h3>选择编程字体</h3>

<p>因为1, l, i  o,O,0 不好区分</p>

<ol>
<li>必须选择等宽字体</li>
<li>常见的等宽编程字体包括Courier New, Consolas.</li>
<li>推荐使用 Source Code pro, 是有Adobe公司专门为程序员设计，免费开源。</li>
</ol>


<p>PHPstorm在File -> Settings -> Editor -> Colors &amp; Fonts -> Font 先Save As, 再更改</p>

<h3>命名空间与 autoload</h3>

<p>开发符合PSR-0规范的基础框架</p>

<ol>
<li>全部使用命名空间</li>
<li>所有PHP文件必须自动载入，不能有include/require</li>
<li>单一入口</li>
</ol>


<p>PSR-0规范被PSR-4规范代替（2014.10</p>

<ul>
<li><a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md">PSR-4 English</a></li>
<li><a href="http://segmentfault.com/a/1190000002521658">PSR-4 中文</a></li>
</ul>


<p>一个关于 文件路径 自动加载 的规范</p>

<ol>
<li><p>“命名空间前缀”，其必须与至少一个“文件基目录”相对应；</p></li>
<li><p>末尾的类名必须与对应的以 .php 为后缀的文件同名。</p></li>
</ol>


<p><a href="http://www.bubuko.com/infodetail-557809.html">一个遵循PSR-4的文件autoload的例子</a></p>

<h3>PHP面向对象的高级特性</h3>

<h4>SPL库的使用（php标准库） PHP5.5</h4>

<ol>
<li>SplStack, SplQueue, SplHeap, SplFixedArray</li>
</ol>


<h4>魔术方法</h4>

<ol>
<li><strong>get </strong>set</li>
<li><strong>call </strong>callStatic</li>
<li>__toString</li>
<li>__invoke  将一个对象当做函数使用</li>
</ol>


<h3>11种PHP设计模式</h3>

<ol>
<li>工厂模式： 工厂方法或类生成对象，而不是在代码中直接new</li>
<li>单例模式： 使某个类的对象仅允许创建一个</li>
<li>注册模式： 全局共享和交换对象</li>
</ol>


<p>工厂模式的好处：
1. 工厂里被实例化的类，类名可修改，参数可调</p>

<h3>适配器模式</h3>

<ol>
<li>适配器模式，可以将截然不同的函数接口封装成统一的API</li>
<li>example： PHP的数据库操作有mysql，mysqli，pdo3种，可以用适配器模式统一成一致。类似的场景还有cache适配器，将memcache, redis, file, apc等不同的缓存函数，统一成一致。</li>
</ol>


<h3>策略模式</h3>

<p>将一组特定的行为和算法封装成类，以适应默写特定的上下文环境，这种模式就是策略模式。</p>

<p>实际应用举例，例如一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有广告位展示不同的广告。</p>

<p>使用策略模式可以实现Ioc，依赖倒置，控制反转</p>

<p>ps， 不同的支付接口也可以调用策略模式</p>

<h3>数据对象映射模式</h3>

<ol>
<li>数据对象映射模式，是将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作</li>
<li>在代码中实现数据对象映射模式，我们将实现一个ORM类，将复杂的SQL语句映射成对象属性的操作。</li>
<li>结合使用数据对象模式，工厂模式，注册模式</li>
</ol>


<h3>观察者模式</h3>

<ol>
<li>观察者模式(Observer),当一个对象状态发生改变时，依赖它的对象全部收到通知，并自动更新</li>
<li>一个事件发生后，要执行一连串的更新操作。传统的编程方式，就是在时间的代码之后直接加入处理逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要改变事件主体的代码</li>
<li>观察者模式实现了低耦合，非侵入式的通知和更新机制</li>
</ol>


<h3>原型模式</h3>

<ol>
<li>与工厂模式作用类似，都是用来创建对象</li>
<li>与工厂模式实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样就免去了类创建时重复的初始化操作。</li>
<li>原型模式适用于大对象的创建。创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需要内存拷贝即可。</li>
</ol>


<p>ps: 就是使用关键字clone对实例化好的类进行克隆。</p>

<h3>装饰器模式</h3>

<ol>
<li>注释七模式（Decorator），可以动态地添加修改类的功能</li>
<li>一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要一个子类来继承它，并重新实现类的方法</li>
<li>使用装饰器模式，仅需在运行时添加一个装饰器对象极客实现，可以实现最大的灵活性

<h3>PSR, Composer, Phar</h3></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP各个版本的新特性]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/11/php_version/"/>
    <updated>2015-08-11T14:19:23+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/11/php_version</id>
    <content type="html"><![CDATA[<p>两年前，公司由PHP5.2 升级到了PHP5.3,此后在PHP5.3上开发了有一年的时间，此后不断的升级，现在记录一些我用到的特性。</p>

<h1>PHP5.3</h1>

<p> PHP5.3一方面在面向对象开发等方面有所加强, 另一方面也增加了不少实用的语法特性和新扩展。</p>

<ol>
<li>支持命名空间</li>
<li>新增两个魔术方法<strong>invoke 和</strong>callStatic</li>
<li>三元符增加了一个快捷方式来书写。</li>
<li>支持闭包</li>
</ol>


<p>命名空间的分隔符为反斜杠\</p>

<p>以函数形式来调用对象时，__invoke()方法将被自动调用。</p>

<p>当尝试调用类中不存在的静态方法时，__callStatic()魔术方法将被自动调用。</p>

<h1>PHP 5.4</h1>

<p>当升级到PHP5.4版本的时候，我们的开发环境有XP全部升级到了WIN7</p>

<ul>
<li>数组简写形式  [1,2,3]  [&lsquo;foo&rsquo; => &lsquo;banana&rsquo;, &lsquo;bar&rsquo; => &lsquo;apple&rsquo;]</li>
<li>内置Web服务器  php -S localhost:8000 -t public</li>
<li>&lt;?=（精简回显语法）现在始终可用，无论 short_tags ini 设置的值为何。</li>
<li><p>PHP 5.4版本将是最后一个支持Windows XP 和 Windows 2003的版本，今后将不再提供针对这些操作系统的二进制包。</p></li>
<li><p>返回数组的函数调用现在可以直接解除引用：</p>

<p>  function fruits() {<br/>
      return [&lsquo;apple&rsquo;, &lsquo;banana&rsquo;, &lsquo;orange&rsquo;];<br/>
  }</p>

<p>  echo fruits()[0]; // Outputs: apple</p></li>
</ul>


<h1>PHP 5.5</h1>

<p>Laravel 框架对PHP的版本要求是大于等于PHP5.5.9</p>

<ul>
<li>不推荐使用 mysql 函数，推荐使用 PDO 或 MySQL</li>
</ul>


<h1>PHP 5.6</h1>

<ul>
<li>命名空间支持常量和函数：</li>
</ul>


<h1>PHP 7</h1>

<p>2015年11月发布</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Homestead搭建本地Laravel开发环境]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/09/laravel-homestead/"/>
    <updated>2015-08-09T15:06:33+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/09/laravel-homestead</id>
    <content type="html"><![CDATA[<h3>环境说明</h3>

<ul>
<li>64bit Win7系统</li>
<li>Git Bash</li>
<li>Vagrant</li>
<li>Virtual Box</li>
</ul>


<h3>约定</h3>

<p>我们要创建一个项目blog，放在/d/sites/blog/目录下面</p>

<h3>安装</h3>

<p>创建项目目录</p>

<pre><code>cd /d/sites
mkdir blog
</code></pre>

<p>下载laravel的box和homestead</p>

<pre><code>vagrant box add laravel/homestead
git clone https://github.com/laravel/homestead.git Homestead
</code></pre>

<p>生成Homestead.yaml 到~/.homestead目录下</p>

<pre><code>cd /d/sites/blog/Homestead/
init.sh
</code></pre>

<p>生成秘钥</p>

<pre><code>ssh-keygen -t rsa -C "you@homestead"
</code></pre>

<p>配置文件 ~/.homestead/Homestead.yaml</p>

<pre><code>---
ip: "192.168.10.10"
memory: 2048
cpus: 1
provider: virtualbox

authorize: ~/.ssh/id_rsa.pub

keys:
    - ~/.ssh/id_rsa

folders:
    - map: d:\sites\blog
      to: /home/vagrant/blog

sites:
    - map: blog.app
      to: /home/vagrant/blog/public

databases:
    - homestead

variables:
    - key: APP_ENV
      value: local

# blackfire:
#     - id: foo
#       token: bar
#       client-id: foo
#       client-token: bar

# ports:
#     - send: 93000
#       to: 9300
#     - send: 7777
#       to: 777
#       protocol: udp
</code></pre>

<h3>Win下添加快捷键</h3>

<pre><code>cd ~
vi .bashrc
alias vm="ssh vagrant@127.0.0.1 -p 2222"

source .bashrc
</code></pre>

<h3>启动虚拟机</h3>

<pre><code>cd /d/sites/blog/Homestead/
vagrant up
</code></pre>

<h3>修改hosts文件</h3>

<h3>虚拟机的mysql</h3>

<pre><code>host: 127.0.0.1
port: 33060
user: homestead
pass: secret
</code></pre>

<h3>虚拟机里的端口转发</h3>

<pre><code>SSH: 2222 -&gt; Forwards To 22
HTTP: 8000 -&gt; Forwards To 80
MySQL: 33060 -&gt; Forwards To 3306
Postgres: 54320 -&gt; Forwards To 5432
</code></pre>

<h3>配置</h3>

<pre><code>php artisan key:generate
</code></pre>

<p>将生成的key复制到config/app.php替换82行的APP_KEY键值。</p>

<h3>参考链接</h3>

<p> <a href="http://www.golaravel.com/laravel/docs/5.1/homestead/">golaravel</a></p>

<p><a href="https://phphub.org/topics/2">phphub.org</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言学习中的难重点]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/29/c-difficult/"/>
    <updated>2015-07-29T23:18:44+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/29/c-difficult</id>
    <content type="html"><![CDATA[<ol>
<li>运算符: 自增、自减运算符</li>
<li>进制： 各种进制转换、原码、反码、补码</li>
<li>数组： 一维数组、二维数组、多维数组</li>
<li>循环： 多重循环的嵌套、排序、查找</li>
<li>函数：递归函数、递归调用</li>
<li>指针：一级指针、多级指针、指针和数组、函数、结构体之间的关系</li>
<li>内存管理： C语言内存管理问题、内存泄露、野指针</li>
<li>有参宏及条件编译</li>
<li>多文件开发： 多文件编译、多文件开发</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[腾讯云主机免费试用]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/27/qcloud/"/>
    <updated>2015-07-27T16:19:32+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/27/qcloud</id>
    <content type="html"><![CDATA[<p>今天免费申请了<a href="http://qcloud.com">腾讯云</a>主机的免费试用15天。
50元的代金券买了两台数据库，并使用了负载均衡。</p>

<p>记录主要操作如下：</p>

<p>修改 /etc/hostname 和 /etc/hosts</p>

<p>配置openssh-server</p>

<p>安装nginx php5-fpm php5-mysql php5-cli</p>

<p>域名A记录和CNAME指向</p>

<p>配置nginx虚拟主机</p>

<p>安装mariadb</p>

<p>安装redis</p>

<p>购买了两台mysql服务器</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ubuntu 14.04远程登录服务器--ssh的安装和配置]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/27/ssh-server/"/>
    <updated>2015-07-27T15:22:47+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/27/ssh-server</id>
    <content type="html"><![CDATA[<pre><code>sudo apt-get update
sudo apt-get install openssh-server
sudo ps -e |grep ssh

#没有启动，输入
service ssh start
</code></pre>

<p>vi /etc/ssh/sshd_config</p>

<p>把配置文件中的"PermitRootLogin without-password"加一个"#&ldquo;号,把它注释掉&ndash;>再增加一句"PermitRootLogin yes&rdquo;&ndash;>保存，修改成功。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP开发工程师]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/26/learn-php/"/>
    <updated>2015-07-26T22:22:29+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/26/learn-php</id>
    <content type="html"><![CDATA[<p>成为一名PHP开发者要学习哪些内容？</p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/what_shoud_learn_for_phper.jpg" alt="" /></p>

<p>活到老，学到老，作为开发者，要不断地学习，那应该怎样学习呢？</p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/how_to_learn_php.jpg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Composer]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/26/composer/"/>
    <updated>2015-07-26T19:45:50+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/26/composer</id>
    <content type="html"><![CDATA[<p><a href="http://www.phpcomposer.com/composer-the-new-age-of-dependency-manager-for-php/">参考链接</a></p>

<p>全局安装：</p>

<pre><code>$ curl -sS https://getcomposer.org/installer | php
$ mv composer.phar /usr/local/bin/composer
</code></pre>

<p>Composer 中国镜像</p>

<p>采用</p>

<p> <a href="http://pkg.phpcomposer.com/">composer 的全局配置文件</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yii 2.0框架]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/26/yii/"/>
    <updated>2015-07-26T19:22:48+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/26/yii</id>
    <content type="html"><![CDATA[<h3>框架介绍</h3>

<p>高性能、基于组件</p>

<ol>
<li>实现了MVC模式</li>
<li>代码简洁优雅</li>
<li>全栈框架，对关系型和NoSQL数据库都提供了查询生成器和ActiveRecord；多层缓存支持。</li>
<li>高性能始终是Yii的首要目标之一。</li>
</ol>


<p>目前主要有1.1 和2.0 两个版本。</p>

<p>2.0是一个完全重写的版本，采用了最新的技术和协议，包括依赖包管理器Composer， PHP代码规范PSR、命名空间、Traits（特质）等等。2.0 代表新一代框架。</p>

<p>Yii2.0需要<strong>PHP5.4.0</strong>以上的版本。</p>

<h3>框架部署</h3>

<ol>
<li>通过Composer安装，升级简单
<a href="http://www.yiiframework.com/download/">安装说明</a></li>
</ol>


<h3>Yii 2.0 表单怎么用？</h3>

<ol>
<li>创建模型</li>
<li>按规则自动验证</li>
<li>视图通过小部件（widgets）自动生成HTML</li>
</ol>


<p>可能出现的问题</p>

<ol>
<li>命名空间要写对</li>
<li>记的引用（use）所需要的小部件或是类</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis的数据类型(一)]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/24/redis-data-type/"/>
    <updated>2015-07-24T14:54:30+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/24/redis-data-type</id>
    <content type="html"><![CDATA[<h4>Redis 的数据库内部结构</h4>

<pre><code>Redis中每个数据库，都是由一个redis.h/redisDb结构表示：
    typedef struct redisDb{
    int id: //保存着数据库以整数表示的号码
    dict *dict；   //保存着所有键值对数据，这个属性也被称为键空间（key space）
    dict *expires; //保存着键的过期信息
    dict *blocking_keys;    //实现列表阻塞原语，
    dict *watched_keys;     //用于实现WATCH命令
}redisDb
</code></pre>

<p>因为Redis是一个键值对数据库（key-value-pairs database）,所以它的数据库本身也是一个字典（俗称 key space）
- 字典的的键是一个<strong>字符串</strong>对象
- 字典的值可以是包括<strong>字符串、列表、哈希值、集合或有序集</strong>在内的任意一种Redis类型对象。</p>

<p>在 redisDb  结构的 dict  属性中，保存着数据库的所有键值对数据。
下图展示了一个包含 number 、book 、message 三个键的数据库—其中 number
 键是一个列表，列表中包含三个整数值；book  键是一个哈希表，表中包含三个键
值对；而 message  键则指向另一个字符串。</p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/redis_hash.jpg" alt="" /></p>

<ul>
<li>命令

<ul>
<li>Redis中的命令不区分大小写，SET与set效果一样。</li>
</ul>
</li>
<li>主键（key）

<ul>
<li>可以用任何二进制序列作为key值，从形如“foo”的简单字符串到一个JPEG文件的内容都可以。空字符串也是有效的key值。</li>
</ul>
</li>
<li>关于key的规则

<ul>
<li>可以用任何二进制序列作为key值</li>
<li>格式约定： object-type:id:field</li>
<li>不用太长的键值。不仅消耗内存，而且在数据查找中计算成本很高。</li>
<li>太短的键值通常也不是好主意，可读性差。

<ul>
<li>如用“user:1000:password”来代替“u:1000:pwd”</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>Redis 的 String 类型的底层实现与操作命令</h4>

<p>String是Redis最基本的类型，而且String类型是二进制安全的。意思是Redis的String可以包含任何数据。比如jpg图片或者序列化对象。从内部实现来看其实String可以看做byte数组，最大上限是1G字节。下面是String类型的定义。</p>

<pre><code>struct sdshdr{
    long len;   //len是buf数组的长度
    long free;  //free是数组中剩余可用字节数
    char buf[]; //char数组用于贮存实际的字符串内容
}String;
</code></pre>

<p>新增相关命令</p>

<pre><code>Set
语法：set key value
解释：把值value赋给key，如果key不存在，新增；否则，更新。
Setnx
语法：setnx  key  value
解释：只 insert 不 update，即，仅仅key不存在时，则设置key的值为value，并返回1，否则返回0  。setnx 是set if not exists 的缩写。
Setex
语法： setex key secondes value
解释： 设置KEY的过期时间和值。过期时间seconds单位是秒。设置过期时间和值是原子操作，如果redis仅仅当做缓存，这个命令很有用。
msetnx
语法：msetnx key value  [key value ...]
解释：所有key都不存在才执行set操作。
</code></pre>

<p>查询相关命令</p>

<pre><code>get
语法：get key
解释：获取key所set的值。
mget
语法： mget key [key]
解释：批量获取key的值。程序一次获取多个值，可以减少网络连接损耗。
getrange
语法：getrange  key star end
解释：获取存储在key中value的字串。字符串的截取有star和end决定，字符串的第一个字符编号是0，第二个是1，一次类推；如果是负数，-1是最后一个字符，-2是倒数第二个字符，一次类推。
</code></pre>

<p>修改相关命令</p>

<pre><code>getset
语法：getset key value
解释：设置key的值，并返回key的旧值。
append
语法：append key value
解释：key存在，在旧值的后面追加value；key不存在，直接set，返回长度。
setrange (替换部分子串)
语法：setrange  key offset value
解释：用value重写key值的一部分，偏移量由offset指定 。
Incr/decr
语法：incr/decr  key
解释：key中如果存储的是数字，则可以通过incr递增key的值，返回递增后的值。如果key不能存在，视为初始值为0。
Incrby/decrby
语法：incrby key increment
解释：用指定的步长增加key存储的数字。如果步长increment是负数，则减。
注意：递增递减系列的函数，只能对保存的是数字的key操作，不能是字符串。
</code></pre>

<p>删除及其它命令</p>

<pre><code>del
语法：del key [key]
解释：删除指定的key，返回删除key的个数。
</code></pre>

<p>长度</p>

<pre><code>strlen
语法：strlen key
解释：获取key中所存储值的长度。
</code></pre>

<p>场景案例</p>

<pre><code>案例：博客系统的设计与开发
需求与实现
文章的访问量：定义键 post:articleID:pageView，通过INCR命令递增
自增ID：定义键article:count，通过INCR递增
存储文章的数据：伪代码如下
首先获得新文章的ID
              $postID = INCR posts:count
将博客文章的诸多元素序列化成字符串
              $serializedPost = serialize($title,$content,$author,$time)
把序列化后的字符串存入一个字符串类型的键中
              SET post:$postID:data,$serializedPost
获取文章数据的伪代码
从Redis中读取文章的数据
              $serializePost=GET post:42:data
将文章数据反序列化成文章的各个元素
               $title,$content,$author,$time = unserialize($serializePost)
获取并递增文章的访问量
              $count=INCR post:42:pageView

post:count        最后一次的文章ID
post:42:data      序列化存储文章数据
post:42:pageView  文章访问量

组合使用多个字符串类型键来存储文章数据
Post:42:title   第一篇日志
Post:42:author  Michael
Post:42:content 今天下雨了
Post:42:time    2015-07-26
</code></pre>

<h4>Redis 的 Hash 类型的底层实现与操作命令</h4>

<p>Redis hash 是一个 string 类型的 field 和 value 的映射表，一个 key 可对应多个
field，一个 field 对应一个value。可以将 Redis 中的 Hash 类型看成具有 String
Key 和 String  Value 的 map容器。将一个对象存储为 Hash 类型，较于每个字段
都存储成 string 类型更能节省内存。每一个Hash可以存储2的32次幂 -1个键值对。</p>

<p>Hash 对应 Value 内部实际就是一个 HashMap，实际这里会有2种不同实现，这个
Hash的成员比较少时 Redis 为了节省内存会采用类似一维数组的方式来紧凑存储即
zipmap（压缩列表），而不会采用真正的 HashMap 结构，对应的value
redisObject 的 encoding为 zipmap，当成员数量增大时会自动转成真正的
HashMap,此时 encoding 为ht。
<img src="http://7xkc1x.com1.z0.glb.clouddn.com/struct_hash.png" alt="" />
dict.h/dict 给出了这个字典的定义：</p>

<pre><code>Typedef  struct  dict {
 dictType *type;  // 特定于类型的处理函数
 void *privdata;  // 类型处理函数的私有数据
 dictht ht[2];       // 哈希表（2 个）
 int rehashidx;  // 记录rehash 进度的标志，值为-1 表示rehash 未进行
 int iterators;    // 当前正在运作的安全迭代器数量
} dict;
</code></pre>

<p>字典所使用的哈希表实现由 dict.h/dictht 类型定义：</p>

<pre><code>typedef struct dictht {
     dictEntry  **table; // 哈希表节点指针数组（俗称桶，bucket）
     unsigned long size; // 指针数组的大小
     unsigned long sizemask; // 指针数组的长度掩码，用于计算索引值
     unsigned long used; // 哈希表现有的节点数量
  } dictht;
</code></pre>

<p>dictEntry 都保存着一个键值对，以及一个指向另一个 dictEntry 结构的指针:</p>

<pre><code>typedef struct dictEntry {
  void *key;// 键
  union {
     void *val;   …
    } v; // 值
  struct dictEntry *next;// 链往后继节点
} dictEntry;
</code></pre>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/redis_hash_struct_pic.png" alt="" /></p>

<p>新增相关命令</p>

<pre><code>hset
语法：hset key field value
解释：设置hash表key中的field的值。如果hash表不存在，则创建，并执行设置field的值，如果hash表存在，值field的值覆盖或新增。
hmset
语法：hash key  field  value[key value]
解释：批量设置hash表key的域。
hsetnx
语法：hsetnx key field value
解释：仅仅当field域不存在时，设置hash表field的值。
</code></pre>

<p>查询相关命令</p>

<pre><code>hget
语法：hget key field
解释：获取哈希表key的field值。
hmget
语法：hmget key
hgetall
语法：hgetall key
解释：获取hash表的所有域值。
hkeys
语法：hkeys key
解释：获取hash表的所有域。
hvals
语法：hvals key
解释：获取hash表的所有域值。
hexists
语法：hexists key field
解释：判断hash表中是否存在某个域。
</code></pre>

<p>修改相关命令</p>

<pre><code>hincrby

语法：hincrby key field increment
解释：hash表field域的数值增加步长increment，如果increment是负值，则是递减。如果域不存在，初始值视为0。
</code></pre>

<p>删除及其它命令</p>

<pre><code>hdel
语法：hdel key field[field]
解释：删除hash的域，如果指定多个field，则删除多个。
</code></pre>

<p>~</p>

<pre><code>hlen
语法：hlen key
解释：获取hash的域数量。
</code></pre>

<p>场景案例
<img src="http://7xkc1x.com1.z0.glb.clouddn.com/hash_post.jpg" alt="" /></p>

<h4>List概念与底层实现</h4>

<p>List是一个链表结构，主要功能是push、pop、获取一个范围的所有值等等，操作中key理解为链表的名字。Redis的list类型其实就是一个每个子元素都是string类型的双向链表。我们可以通过push、pop操作从链表的头部或者尾部添加删除元素， push和pop命令的算法时间复杂度都是O(1)，这样list既可以作为栈，又可以作为队列。链表的最大长度是2的32次幂-1。</p>

<h4>List常用操作命令</h4>

<p>LPUSH 与 LRANGE 命令</p>

<pre><code>LPUSH
语法：LPUSH  key   value
解释：用来向列表左边增加元素，返回值表示增加元素后列表的长度；LPUSH命令还支持同时增加多个元素。

LRANGE
语法：LRANGE  key   start  end
解释：用来获得列表中的某一片段，返回索引从 Start 到 end 之间的所有元素，索引从0开始。LRANGE 命令也支持负索引，-1表示最右边的元素，-2表示最右边倒数第2个元素。
</code></pre>

<p>RPUSH 与 LINSERT 命令</p>

<pre><code>RPUSH
语法：RPUSH  key   value
解释：用来向列表右边增加元素，返回值表示增加元素后列表的长度；RPUSH命令还支持同时增加多个元素。
LINSERT
语法：LINSERT  key   BEFORE | AFTER  pivot  value
解释：此命令首先会在列表中从左到右查找值为pivot的元素，然后根据第2个参数是BEFORE还是AFTER来决定将Value插入到前面还是后面。返回值是插入后元素的个数。
</code></pre>

<p>LPOP 与 RPOP 命令</p>

<pre><code>LPOP/RPOP
语法：LPOP/RPOP   key
解释：LPOP命令可以从列表左边弹出一个元素；RPOP从列表右边弹出一个元素。
LPOP和LPUSH配合，RPOP和RPUSH配合可以把列表当作栈使用；LPUSH和RPOP配合，RPUSH和LPOP配合可以把列表当作队列使用。
</code></pre>

<p>LREM 命令</p>

<pre><code>LREM
语法：LREM  key   count   value
解释：LREM 命令会删除列表中前 count 个值为value 的元素，返回值是实际删除的元素的个数。
当 count &gt;0时，从左边开始删除；
当 count &lt;0时，从右边开始删除；
当 count =0时，删除所有值为 value 的元素；
</code></pre>

<p>LTRIM 命令</p>

<pre><code>LTRIM
语法：LTRIM  key   start   end
解释：LTRIM 命令会删除列表中指定索引范围外的所有元素，返回值即指定索引内的元素。LTRIM 命令常和 LPUSH命令一起使用来限制列表中元素的数量，比如记录日志时我们希望只保留最近的100条记录，则每次添加日志时调用一次 LTRIM 命令即可。
</code></pre>

<p>RPOPLPUSH 命令</p>

<pre><code>RPOPLPUSH
语法：RPOPLPUSH  src   dest
解释：RPOPLPUSH 命令先从 src 列表的右边弹出一个元素，然后将其加入 dest 列表的左边，并返回这个元素的值。当把列表当作队列时，RPOPLPUSH 可以在多个队列中传递数据。当 src 与dest 相同时，此命令会不断的将队尾的元素移动到队首。
</code></pre>

<p>LINDEX 与 LSET命令</p>

<pre><code>LINDEX
语法：LINDEX  key  index
解释：LINDEX 命令用来返回指定索引的元素，索引从0开始。
LSET
语法：LSET key  index  value
解释：将索引为 index 的元素赋值为 value。
</code></pre>

<p>LLEN 命令</p>

<h4>List的应用场景</h4>

<pre><code>Redis list应用场景非常多,比如：
微博的关注列表
粉丝列表
博客评论
消息队列
取最新 N  个数据的操作
排行榜应用，取 TOP  N 操作
</code></pre>

<p>String 类型存储文章 ID 的弊端:</p>

<pre><code>如何获取文章列表
读取 post:count 键获得博客文章的最大 ID
根据 ID 进行分页（假设每页10条），第 n 页的文章 ID 范围是“最大的文章ID-(n-1)*10”到“max(最大的文章 ID – n*10+1,1)”
对每个ID使用HMGET命令来获取文章的数据，伪代码如下：

# 每页显示10篇文章
$postsPerPage  = 10
# 获得最后发表的文章 ID
$lastPostID = GET posts:count
# 当前页码范围
$start = $lastPostID – ($currentPage - 1) * $postsPerPage
$end = max( $lastPostID – $currentPage  * $postsPerPage +1，1)

# 遍历文章 ID 获取数据
For $i = $start down to $end
# 获取文章的标题和作者并打印出来
post = HMGET post:$i，title，author
         Print $post[0]
         Print $post[1]
缺点：删除文章时影响页码分布，都需要从最大文章 ID 开始遍历
</code></pre>

<p>List 类型存储文章 ID</p>

<pre><code>使用列表类型键 posts:list 记录文章 ID
LPUSH posts:list  文章ID
LREM    posts:list  1  文章 ID
# 使用 LRANGE 实现分页
$postsPerPage  = 10
$start =  ($currentPage - 1) * $postsPerPage
$end =  $currentPage  * $postsPerPage  - 1
$postsID = LRANGE posts:list，$start，$end

# 获取需要显示文章的 ID 列表
For   each   $id   in   $postsID
          $post = HGETALL post:$id
           print  文章标题：$post.title
</code></pre>

<p>缺点： 文档内容较多的时候，访问中间的内容性能比较差。因为LIST是通过链表实现的，所以访问中间元素时，效率不高； 解决方法，使用有序集合来存储文章ID.</p>

<p>List 类型存储文章评论</p>

<pre><code># 使用列表类型键post：文章 ID：comments来存储文章的评论
$serializedComment = serialize($author，$email，$time，$content)
LPUSH  post:42:comments，$serializedComment
读取评论时使用 LRANGE 命令
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis的安装与配置]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/24/redis_setup_config/"/>
    <updated>2015-07-24T10:36:56+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/24/redis_setup_config</id>
    <content type="html"><![CDATA[<h1>Redis 的历史与特性</h1>

<p>Redis 是Remote Dictionary Server的缩写，Redis是一个<strong>开源、基于C语言、基于内存可持久化</strong>的高性能NoSQL的<strong>键值对</strong>数据库。在众多场合中均可使用Redis代替传统的数据库或缓存系统。</p>

<p>与Memcache类似的NoSQL型数据库，但它的数据可以持久化的保存在磁盘上，解决了服务重启后数据不丢失的问题。</p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/show_redis.jpg" alt="" /></p>

<p>2015年Redis3.0.1 发布
    Redis 3.0 最重要的特征是对Redis集群的支持
Redis约定<strong>次版本号</strong>为偶数的版本是稳定版</p>

<p>主要特性：</p>

<ul>
<li>存储结构丰富</li>
<li>内存存储与持久化： 1s内读写10万个键值，异步写入硬盘；</li>
<li>功能丰富：可用于数据库，缓存系统，队列</li>
<li>简单稳定</li>
</ul>


<h1>安装</h1>

<p>安装最新版本的3.0， <a href="http://redis.io/download">http://redis.io/download</a></p>

<pre><code>apt-get install make gcc
wget http://download.redis.io/releases/redis-3.0.3.tar.gz
tar xzf redis-3.0.3.tar.gz
cd redis-3.0.3/src
make install
</code></pre>

<h3>Redis可执行文件</h3>

<p>redis-cli  #客户端
redis-server #服务器</p>

<pre><code>ls /usr/local/bin/redis*

cd ..
mkdir /etc/redis
cp redis.conf /etc/redis/6379.conf

cd utils/
cp redis_init_script /etc/init.d/redisd

sudo update-rc.d redisd defaults
service redisd start
</code></pre>

<h3>启动方法</h3>

<ol>
<li>redis-server&amp;

<ul>
<li>ps -ef |grep redis 检测后台进程是否存在</li>
<li>netstat -tunpl |grep 6379  检测6379端口是否在监听</li>
<li>redis-cli检测， shutdown退出</li>
</ul>
</li>
<li><p>指定配置文件启动</p>

<p> redis-server /usr/local/redis/etc/redis.conf</p>

<p> 修改配置文件 daemonize yes</p></li>
<li><p>使用Redis启动脚本设置开机启动</p></li>
</ol>


<p>启动脚本位于redis_init_script位于安装目录的/utils目录下，</p>

<pre><code>-   新建目录/etc/redis
-   复制redis.conf到/etc/redis/重命名为6379.conf
-   修改6379.conf配置
-   复制redis_init_script脚本文件复制到/etc/init.d目录中，并重命名redisd
-   执行随系统自动启动命令 
    -   sudo update-rc.d redisd defaults
    -   service redisd start
</code></pre>

<h3>停止方法</h3>

<ol>
<li>退出客户端用CTRL + C</li>
<li>在客户端下，执行SHUTDOWN，停止服务</li>
<li>kill -9 PID</li>
</ol>


<h3>redis 的配置</h3>

<p>redis.conf #redis server的配置文件</p>

<p>sentinel.conf #redis sentine配置文件，用于监控</p>

<ul>
<li>基本项配置</li>
<li><strong>持久化（Persistence）</strong>相关配置</li>
<li><strong>Replication配置</strong></li>
<li>Security配置</li>
<li>Limit配置</li>
<li>SlowLog配置</li>
<li>Advanced配置</li>
<li>INCLUEDS配置

<h5>基本配置</h5></li>
<li>daemonize 如果需要在后台运行，把该项改为yes</li>
<li>pidfile 配置多个pid地址， 默认在/var/run/redis.pid</li>
<li>bind  绑定ip， 设置后只接受来自该ip的请求</li>
<li>port 监听端口，默认6379</li>
<li>timeout 设置客户端连接的超时时间，单位为秒</li>
<li>loglevel分为4级， debug， verbose, notice, warning</li>
<li>logfile 配置log文件地址</li>
</ul>


<p>总结: 上述配置基本项中，port为必配项，其余项一般情况下保持默认即可。</p>

<h5>持久化配置项目</h5>

<ul>
<li>databases 设置数据库的个数， 默认使用的数据库为0</li>
<li>save 设置redis进行数据库镜像的频率</li>
<li>rdbcompression 在进行镜像备份时，是否进行压缩</li>
<li>Dbfilename 镜像备份文件的文件名</li>
<li>Dir 数据库镜像备份的文件放置路径

<h5>Limit配置项目</h5>

maxclients 客户端的并发连接数，默认10000
maxmemory配置Redis Server可占用的最大内存

<h5>Security配置项</h5>

<p>Requirepass 设置登录时需要使用的密码</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL数据库管理]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/23/mysql-study/"/>
    <updated>2015-07-23T17:26:01+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/23/mysql-study</id>
    <content type="html"><![CDATA[<h3>MySQL权限</h3>

<p>创建用户</p>

<pre><code>grant all privileges on *.* to dev@localhost identified by 'dev' with grant option;
grant select on jikedb.* to webuser@localhost identified by '123';
</code></pre>

<p>刷新权限</p>

<pre><code>flush privileges;
</code></pre>

<p>回收权限</p>

<pre><code>revoke select on jikedb.* from webuser@localhost;
</code></pre>

<p>删除用户</p>

<pre><code>drop user webuser@localhost;
</code></pre>

<p>查看用户权限</p>

<pre><code>show grants for root@localhost;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thinkphp]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/23/thinkphp/"/>
    <updated>2015-07-23T11:55:43+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/23/thinkphp</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>PHP 作为一种广泛用于 Web 服务器端的脚本语言，在敏捷 Web 开发方面有独特的优势，成功案例多、社区活跃、资源丰富，框架也非常多。ThinkPHP 作为一款起步较早、相对成熟的国产 PHP 框架，在国内有相当的用户量，借这个机会向大家介绍 ThinkPHP 基础知识，为后续的项目实战做好准备。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在ubuntu上安装mariadb]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/23/mariadb-setup/"/>
    <updated>2015-07-23T10:50:50+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/23/mariadb-setup</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>MySQL被SUN收购后，又被Oracle收购。它的作者从新开发了一个完全兼容MySQL的数据库，并且以他的女儿命名，叫做<a href="https://mariadb.org/">MariDB</a></p>

<h1>安装</h1>

<p>首先从 <a href="http://downloads.mariadb.org/mariadb/repositories/">MariaDB 下载页面</a> 选择贴近你的 Ubuntu 版本的资料库镜像，然后下载页面会在底部显示镜像信息（如下所示），然后执行这些命令</p>

<pre><code>sudo apt-get install software-properties-common
sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xcbcb082a1bb943db
sudo add-apt-repository 'deb http://mirrors.hustunique.com/mariadb/repo/5.5/ubuntu trusty main'
</code></pre>

<p>开始安装</p>

<pre><code>sudo apt-get update
sudo apt-get install mariadb-server
</code></pre>

<p>这样 MariaDB 5.5 就已经安装成功，你就可以像使用 MySQL 那样对它进行配置和使用了。</p>

<p>使用mysql -h -uroot -p1234测试。</p>
]]></content>
  </entry>
  
</feed>
