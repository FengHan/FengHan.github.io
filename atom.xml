<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[hanfeng.name]]></title>
  <link href="http://fenghan.github.io/atom.xml" rel="self"/>
  <link href="http://fenghan.github.io/"/>
  <updated>2015-10-16T08:25:18+08:00</updated>
  <id>http://fenghan.github.io/</id>
  <author>
    <name><![CDATA[HanFeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Drupal101]]></title>
    <link href="http://fenghan.github.io/blog/2015/10/12/drupal101/"/>
    <updated>2015-10-12T22:39:48+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/10/12/drupal101</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>入职新公司，开始学习Drupal。立志成为Drupal专家</p>

<h1>Drupal101</h1>

<ul>
<li>创始人 Dries Buytaert博客 <a href="http://buytaert.net/">http://buytaert.net/</a></li>
<li>学习资源 <a href="https://drupalize.me">drupalize.me</a></li>
</ul>


<h4>What is Drupal</h4>

<ul>
<li>CMS

<ul>
<li>CMF</li>
</ul>
</li>
<li></li>
</ul>


<h4>Who uses Drupal</h4>

<ul>
<li><a href="http://drupalshowcase.com/">Drupal Showcase</a></li>
<li><a href="https://www.drupal.org/case-studies">drupal.org</a></li>
</ul>


<h4>Major features with site building</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL存储引擎]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/16/mysql-storage-engine/"/>
    <updated>2015-09-16T20:01:29+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/16/mysql-storage-engine</id>
    <content type="html"><![CDATA[<h3>什么是MySQL存储引擎</h3>

<p>服务层 - 存储引擎 - 文件系统层</p>

<p>MySQL5.5 以后默认为InnoDB,推荐。</p>

<p>Memory存储引擎，临时表</p>

<h4>MyISAM</h4>

<ul>
<li>堆表（插入性能好）</li>
<li>不支持事务</li>
<li>只维护索引缓存池，表数据缓存交给操作系统（表若很大，浪费内存）</li>
<li>锁粒度较大（表级锁，读写锁，读的时候不允许写，写的时候不允许读）</li>
<li>数据文件可以直接拷贝，备份数据用得上</li>
</ul>


<p>不推荐的原因：1. 不支持事务 2. 锁的颗粒度比较大 3. 表数据缓存交给操作系统，表若很大，浪费内存</p>

<h4>TokuDB</h4>

<p>社区版备份比较麻烦</p>

<h4>MySQL Cluster</h4>

<ul>
<li>多主分布式集群</li>
<li>数据节点间冗余，高可用</li>
<li>支持事务</li>
<li>设计上易于扩展</li>
<li>面向未来，线上慎用</li>
</ul>


<h4>InnoDB</h4>

<ul>
<li>缓存池 +　各种后台线程　＋ 数据文件</li>
</ul>


<p>事务ACID:</p>

<ul>
<li>回滚段失败回滚（A）</li>
<li>支持主外键（C）</li>
<li>事务版本 + 回滚段 = MVCC(I)</li>
<li>事务日志持久化（D）</li>
</ul>


<p>行级别锁：</p>

<ul>
<li>写不阻塞读</li>
<li>不同行间的写相互不阻塞</li>
<li>并发性能好</li>
<li>锁是加在索引上的</li>
</ul>


<p>InnoDB数据块缓存池</p>

<ul>
<li>数据的读写经过缓存</li>
<li>IO效率高，性能好。</li>
</ul>


<p>InnoDB数据文件存储结构：</p>

<ul>
<li>根据主键寻址速度很快</li>
<li>主键值递增的insert插入效率较好</li>
<li>主键随机insert插入效率较好</li>
<li><strong>因此，InnoDB表必须指定主键，建议使用自增数字</strong></li>
</ul>


<p>数据持久化与事务日志</p>

<ul>
<li>事务日志实时持久化</li>
</ul>


<h3>介绍MySQL主要存储引擎的特点及试用场景</h3>

<h3>Innodb存储引擎</h3>

<pre><code>show global variables like "%increment%";

+-----------------------------+-------+
| Variable_name               | Value |
+-----------------------------+-------+
| auto_increment_increment    | 1     |
| auto_increment_offset       | 1     |
| div_precision_increment     | 4     |
| innodb_autoextend_increment | 64    |
+-----------------------------+-------+
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL数据库对象与应用]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/14/mysql-db-object/"/>
    <updated>2015-09-14T11:16:22+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/14/mysql-db-object</id>
    <content type="html"><![CDATA[<h1>MySQL数据类型</h1>

<h4>经验之谈</h4>

<ul>
<li>存储性别、省份、类型等分类信息时，选择TINYINT或者ENUM</li>
<li>BIGINT存储空间更大，INT和BIGINT之间通常选择BIGINT</li>
<li>交易等高精度数据时选择使用DECIMAL</li>
</ul>


<h1>MySQL数据对象</h1>

<p>help create index</p>

<h1>MySQL权限管理</h1>

<ul>
<li><p>Data Privileges</p>

<pre><code>  DATA: SELECT, INSERT, UPDATE, DELETE
</code></pre></li>
<li>Define</li>
<li>Administrator Privileges

<ul>
<li>Shutdown Database</li>
<li>Replication</li>
</ul>
</li>
</ul>


<p>创建一个用户并赋权：</p>

<ul>
<li>使用原生的SQL</li>
<li>更改数据库记录</li>
<li>更简单的方法

<h4>查看用户权限</h4>

show grants;

<h4>如何更改用户的权限</h4></li>
</ul>


<h4>如何更改用户的密码</h4>

<h4>删除用户</h4>

<h4>With Grant Option</h4>

<h4>与权限相关的表</h4>

<ul>
<li>user</li>
<li>db</li>
<li>tables_priv</li>
<li>clomuns_priv

<h5>Mysql 权限验证的过程</h5></li>
</ul>


<h4>MySQL权限上有哪些问题</h4>

<ul>
<li>默认的test库不受权限控制，存在安全风险</li>
<li>mysql_secure_installation</li>
</ul>


<h4>小结</h4>

<ul>
<li>权限相关的操作不要直接操作表，统一使用MySQL命令</li>
<li>使用二进制安装MySQL后，需要重置管理用户（root）的密码</li>
<li>线上数据库不要留test库</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高性能产品的必由之路—性能测试工具]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/12/performance-test/"/>
    <updated>2015-09-12T10:32:58+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/12/performance-test</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>课程笔记：<a href="http://www.imooc.com/learn/278">IMOOC:高性能产品的必由之路—性能测试工具</a>。
昨天面试，问我LNAMP能够承载多少用户，答不知道，所以学习。</p>

<h1>引言</h1>

<ul>
<li>搭建一个网站容易</li>
<li>搭建一个千万用户级的网站没有那么容易

<ul>
<li>横向扩展的能力</li>
<li>数据库的优化</li>
<li>尽量让一台机器能够承载更多的用户请求

<h1>性能测试的指标</h1>

<h4>什么是系统测试</h4></li>
</ul>
</li>
</ul>


<p>性能测试就是通过<strong>技术的手段</strong>模拟大量用户<strong>同时</strong>访问被测应用，观察、记录和分析系统的<strong>各项性能指标</strong>的过程。</p>

<p>性能测试的目标是评估系统的性能瓶颈，预测系统的最大用户负载能力。</p>

<h3>两个关键点</h3>

<ul>
<li>模拟大量并发用户</li>
<li>监控系统负载参数分析系统瓶颈

<h4>性能指标</h4></li>
<li>平均响应时间（TTLB, Time to laster byte）

<ul>
<li>平均每个请求从发送到接收响应的时间</li>
<li>合理的平均响应时间

<ul>
<li>2/5/10原则</li>
<li>非常有吸引力/比较不错/糟糕失败的</li>
</ul>
</li>
<li>平均响应时间的业务影响

<ul>
<li>1秒延迟减少了11%的PV，降低了16%的客户满意度</li>
<li>2秒增加到10秒，会导致38%的页面浏览放弃率</li>
</ul>
</li>
</ul>
</li>
<li>CPU

<ul>
<li> CPU的占用率</li>
</ul>
</li>
<li>内存

<ul>
<li>内存的占用率， 换页数</li>
</ul>
</li>
<li>I/O

<ul>
<li>读写请求数，读写量</li>
</ul>
</li>
<li>带宽

<ul>
<li> 进站出站带宽占用率

<h4>为什么要进行性能测试</h4></li>
</ul>
</li>
<li>能够有效评估系统的性能指标，用于系统的系能评估</li>
<li>能够识别系统的性能瓶颈，协助性能调优</li>
<li>能够指导突发流量承载方案的制定</li>
<li>能够用于系统运维成本的预算

<h4>性能的事的一般分类</h4></li>
<li>负载测试(Load Test)

<ul>
<li>为了验证系统设计符合正常业务负载情况下系统性能表现的测试</li>
<li>开发人员找到内存泄露、连接泄露和系统瓶颈</li>
</ul>
</li>
<li>压力测试（Stress Test）

<ul>
<li>为了验证系统在极端负载情况下的性能表现的测试</li>
</ul>
</li>
</ul>


<h3>性能测试工具</h3>

<ul>
<li>top

<ul>
<li>F 显示字段与排序</li>
<li>h 帮助</li>
<li>VIRT 虚拟内存大小</li>
<li>RES   真实内存大小</li>
<li>SHA 共享内存大小</li>
<li>TIME+ 运行这个进程的时间</li>
<li>查看cpu排序也可以用  SHIFT键+p 或者  大写状态下 P</li>
<li>查看内存排序也可以用  SHIFT键+m 或者  大写状态下 M</li>
</ul>
</li>
<li>top -b -n 1

<ul>
<li>b 所有的都列出来</li>
<li>n 1  ， 只执行一次</li>
</ul>
</li>
<li>sysstat

<ul>
<li>统计系统的各种占用资源</li>
<li>cd /etc/cron.d; cat sysstat</li>
<li>CPU监控</li>
<li>查看是否是内存瓶颈</li>
<li>swap的监控</li>
<li>IO的监控</li>
<li>网络监控

<h3>评估磁盘读写性能极限</h3></li>
</ul>


<p>  fio -filename=/tmp/test -direct=1 -iodepth 1 -thread -rw=randrw -ioengine=psync -bs=16k -size 2G -numjobs=10 -runtime=30 -group_reporting -name=mytest13
查看IOPS,我的ssd硬盘，在虚拟机中的ubuntu， read：1348 write：1345</p></li>
</ul>


<h1>Jmeter</h1>

<p>Apache组织开发的开源性能测试工具</p>

<h4>ECSHOP</h4>

<ul>
<li>开源，但商业应用需要付费，功能齐全。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL主从复制]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/10/mysql-master-slave/"/>
    <updated>2015-09-10T10:44:16+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/10/mysql-master-slave</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>之前写过一篇MySQL的主从配置，今天这篇文章涉主要涉及理论。</p>

<h1>什么是主从复制</h1>

<ul>
<li>数据拷贝</li>
<li>准实时</li>
<li>源主节点； 目的-从节点</li>
</ul>


<h1>主从复制的原理</h1>

<h4>复制格式</h4>

<ul>
<li>SRB: Statement Based Replication (原生的语句)</li>
<li>PBR: Row （5.7.7变为默认格式）</li>
<li>MBR: Mixed</li>
</ul>


<p>查看复制格式
        show global variables like &lsquo;binlog_format&rsquo;;</p>

<p>配置文件
    [mysqld]
    binlog_format = ROW</p>

<h1>主从复制的用途</h1>

<ul>
<li>试试灾备，用于故障切换（高可用的切换）</li>
<li>读写分离，提供查询服务</li>
<li>备份，避免影响业务</li>
</ul>


<h2>MySQL主从复制的一些模式</h2>

<ol>
<li>一主一从</li>
<li>主主复制</li>
<li>一主多从</li>
<li>多主依从 （mysql5.7开始支持）</li>
<li>联级复制</li>
</ol>


<h1>主从复制的搭建</h1>

<h3>主从部署的必要条件：</h3>

<ul>
<li>主从开启binlog日志（设置log-bin参数）</li>
<li>主从server-id不同</li>
<li>从库服务器能连通主库</li>
</ul>


<h3>主从部署步骤</h3>

<ul>
<li>备份还原(mysqldump )</li>
<li>授权 （grant replicaton slave on <em>.</em>）</li>
<li>配置复制，并启动 (change master to)</li>
<li><p>查看主从复制信息 (show slave status\G)</p>

<h1>主从复制的问题</h1></li>
<li><p>主库宕机，数据可能丢失</p></li>
<li>从库只有一个sql thread, 主库写压力大，复制很可能延时。</li>
</ul>


<h3>MySQL半同步复制</h3>

<h3>MySQL并行复制</h3>

<ul>
<li>社区版5.6新增</li>
<li>并行是指从库多线程，</li>
<li><p>库级别并应用binlog，同一个数据库更新还是串行的（5.7版并行复制基于事务组）</p>

<p>  set global slave_parallel_workers = 10</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL索引]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/10/mysql-index/"/>
    <updated>2015-09-10T10:07:51+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/10/mysql-index</id>
    <content type="html"><![CDATA[<h4>什么是索引</h4>

<p>索引是值到行位置的映射。索引就是一个目录。</p>

<h4>索引的作用：</h4>

<ul>
<li>提高访问的速度。硬盘IO每秒100到150次的响应。每次10毫秒</li>
<li>实现主键、唯一键逻辑</li>
</ul>


<p>IO是个宝贵的资源，</p>

<h4>索引的使用场景：</h4>

<p>FTS 全表索引</p>

<h4>Mysql中我们可以使用的索引类型：</h4>

<ul>
<li>Btree索引：</li>
<li>B+tree： 平衡二叉树的一种改良</li>
<li>Hash索引 InnoDB</li>
<li>Innodb ： 聚簇索引，</li>
<li>二级索引： 除了主键，用户创建的索引。</li>
</ul>


<h4>索引的代价：</h4>

<p>插入修改删除每个索引都编程一个内部事务，索引越多，事务越长。(增删改)</p>

<h4>索引的优势:</h4>

<ol>
<li>减少查询IO</li>
<li>优化等值查询、范围查询</li>
<li><p>利用有序特性</p>

<p> order by , group byh , distinct, max ,min</p></li>
</ol>


<h4>如何用好索引：</h4>

<ul>
<li><p>依据where查询条件来建立索引：</p>

<pre><code>  select a,b from tab_a where c = ?;  #c上建立索引
</code></pre></li>
<li><p>使用联合索引，而不是多个单列索引。</p>

<pre><code>  select * from tab_a where a = ? AND b = ? 
  #建立a和b的索引， 把一组值作为b+tree 的索引， 在同一个树里，查询速度更高。
</code></pre></li>
<li><p>联合索引， 区分度大的放在前面。</p>

<pre><code>  name,gender 对， 因为name的区分度很大。能够更好地使用b+ TREE来定位节点

  gender,name 错
</code></pre></li>
<li><p>联合索引能为前缀单列，复列查询提供帮助。</p>

<pre><code>  where a = ? 
  wherer a = ? AND b =? 
</code></pre></li>
<li><p>合理创建联合索引，避免冗余。
      abc 包含 a ,ab</p></li>
<li><p>ORDER BY, GROUP BY, DISTINCT 字段添加索引</p></li>
<li><p>用 EXPLAIN 查看语句</p>

<pre><code>  possible_key 可以使用的索引
  key 实际的索引名字  重要
  rows  读的记录行数，才返回的结果 重要。
  typpe   index  扫描完整的索引树， 重要   
  key_len 如果只使用了一部分，为长度。  
  force index  强制使用索引 
  ignore index 
</code></pre>

<h4>其他技巧</h4></li>
<li><p>一个表，控制百万级别。如何达到了一两百G，就可以考虑分库分表了。千万级别，取决于访问方式，left join</p></li>
<li><p>WHERE查询时，  函数不要加在字段上。timestamp > func(1234)。</p></li>
<li><p>外键一般用程序使用。</p></li>
<li><p>什么事优化器： 哪个索引会更快，IO更小。生发语法数，生成一个计划。</p></li>
<li><p>纵向分表，根据业务来拆分。</p></li>
<li><p>等值查询 ，2个范围查询， 不能都覆盖到。联合查询。等值能用一个，范围查询也只能用一个。</p></li>
<li><p>通过表结构设计来避免连表。</p></li>
<li><p>触发器和存储过程不好维护，做运维手段还可以。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL Foundation]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/09/mysql-foundation/"/>
    <updated>2015-09-09T15:25:59+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/09/mysql-foundation</id>
    <content type="html"><![CDATA[<h1>认识MySQL</h1>

<h4>关系与非关系型数据库</h4>

<p>关系型数据库</p>

<ul>
<li>mysql</li>
<li>oracle</li>
<li>sql server</li>
<li>postgresql</li>
</ul>


<p>非关系型数据库</p>

<ul>
<li>hadoop</li>
<li>mongoDB</li>
<li>redis</li>
<li>Cassandra</li>
</ul>


<p>区别：</p>

<p>是否使用SQL语句作为数据操作的方法和方式。</p>

<p>所以关系型数据库又叫做SQL数据库。</p>

<h4>为什么学习MySQL</h4>

<ul>
<li>基于GPL协议</li>
<li>Mysql 最流行 ，开源，但不是最先进的。</li>
<li>互联网企业中占绝对主流地位</li>
</ul>


<p>开发者学习MySQL：</p>

<ul>
<li>学习数据类型的正确使用</li>
<li>学习如何利用索引优化查询效率</li>
<li>了解分区，读写分离特性</li>
<li>了解数据库事务相关特性</li>
</ul>


<p>DBA学习MySQL：</p>

<ul>
<li>学习MySQL体系结构知识</li>
<li>学习日常运维，性能调优，故障排查</li>
<li>虚席数据层架构设计，schema优化知识</li>
</ul>


<h1>轻松安装MySQL</h1>

<p>5.6 <a href="http://www.mysql.com/downloads/">http://www.mysql.com/downloads/</a></p>

<ul>
<li>企业版</li>
<li>集群版</li>
<li>社区版 （免费）

<h4>Windows上安装</h4>

<p>安装包：300M+</p></li>
</ul>


<h4>Linux上安装</h4>

<h4>Ubuntu上安装MySQL</h4>

<pre><code>apt-cache search mysql-server
apt-get install mysql-server-5.6
#查看mysql进程
ps -ef|grep mysqld
#查看mysql状态：版本、运行时间、连接方式、查询统计
sudo /etc/init.d/mysql status
#msyql启动、停止、重启
sudo /etc/init.d/mysql start|stop|restart
</code></pre>

<h1>连接使用MySQL</h1>

<ul>
<li>应用程序驱动</li>
<li>MySQL命令行</li>
<li><p>GUI工具</p>

<p>  #查看mysql-client版本
  mysql -V</p></li>
</ul>


<p>命令行连接MySQL</p>

<ul>
<li><p>Socket连接(本地连接)</p>

<pre><code>  mysql -S/var/run/mysqld/mysqld.sock -uhomestead -p
</code></pre></li>
<li><p>TCP/IP连接（远程连接）</p>

<pre><code>   mysql -h127.0.0.1 -P3306 -uhomestead -p
</code></pre></li>
</ul>


<p>本地连接只能在MySQL服务器上创建，常作为MySQL状态检查，或程序和MySQL部署在一台机器上。</p>

<pre><code>#小技巧
Ctrl + r : 搜索之前敲过的命令
</code></pre>

<h3>两个重要的命令： status, show processlist</h3>

<h4>status</h4>

<p>关注的信息：</p>

<ul>
<li>Server version</li>
<li>characterset: utf8 (Server, Db, Client, Conn)</li>
<li>Uptime

<h4>show processlist</h4></li>
</ul>


<p>help select;</p>

<pre><code>#查看socket文件位置
show global variables like 'socket'
</code></pre>

<ul>
<li>socket权限为777</li>
<li>不要把密码直接输入在命令行里面，存在安全风险。</li>
</ul>


<p>history -c 清楚命令行历史</p>

<h4>常用的图形客户端工具</h4>

<ul>
<li>Navicat</li>
<li><p>MySQLWenkBench</p></li>
<li><p>操作简单，易于上手</p></li>
<li>支出图形化的导入导出</li>
<li>可视化的界面输出</li>
</ul>


<p>总结：</p>

<ol>
<li>应用程序使用API接口连接MySQL</li>
<li>开发工程师可以使用图形工具连接MySQL</li>
<li><strong>命令行工具才是DBA的最爱</strong></li>
</ol>


<h1>SQL语言入门</h1>

<p>DDL :
- CREATE TABLE
- DROP TABLE
- ALTER TABLE</p>

<p>DML:</p>

<ul>
<li>SELECT FROM TABLE</li>
<li>INSERT INTO TABLE</li>
<li>UPDATE TABLE SET</li>
<li>DELETE FROM TABLE</li>
</ul>


<p>DCL:</p>

<ul>
<li>GRANT</li>
<li>REVOKE</li>
</ul>


<p>TCL:</p>

<ul>
<li>COMMIT</li>
<li>ROLLBACK</li>
</ul>


<p><a href="http://www.w3school.com.cn/sql/">SQL教程</a></p>

<h1>认识DBA</h1>

<p>DBA是最后一道屏障，守门员，是业务稳定的基石。</p>

<p>监控线上，保障业务的正常运行。</p>

<p>做好实时性能监控,一旦有长的SQL语句，就会立刻接到报警，然后进行调优。</p>

<h4>小公司</h4>

<ul>
<li>没有专职DBA</li>
<li>但肯定有懂数据库的人</li>
</ul>


<p>大公司：</p>

<ul>
<li>专职DBA</li>
<li>数据存储技术专家</li>
</ul>


<p>互联网业务： 高性能、高可用、可扩展、安全性。</p>

<p>没有DBA就没有稳定的数据库，请求变慢，数据丢失，安全问题，用户投诉，无穷无尽。</p>

<h3>DBA要做哪些工作？</h3>

<ol>
<li>基础运维

<ul>
<li>安全部署</li>
<li>监控</li>
<li>故障处理</li>
</ul>
</li>
<li>安全运维工作

<ul>
<li>数据备份与恢复</li>
<li>安全访问，安全漏洞</li>
<li>审计</li>
</ul>
</li>
<li>性能调优工作

<ul>
<li>数据库优化</li>
<li>容量评估、软硬件升级</li>
</ul>
</li>
<li>开发支持工作

<ul>
<li>存储方案制定(哪些数据放在memcache，减少对数据库的访问)</li>
<li>数据库设计</li>
<li>数据库变更 SQL Review （审核业务SQL，全表扫描的SQL会把数据库跑死）</li>
</ul>
</li>
<li>流程与培训

<ul>
<li>数据库开发规范</li>
<li>运维流程与标准化</li>
<li>业务培训</li>
</ul>
</li>
</ol>


<p>练习：
mysql要做的：</p>

<p>分析MySQL慢日志请求，优化表索引</p>

<h4>DBA需要的技能</h4>

<p>专业技能：
    - 数据库原理
    - Linux与Shell
    - 计算机体系结构
    - 网络原理
    - 数据库系统与操作
    - 服务器硬件
    - 业务架构设计
软技能：</p>

<pre><code>- 责任心、执行力
- 坚韧，抗压（半夜、凌晨工作）
- 学习与沟通能力
- 正直，诚信
- 耐心，注重细节
- 分析能力
- 团队协作
- 
</code></pre>

<p>DBA如何发展？</p>

<ul>
<li>业务架构师（数据存储有深入研究，处理不同业务场景与需求的数据存储）</li>
<li>运维专家（解决mysql的任何问题，帮助数据库更稳定更高效的运行）</li>
<li>数据库研发（改进数据库系统或开发自己的数据库）</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laravel5 基础]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/09/learn-laravel-from-scratch/"/>
    <updated>2015-09-09T11:09:29+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/09/learn-laravel-from-scratch</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>Laravel 5 的很多新功能是来自 Jeffrey Way的 idea,</p>

<p>如: Form Requests, Laravel Elixir, Command bus etc..</p>

<p>所以, 他的这套视频就很有观看的必要
 <a href="https://laracasts.com/series/laravel-5-fundamentals">https://laracasts.com/series/laravel-5-fundamentals</a></p>

<p>现已看完，做下记录</p>

<h2>Laravel5 Foundation</h2>

<h4>需求分析：</h4>

<ol>
<li>Article模块

<ul>
<li>Articles List</li>
<li>Create Article :title , body, published_at, tag</li>
<li>Edit Article</li>
</ul>
</li>
<li>用户登录模块</li>
</ol>


<h4>细节：</h4>

<ol>
<li>Create Article的输入内容，要进行validate，使用Request进行验证。</li>
<li>Create Article成功时，用Flash Message提示。</li>
</ol>


<h4>学习的内容</h4>

<ul>
<li>Composer 的安装与使用</li>
<li>Virtual Box, Vagrant, Homestead安装与使用</li>
<li>Route 路由的使用</li>
<li>Blade  模板文件</li>
<li>.env 开发环境的设置</li>
<li>migration 创建和修改数据库的结构</li>
<li>MVC在Laravel中的工作流</li>
<li>Form表单</li>
<li>Model 中的 Dates : Carbon\Carbon</li>
<li>Model 中的 Scopes : 封装判断条件（例如： article是否发布）</li>
<li>Model 中的 set Attributes : 插入记录时，自动插入（例如时间）</li>
<li>View Partials 视图文件的局部选软</li>
<li>Eloquent  这个很强大，但感觉复杂查询会很麻烦，// todo 继续深入学习</li>
<li>Auth  Laravel5.0 提供了简单的注册、登录和找回密码</li>
<li>Middleware （用处：例如验证是否用户登录）</li>
<li>Many to Many Relation (A article has many tags, and a tag has many articles.)</li>
<li>Tag 选择地时候用了Select2插件</li>
<li>View Partial Always Receive Data (例如首页导航条)</li>
<li>Service Container (又叫 Ioc Container,是Laravel框架的核心所在)</li>
</ul>


<h3>用到的第三方包</h3>

<pre><code>{
    “require” : {
        "barryvdh/laravel-ide-helper": "^2.1",
        "illuminate/html": "^5.0",
        "laracasts/flash": "~1.3",
    }
}
</code></pre>

<ul>
<li>barryvdh/laravel-ide-helper  用来提示Laravel的Facade</li>
<li>illuminate/html Html Form封装了form表单</li>
<li>laracasts/flash Jeffrey Way写的 flash message</li>
</ul>


<p>以上文件放在composer.json中，第二步是在config/app.php配置 provider 和 alias.</p>

<h3>经常用到的命令</h3>

<pre><code>php artisan make:controller --plain
php artisan dump-autoload 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cross Site Request Forgery]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/05/csrf/"/>
    <updated>2015-09-05T17:00:56+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/05/csrf</id>
    <content type="html"><![CDATA[<p>CSRF（Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。</p>

<h3>CSRF 攻击的防范；</h3>

<ol>
<li><p>加密令牌：web应用程序可以在网页中嵌入一个加密的令牌，所有的请求都包含这个加密令牌，由于跨站请求无法获取这个令牌，所以伪造的请求很容易就被服务器识别；</p></li>
<li><p>Referer头途径：使用web应用程序也可以验证请求来源页面的Referer，然后由于隐私考虑，这个referer经常被客户端过滤；</p></li>
</ol>


<h3>加密令牌</h3>

<p>1.根据 加密参数、用户的session_id(), 时间戳和存放在session中的HASH函数。</p>

<p>把令牌token和时间戳 放到form的hidden里面。</p>

<pre><code>$_SESSION[STOKEN_NAME] = gen_token(); // 随机数
&lt;input type="hideen" value="session_token" value= &lt;?=$_SESSION[STOKEN_NAME]?&gt;
</code></pre>

<p>每次请求的时候，要验证session_token。</p>

<p>参考链接：</p>

<ol>
<li><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></li>
<li><a href="https://www.shiyanlou.com/courses/303#">实验楼 - Elgg 系统 CSRF 攻击实验</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xdebug]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/02/xdebug/"/>
    <updated>2015-09-02T22:57:38+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/02/xdebug</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>掌握Xdebug是每一个PHP程序员必备的技能。</p>

<p>当你在使用Yii, ThinkPHP, Laravel框架的时候，你只有了解其系统架构后，才能更好的编写代码。Xdebug能够帮助你更好的调试代码。</p>

<p>安装XDebug在<a href="http://xdebug.org/wizard.php">官网</a>输入你的phpinfo()信息，然后按照它的提示进行安装。</p>

<p><a href="http://xdebug.org/docs/remote">远程调试</a>
<a href="http://aicode.cc/article/362.html">中文文档</a></p>

<pre><code>[xdebug]
zend_extension = /usr/lib/php5/20131226/xdebug.so
xdebug.remote_enable=1
xdebug.remote_host=localhost
xdebug.remote_port=9000
xdebug.remote_connect_back=1
xdebug.remote_autostart=1
xdebug.profiler_enable=1
xdebug.profiler_output_dir="/tmp"
xdebug.idekey=PHPSTORM
</code></pre>

<p>php -v查看是否安装成功</p>

<pre><code>root@homestead:/etc/php5/fpm# php -v
with Xdebug v2.3.3, Copyright (c) 2002-2015, by Derick Rethans
</code></pre>

<p>php &ndash;ini</p>

<p>我在这里遇到了一个坑，因为ubuntu环境下的php配置文件被拆分成多块，要在cli 下使用 php &ndash;ini来查看配置文件的位置。</p>

<p>PHPStrom与Xdebug的结合使用，有一系列的配置。</p>

<p>PHPStrom配置，一个是在PHP SCRIPT, 另一个是PHP WEB APPLICATION.</p>

<h1>后续</h1>

<p>在上面折腾了一番后，原来我使用Laravel提供的Homestead开发环境已经提供了XDebug，已经开启了远程调试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop介绍]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/30/hadoop-intro/"/>
    <updated>2015-08-30T16:22:21+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/30/hadoop-intro</id>
    <content type="html"><![CDATA[<p>慕课网<a href="http://www.imooc.com/learn/391">Hadoop大数据平台架构与实践&ndash;基础篇</a> 的文字记录</p>

<h1>初识Hadoop</h1>

<h2>课程简介</h2>

<h4>介绍的内容：</h4>

<ol>
<li>大数据技术的相关概念</li>
<li>Hadoop的架构和运行机制</li>
<li>实战：Hadoop的安装和配置</li>
<li>实战： Hadoop的开发</li>
</ol>


<h4>学习目标：</h4>

<ol>
<li>掌握大数据存储与处理技术的原理（理论知识）</li>
<li>掌握Hadoop的使用和开发能力（实践能力）</li>
</ol>


<h4>课程学习建议：</h4>

<ol>
<li>书籍：

<ol>
<li>《Hadoop权威指南》</li>
<li>《Hadoop技术详解》</li>
</ol>
</li>
<li>实践很重要，边听边实践</li>
</ol>


<h4>课程预备知识</h4>

<ol>
<li>Linux常用命令</li>
<li>Java编程基础

<h2>Hadoop的前世今生</h2>

<p>单机的系统瓶颈： 存储容量，读写速率，计算效率</p></li>
</ol>


<p>Google大数据技术：
1. MapReduce
2. BigTable
3. GFS</p>

<ul>
<li>革命性的变化1：成本降低，能用PC机，就不用大型机和高端存储。</li>
<li>革命性得变化2： 软件容错硬件故障视为常态，通过软件保证可靠性</li>
<li>革命性的变化3： 简化并行分布式计算，无须控制节点同步和数据交换</li>
</ul>


<p>Google只发表了论文，没有开放源代码。</p>

<p>Hadoop是一个模仿大数据技术的开源实现。</p>

<h2>Hadoop的功能与优势</h2>

<h4>什么是Hadoop</h4>

<p>Hadoop是<strong>开源的</strong>， <strong>分布式存储</strong> + <strong>分布式计算平台</strong>。
<a href="http://hadoop.apache.org/">http://hadoop.apache.org/</a></p>

<p>它包括两个核心组成：</p>

<ul>
<li>HDFS: 分布式文件系统，存储海量的数据</li>
<li>MapReduce: 并行处理框架，实现任务分解和调度</li>
</ul>


<h4>Hadoop可以用来做什么?</h4>

<p>搭建大型数据仓库，PB级数据的存储、处理、分析、统计业务。</p>

<ul>
<li>搜索引擎</li>
<li>商业智能</li>
<li>日志分析</li>
<li>数据挖掘</li>
</ul>


<h4>Hadoop的优势</h4>

<ol>
<li>高扩展</li>
<li>低成本</li>
<li>成熟的生态圈</li>
</ol>


<h4>Hadoop的应用情况</h4>

<ul>
<li>国外： facebook twitter yahoo intel hulu linkedIn</li>
<li>国内： 百度，京东，淘宝，华为，新浪微博，小米，腾讯，网易</li>
</ul>


<p>Hadoop已成为业内大数据平台的首选</p>

<h4>Hadoop的人才需求</h4>

<ol>
<li>Hadoop开发人才</li>
<li>Hadoop运维人才</li>
</ol>


<h2>Haoop的生态系统及版本</h2>

<h4>生态系统</h4>

<ul>
<li>Hive

<ul>
<li>中文：小蜜蜂，不需要Hadoop任务程序，只需要写SQL语句。降低了使用Hadoop的使用门槛</li>
<li>它是基于Hadoop之上的一个数据仓库</li>
</ul>
</li>
<li>HBase 存储结构化数据的分布式数据库。

<ul>
<li>与传动数据相比：放弃事务特性，最求更高的扩展</li>
<li>与HDFS的区别：随机读写和实时访问，实现对表数据的读写功能</li>
</ul>
</li>
<li>zookeeper

<ul>
<li>像动物管理员一样，监控Hadoop集群里面每一个节点的状态。管理配置，维护节点之前的一致性

<h4>版本</h4></li>
</ul>
</li>
</ul>


<p>1.x 与 2.x （现在2.6）</p>

<p>我们选择1.2的版本，因为1.x稳定，且对于新手易于理解容易上手。</p>

<hr />

<h1>Hadoop的核心 - HDFS简介</h1>

<h2>HDFS设计架构</h2>

<ul>
<li>Blocks

<ul>
<li>HDFS的文件被分成块进行存储</li>
<li>HDFS块的默认大小为64M</li>
<li>块是文件存储处理的逻辑单元</li>
</ul>
</li>
<li>NameNode

<ul>
<li>NameNode是管理节点，存放文件元数据</li>
<li>文件与数据块的映射表</li>
<li>数据块（Block）与数据节点(DataNode)的映射表</li>
</ul>
</li>
<li>DataNode

<ul>
<li>用来存放数据块的。</li>
</ul>
</li>
</ul>


<h2>数据管理策略</h2>

<h4>HDFS数据管理与容错</h4>

<p>每个数据块3个副本，分布在两个机架内的三个节点</p>

<h4>心跳检测</h4>

<ul>
<li>DataNode定期向NameNode发送心跳信息</li>
<li>二级NameNode定期同步元数据镜像文件和修改日志， NameNode发生故障时，备胎转正。</li>
</ul>


<h4>HDFS读取文件流程</h4>

<h4>HDFS特点</h4>

<hr />

<h1>Hadoop的核心 - MapReduce简介</h1>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性能瓶颈]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/30/performance-bottleneck/"/>
    <updated>2015-08-30T00:10:51+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/30/performance-bottleneck</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>今天和一位搞运维研发的同学聊天，问如何解决300万条订单数据的分析。</p>

<p>答：看性能瓶颈在哪里，<strong>读慢加缓存，写慢加队列</strong></p>

<p>可以研究一下内容：hadoop、spark、分布式数据库hbase，其中Spark利用内存计算会快些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大数据简介]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/29/big-data-intro/"/>
    <updated>2015-08-29T23:47:10+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/29/big-data-intro</id>
    <content type="html"><![CDATA[<p><a href="http://mooc.study.163.com/course/Wiley-1000077001#/info">网易云课堂-大数据简介</a></p>

<h1>大数据的定义</h1>

<p>大数据可以定义为一个巨大的数据集，
在可接受的时间范围内，它可以用来获取、存储、搜索、转换、分析以及可视化相关的信息或数据。</p>

<h1>大数据的三个特性</h1>

<ol>
<li>Volume 容量巨大</li>
<li>Velocity 产生速度快 处理速度快</li>
<li>Variety 种类繁多</li>
</ol>


<p>例子：</p>

<ul>
<li>Twitter每秒产生80M的数量</li>
<li>eBay每天可以实施分析500万交易</li>
<li>产生的数据又各种类型，因为数据的来源不同。数据有结构化数据（database,excel）、半结构化数据(word)和非结构化数据（图片、文件）。</li>
</ul>


<h1>大数据的三个来源</h1>

<ol>
<li>社交</li>
<li>机器   : 例如RFID射频识别信息</li>
<li>交易数据</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SCRUM敏捷式开发（Agile）思维整理]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/29/agile/"/>
    <updated>2015-08-29T12:33:45+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/29/agile</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>今天看到朋友圈里关于<a href="www.teambition.com">teambition</a>团队协作工具的介绍。</p>

<p>由此联想到了以前公司的SCRUM敏捷式开发。这里整理一下敏捷式团队开发的一些思绪。</p>

<h1>SCRUM</h1>

<p><img src="http://images.cnblogs.com/cnblogs_com/taven/201010/2010-10-17_202832.png" alt="" /></p>

<p>就如上图(图片为网络搜寻)所看到的，一个超大的白板上规矩的排满了各种纸条。每个纸条上写着各种任务。如果谁对这个任务感兴趣，就在这个纸条上写上自己的名字。为了便于说明，我假设了一个场景进行阐述。</p>

<h4>周一上午</h4>

<p>IT经理已经和总经理进行了讨论。IT 经理说：</p>

<ol>
<li><p>上周，市场部门已经提前跟我说过，国庆节来了，我们是一个电商网站，要做出一些活动，所以们这周会给3个月内未购买过产品的用户发电子邮件。这个任务包含了前端HTML和后端PHP的一些逻辑。</p></li>
<li><p>我们的网站要有一个法语的版本，所以我们在接下来的这两个星期会考虑我们的数据库设计。</p></li>
</ol>


<p>&hellip;（省略若干任务）</p>

<h4>周一下午</h4>

<p>IT部门的10个人聚集在会议室。打算做两件事情：</p>

<ol>
<li><p>讨论上周的任务完成情况，当然在一般的情况下，这些任务是都完成了的。Review一下成果。</p></li>
<li><p>讨论IT经理上午和总经理谈得任务，把每条任务进行逐行分解。并把任务平均分配到2个team上。接下来把任务打印出来。贴到白板上。正如上图所见，左面第一列的每一个方格子内是一系列相关的任务，这是打算是打算要这两个星期要做的事情。</p></li>
</ol>


<h3>周二上午10点</h3>

<p>每天上午，IT部门的10个人站在这块白班前面，把自己今天打算要做的任务纸条上写下自己的名字，然后挪动到中间的格子里。叙说一下我对这个任务的看法，打算怎么做，预估多长时间能够昨晚。</p>

<h3>周三上午</h3>

<p>每天早上10点，IT部的人都会站在这块白板前面，对写下名字的任务叙说3件事情：</p>

<ol>
<li>我昨天做了什么</li>
<li>我遇到了哪些困难</li>
<li>我今天打算做些什么</li>
</ol>


<h3>周四上午</h3>

<p>这里叙说一下为什么站在白板前面，而不是坐在会议室里，因为这样站着效率跟高效，10分钟就能够讨论结束。其实每天早上的这个会议叫做Sprint会议。</p>

<p>今天有人已经完成了任务，他会把任务纸条放在最右边的那栏里，表示任务已经完成。</p>

<h2>总结：</h2>

<p>OK, 这就是我执行了2年的SCRUM敏捷式开发的流程。我是一个执行者的流程来看待这件事件。它的优点：</p>

<ol>
<li>任务清楚，明确，一切围绕着目标。</li>
<li>中途加入的临时任务如果不是特别紧急、重要会安排到下周。</li>
</ol>


<p>缺点：
1. 每天时间满满的一个任务接着一个任务，时间久了会有些疲惫。</p>

<p>每一段工作任务都会会学到很多东西，把它记录下来，总结下来，为下一家公司发光发热。</p>

<p>这有一个网上的SCRUM可以看看<a href="http://home.leangoo.com/">leangoo</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何成为高级程序员]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/28/senior-programmer/"/>
    <updated>2015-08-28T08:00:02+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/28/senior-programmer</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>高级程序员都干些什么呢？怎样才能成为高级程序员呢？其实初级或刚入行的朋友喜欢问这样的问题。可能想把作为下一个奋斗的目标吧。下面是微信账号“威哥干Java”的看法。</p>

<p>一个项目好比画了两个圈，内外镶嵌，高级程序员负责内圈代码，初级程序员负责外圈代码。想要成为高级程序员，你就得往内圈挤。</p>

<p>从专业的角度上有三点：</p>

<ol>
<li>确定开发团队、技术路线和技术架构，为关键模块设计技术实现，能够满足长期发展的业务需要。</li>
<li>能参与系统调研，需求分析。负责概要设计、详细设计， 开发计划等编制并实施。负责核心内码通用模块功能实现，解决一些技术问题。</li>
<li>负责提升团队技术能力，协同项目经理进行项目开发，并实现重要的功能，指导和培养团队的成员。</li>
</ol>


<p>满足3个必备条件：</p>

<ol>
<li>具备看官方英文文档的能力。</li>
<li>上专业顶级的社区。</li>
<li>成为Github重度感染者。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[缓存]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/26/cache/"/>
    <updated>2015-08-26T16:26:59+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/26/cache</id>
    <content type="html"><![CDATA[<h3>缓存的类型</h3>

<ul>
<li>局域网缓存</li>
<li>网络缓存</li>
<li>硬盘缓存</li>
<li>内存缓存</li>
<li>数据库缓存</li>
<li>Opcode缓存</li>
<li>客户端浏览器缓存</li>
</ul>


<h3>opcode</h3>

<p>Opcode是一种PHP脚本编译后的中间语言</p>

<ul>
<li>opcache php5.5 默认安装</li>
<li>xcache  php5.4</li>
<li>php 5.2 zned optimization 被淘汰了。</li>
<li>wincache windows下</li>
<li>APC  PHP5.4  （PS: 上一家公司安装了APC）</li>
</ul>


<p>APCU xcache wincache 支持php API调用 （默认情况下 效率高于memcache）</p>

<h4>客户端浏览器缓存</h4>

<p>客户端缓存 （浏览器缓存） 静态资源引用公共服务器资源</p>

<p>把图片放在多个域名下，可以多线程加载图片 例如pc1.domain.com pc2.domain.com</p>

<p>xxx.com/abc.js?t=1234343 开发测试的时候，用这种方法防止浏览器缓存。给静态资源加时间戳带尾巴。</p>

<p>在发行产品的时候带版本号。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[水平分表]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/26/fen-biao/"/>
    <updated>2015-08-26T16:21:34+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/26/fen-biao</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>学习分库、分表的一记录，后期整理，添加示例。</p>

<h1>正文</h1>

<p>数据库分表与分库的实现方法：</p>

<p>tb_user_0  &hellip; tb_user_1 &hellip;.tb_user_2 &hellip;. tb_user_3</p>

<hr />

<p>当多张表具有完全相同的数据结构时，我们认为这些表示对一个实体数据的横向切分。</p>

<p>每张表都可以有自己的id
但是所有切分出来的表必须具备全局uid
分表后要按照某个元素（通常全局id）进行某种算法的计算，得到表后缀。</p>

<p>id生成器。（用redis做id在断电的情况下有风险），通常用mysql</p>

<p>uuid 得到一个字符串</p>

<p>自建索引</p>

<p>当数据库大了，分表是必然的。分表之后，建索引是必然的。</p>

<p>将全局id进行一次md5将得到一个由16进制数值组成的32位字符串。 数据越多越均匀。分成15张表，</p>

<p>或分成256张表。</p>

<p>分成80张： FF = 255 255%80 取余数。分多少张表，就余多少。</p>

<hr />

<p>如果只是做简单切分的时候后，我们会遇到问题：</p>

<ol>
<li>当我们需要将这些数据进行统计与分析的时候，不能使用聚合函数</li>
<li><p>当我们查询某条数据时，我们必须要知道我要查询的数据在哪一张表里，否则我就需要查询所有的表来查找结果。</p></li>
<li><p>当我插入数据的时候，我必须尽可能的让每张表的负载均匀</p></li>
<li>当我要修改数据的时候，我必须明确我要修改的数据在哪里。</li>
</ol>


<p>在不同的时期分表，会产生不同的问题。</p>

<ol>
<li>项目启动阶段就进行分表</li>
<li>项目启动阶段没有分表，而是在项目进行到积累了一定数据量以后再进行分表</li>
<li>项目之前就进行切分过表，但是被切分后的表经过长时间运行，又产生了大量数据，需要再次分表</li>
</ol>


<p>。</p>

<p>合理的分表不单单能解决单张表数据量过大的问题，还能优化我们的业务逻辑。</p>

<p>tb_product_store_sh
tb_product_store_bj
tb_product_store_hubei</p>

<p>基于区域位置的分表，非常适合做类似库存，商户信息，工商管理等有着明显区域性的数据分表。</p>

<p>基于IP地址的分表， 用于统计与分析数据。访问日志。
（几十万的数据开始考虑分表。）
当数据达到100多万的时候，就要考虑分表。</p>

<p>按时间分表，
日志。
财务报表。
绩效考核。</p>

<p>工资流水、销售业绩、出纳凭证等记录，按年份来分表。</p>

<p>考勤记录  销售业绩
个人考勤记录 签单记录  按月分表比较适合</p>

<p>季度、半年度、部门业绩 工资资产 等</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL主从配置及读写分离]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/23/mysql-master-slave/"/>
    <updated>2015-08-23T21:53:41+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/23/mysql-master-slave</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>以前在公司的时候，公司配了MySQL主从，在线上用PHPMyAdmin查看从库信息，但只给了读权限，用于查看线上信息。今天记录一下MySQL主从的搭建过程。（我使用的是MariaDb5.5）</p>

<h2>Notice</h2>

<p>在用户不多、并发不大、mysql服务器在同一个局域网内，MySQL主从是没有问题的。</p>

<p>主从数据库缺点：</p>

<ol>
<li>因为开启了bin log日志，所以会有性能开销。</li>
<li>在实时性非常高的情况下，做了读写分离就不行。因为单线程同步需要花时间，时间上不允许。</li>
</ol>


<h1>MySQL主从配置</h1>

<ol>
<li>mysql的版本相同， mysql主从同源，即具有相同的库、表及记录。</li>
<li>数据迁移的时候，从库的版本高于主库。</li>
<li><p>把主库从库都停掉。因为打包主库的时候会花很长时间，这时如果主库还有文件写入，很容易出错。</p>

<p> cd /var/lib/
 tar zcvf mysql.tar.gz ./mysql</p>

<p> scp mysql.tar.gz vagrant@192.168.33.10:/tmp</p></li>
<li><p>配置/etc/mysql/my.cnf</p>

<p> server-id               = 1
 log_bin                 = /var/log/mysql/mysql-bin.log
 expire_logs_days        = 10
 max_binlog_size         = 100M      每个bin log文件最大的大小</p></li>
</ol>


<p>开启log_bin日志，性能就会降低。没修改一条数据，就会写入文件。硬盘不大的情况下，会写满数据库</p>

<p>要放到msyql有权限的目录里。</p>

<p>我们的目的是用从库修复主库。
靠从库的bin_log来恢复主机。</p>

<p>写bin_log性能降低，但因为我们做了主从，我们靠读多个从库来提高并发量。</p>

<p>让从库能够通过tcp 来连接主库，
5. 为从库专门准备一个用户。</p>

<pre><code>create user 'slave_1'@'%' IDENTIFIED BY 'abcd' ;
grant replication slave  on *.* to 'slave_1'@'%';
或者一条命令
GRANT REPLICATION SLAVE ON *.* to 'mysync'@'%' identified by 'q123456'; 
</code></pre>

<ol>
<li><p>通过  SHOW MASTER STATUS; 显示当前主库的binlog文件与文件位置，我们需要将这个位置记录下来</p>

<p>   SHOW MASTER STATUS;</p></li>
</ol>


<p>连接到从库   开启主从同步</p>

<pre><code>CHANGE MASTER TO MASTER_HOST = '192.168.33.12' ,MASTER_USER='slave_2' ,MASTER_PASSWORD = '1234' ,MASTER_LOG_FILE ='mysql-bin.000002', MASTER_LOG_POS=973
</code></pre>

<p> 不想同步系统库可以选择忽略系统库</p>

<pre><code>binlog_ignore_db        = mysql
</code></pre>

<p>SALVE命令</p>

<pre><code>START SLAVE
STOP  SLAVE
SHOW SLAVE STATUS\G
</code></pre>

<p>我在安装的时候遇到的错误：
<a href="http://serverfault.com/questions/586651/mysql-refuses-to-accept-remote-connections">MySQL refuses to accept remote connections</a></p>

<p>解决方法：</p>

<pre><code>sudo netstat -ntlup | grep mysql
tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN      127018/mysqld
</code></pre>

<p>修改/etc/mysql/my.cnf</p>

<pre><code>bind-address = 0.0.0.0
</code></pre>

<h1>读写分离</h1>

<p>主库创建新用户</p>

<pre><code>GRANT all privileges  ON tiny.* to 'michael'@'%' identified by '1234'; 
flush privileges;
</code></pre>

<p>从库创建新用户，只给读的权限。</p>

<pre><code>GRANT SELECT  ON tiny.* to 'michael2'@'%' identified by '1234'; 

flush privileges;
</code></pre>

<h3>代码</h3>

<p>代码我放到了我的GitHub上，我自己写了一个MVC的简易框架。这样，框架的任何一个部分我都了解，大大节约了我写代码示例的时间。然后学习优秀框架的思想，继续维护我的框架。</p>

<p><a href="https://github.com/hildalove/tiny/blob/master/Tiny/Proxy/Proxy.php">代理模式</a></p>

<p><a href="https://github.com/hildalove/tiny/blob/master/Tiny/Service/Factory.php">获取数据库实例</a></p>

<p><a href="https://github.com/hildalove/tiny/blob/master/App/Controller/Mysql.php">控制器</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[转]PHP程序员的技术成长规划]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/23/php-develop/"/>
    <updated>2015-08-23T21:32:55+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/23/php-develop</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>按照了解的很多PHP/LNMP程序员的发展轨迹，结合个人经验体会，抽象出很多程序员对未来的迷漫，特别对技术学习的盲目和慌乱，简单梳理了这个每个阶段PHP程序员的技术要求，来帮助很多PHP程序做对照设定学习成长目标。</p>

<p>本文按照目前主流技术做了一个基本的梳理，整个是假设PHP程序员不是基础非常扎实的情况进行的设定，并且所有设定都非常具体明确清晰，可能会让人觉得不适，请理解仅代表一家之言。（未来技术变化不在讨论范围）</p>

<h1>第一阶段：基础阶段（基础PHP程序员）</h1>

<p><strong>重点</strong>：把LNMP搞熟练（核心是安装配置基本操作）</p>

<p><strong>目标</strong>：能够完成基本的LNMP系统安装，简单配置维护；能够做基本的简单系统的PHP开发；能够在PHP中型系统中支持某个PHP功能模块的开发。
时间：完成本阶段的时间因人而异，有的成长快半年一年就过了，成长慢的两三年也有。</p>

<h4>1.Linux：</h4>

<p>基本命令、操作、启动、基本服务配置（包括rpm安装文件，各种服务配置等）；会写简单的shell脚本和awk/sed 脚本命令等。</p>

<h4>2.Nginx：</h4>

<p>做到能够安装配置nginx+php，知道基本的nginx核心配置选项，知道 server/fastcgi_pass/access_log 等基础配置，目标是能够让nginx+php_fpm顺利工作。</p>

<h4>3.MySQL：</h4>

<p>会自己搭建mysql，知道基本的mysql配置选项；知道innodb和myisam的区别，知道针对InnoDB和MyISAM两个引擎的不同配置选项；知道基本的两个引擎的差异和选择上面的区别；能够纯手工编译搭建一个MySQL数据库并且配置好编码等正常稳定运行；核心主旨是能够搭建一个可运行的MySQL数据库。</p>

<h4>4.PHP：</h4>

<p>基本语法数组、字符串、数据库、XML、Socket、GD/ImageMgk图片处理等等；熟悉各种跟MySQL操作链接的api（mysql/mysqli/PDO)，知道各种编码问题的解决；知道常规熟练使用的PHP框架（ThinkPHP、Zendframework、Yii、Yaf等）；了解基本MVC的运行机制和为什么这么做，稍微知道不同的PHP框架之间的区别；能够快速学习一个MVC框架。能够知道开发工程中的文件目录组织，有基本的良好的代码结构和风格，能够完成小系统的开发和中型系统中某个模块的开发工作。</p>

<h4>5.前端：</h4>

<p>如果条件时间允许，可以适当学习下 HTML/CSS/JS 等相关知识，知道什么web标准，div+css的web/wap页面模式，知道HTML5和HTML4的区别；了解一些基本的前端只是和JS框架（jQuery之类的）；了解一些基本的JavaScript编程知识；（本项不是必须项，如果有时间，稍微了解一下是可以的，不过不建议作为重点，除非个人有强烈兴趣）</p>

<h4>6.系统设计：</h4>

<p>能够完成小型系统的基本设计，包括简单的数据库设计，能够完成基本的：浏览器 -> Nginx+PHP -> 数据库 架构的设计开发工作；能够支撑每天几十万到数百万流量网站的开发维护工作；</p>

<h1>第二阶段：提高阶段 （中级PHP程序员）</h1>

<p><strong>重点</strong>：提高针对LNMP的技能，能够更全面的对LNMP有熟练的应用。</p>

<p><strong>目标</strong>：能够随时随地搭建好LNMP环境，快速完成常规配置；能够追查解决大部分遇到的开发和线上环境的问题；能够独立承担中型系统的构架和开发工作；能够在大型系统中承担某个中型模块的开发工作；</p>

<h4>1. Linux:</h4>

<p>在第一阶段的基础上面，能够流畅的使用Shell脚本来完成很多自动化的工作；awk/sed/perl 也操作的不错，能够完成很多文本处理和数据统计等工作；基本能够安装大部分非特殊的Linux程序（包括各种库、包、第三方依赖等等，比如MongoDB/Redis/Sphinx/Luncene/SVN之类的）；了解基本的Linux服务，知道如何查看Linux的性能指标数据，知道基本的Linux下面的问题跟踪等。</p>

<h4>2. Nginx:</h4>

<p>在第一阶段的基础上面，了解复杂一些的Nginx配置；包括 多核配置、events、proxy_pass，sendfile/tcp_*配置，知道超时等相关配置和性能影响；知道nginx除了web server，还能够承担代理服务器、反向静态服务器等配置；知道基本的nginx配置调优；知道如何配置权限、编译一个nginx扩展到nginx；知道基本的nginx运行原理（master/worker机制，epoll），知道为什么nginx性能比apache性能好等知识；</p>

<h4>3. MySQL/MongoDB：</h4>

<p>在第一阶段的基础上面，在MySQL开发方面，掌握很多小技巧，包括常规SQL优化（group by/order by/rand优化等）；除了能够搭建MySQL，还能够冷热备份MySQL数据，还知道影响innodb/myisam性能的配置选项（比如key_buffer/query_cache/sort_buffer/innodb_buffer_pool_size/innodb_flush_log_at_trx_commit等），也知道这些选项配置成为多少值合适；另外也了解一些特殊的配置选项，比如  知道如何搭建mysql主从同步的环境，知道各个binlog_format的区别；知道MySQL的性能追查，包括slow_log/explain等，还能够知道基本的索引建立处理等知识；原理方面了解基本的MySQL的架构（Server+存储引擎），知道基本的InnoDB/MyISAM索引存储结构和不同（聚簇索引，B树）；知道基本的InnoDB事务处理机制；了解大部分MySQL异常情况的处理方案（或者知道哪儿找到处理方案）。条件允许的情况，建议了解一下NoSQL的代表MongoDB数据库，顺便对比跟MySQL的差别，同事能够在合适的应用场景安全谨慎的使用MongoDB，知道基本的PHP与MongoDB的结合开发。</p>

<h4>4. Redis/Memcached：</h4>

<p>在大部分中型系统里面一定会涉及到缓存处理，所以一定要了解基本的缓存；知道Memcached和Redis的异同和应用场景，能够独立安装 Redis/Memcached，了解Memcahed的一些基本特性和限制，比如最大的value值，知道PHP跟他们的使用结合；Redis了解基本工作原理和使用，了解常规的数据类型，知道什么场景应用什么类型，了解Redis的事务等等。原理部分，能够大概了解Memcached的内存结构（slab机制），redis就了解常用数据类型底层实现存储结构（SDS/链表/SkipList/HashTable）等等，顺便了解一下Redis的事务、RDB、AOF等机制更好</p>

<h4>5. PHP：</h4>

<p>除了第一阶段的能力，安装配置方面能够随意安装PHP和各种第三方扩展的编译安装配置；了解php-fpm的大部分配置选项和含义（如max_requests/max_children/request_terminate_timeout之类的影响性能的配置），知道mod_php/fastcgi的区别；在PHP方面已经能够熟练各种基础技术，还包括各种深入些的PHP，包括对PHP面向对象的深入理解/SPL/语法层面的特殊特性比如反射之类的；在框架方面已经阅读过最少一个以上常规PHP MVC框架的代码了，知道基本PHP框架内部实现机制和设计思想；在PHP开发中已经能够熟练使用常规的设计模式来应用开发（抽象工厂/单例/观察者/命令链/策略/适配器 等模式）；建议开发自己的PHP MVC框架来充分让开发自由化，让自己深入理解MVC模式，也让自己能够在业务项目开发里快速升级；熟悉PHP的各种代码优化方法，熟悉大部分PHP安全方面问题的解决处理；熟悉基本的PHP执行的机制原理（Zend引擎/扩展基本工作机制）；</p>

<h4>6. C/C++：</h4>

<p>开始涉猎一定的C/C++语言，能够写基本的C/C++代码，对基本的C/C++语法熟悉（指针、数组操作、字符串、常规标准API）和数据结构（链表、树、哈希、队列）有一定的熟悉下；对Linux下面的C语言开发有基本的了解概念，会简单的makefile文件编写，能够使用简单的GCC/GDB的程序编译简单调试工作；对基本的网络编程有大概了解。（本项是为了向更高层次打下基础）</p>

<h4>7. 前端：</h4>

<p>在第一阶段的基础上面，熟悉基本的HTTP协议（协议代码200/300/400/500，基本的HTTP交互头）；条件允许，可以在深入写出稍微优雅的HTML+CSS+JavaScript，或者能够大致简单使用某些前端框架（jQuery/YUI/ExtJS/RequireJS/BootStrap之类）；如果条件允许，可以深入学习JavaScript编程，比如闭包机制、DOM处理；再深入些可以读读jQuery源码做深入学习。（本项不做重点学习，除非对前端有兴趣）</p>

<h4>8. 系统设计：</h4>

<p>能够设计大部分中型系统的网站架构、数据库、基本PHP框架选型；性能测试排查处理等；能够完成类似：浏览器 -> CDN(Squid) -> Nginx+PHP -> 缓存 -> 数据库 结构网站的基本设计开发维护；能够支撑每天数百万到千万流量基本网站的开发维护工作；</p>

<h1>第三阶段：高级阶段 （高级PHP程序员）</h1>

<p><strong>重点</strong> ：除了基本的LNMP程序，还能够在某个方向或领域有深入学习。（纵深维度发展）</p>

<p><strong>目标</strong>：除了能够完成基本的PHP业务开发，还能够解决大部分深入复杂的技术问题，并且可以独立设计完成中大型的系统设计和开发工作；自己能够独立hold深入某个技术方向，在这块比较专业。（比如在MySQL、Nginx、PHP、Redis等等任一方向深入研究）</p>

<h4>1. Linux：</h4>

<p>除了第二阶段的能力，在Linux下面除了常规的操作和性能监控跟踪，还能够使用很多高级复杂的命令完成工作（watch/tcpdump/starce/ldd/ar等)；在shell脚本方面，已经能够编写比较复杂的shell脚本（超过500行）来协助完成很多包括备份、自动化处理、监控等工作的shell；对awk/sed/perl 等应用已经如火纯青，能够随意操作控制处理文本统计分析各种复杂格式的数据；对Linux内部机制有一些了解，对内核模块加载，启动错误处理等等有个基本的处理；同时对一些其他相关的东西也了解，比如NFS、磁盘管理等等；</p>

<h4>2. Nginx:</h4>

<p>在第二阶段的基础上面，已经能够把Nginx操作的很熟练，能够对Nginx进行更深入的运维工作，比如监控、性能优化，复杂问题处理等等；看个人兴趣，更多方面可以考虑侧重在关于Nginx工作原理部分的深入学习，主要表现在阅读源码开始，比如具体的master/worker工作机制，Nginx内部的事件处理，内存管理等等；同时可以学习Nginx扩展的开发，可以定制一些自己私有的扩展；同时可以对Nginx+Lua有一定程度的了解，看看是否可以结合应用出更好模式；这个阶段的要求是对Nginx原理的深入理解，可以考虑成为Nginx方向的深入专业者。</p>

<h4>3. MySQL/MongoDB：</h4>

<p>在第二阶段的基础上面，在MySQL应用方面，除了之前的基本SQL优化，还能够在完成一些复杂操作，比如大批量数据的导入导出，线上大批量数据的更改表结构或者增删索引字段等等高危操作；除了安装配置，已经能够处理更多复杂的MySQL的问题，比如各种问题的追查，主从同步延迟问题的解决、跨机房同步数据方案、MySQL高可用架构等都有涉及了解；对MySQL应用层面，对MySQL的核心关键技术比较熟悉，比如事务机制（隔离级别、锁等）、对触发器、分区等技术有一定了解和应用；对MySQL性能方面，有包括磁盘优化（SAS迁移到SSD）、服务器优化（内存、服务器本身配置）、除了二阶段的其他核心性能优化选项（innodb_log_buffer_size/back_log/table_open_cache/thread_cache_size/innodb_lock_wait_timeout等）、连接池软件选择应用，对show *（show status/show profile）类的操作语句有深入了解，能够完成大部分的性能问题追查；MySQL备份技术的深入熟悉，包括灾备还原、对Binlog的深入理解，冷热备份，多IDC备份等；在MySQL原理方面，有更多了解，比如对MySQL的工作机制开始阅读部分源码，比如对主从同步（复制）技术的源码学习，或者对某个存储引擎（MyISAM/Innodb/TokuDB）等等的源码学习理解，如果条件允许，可以参考CSV引擎开发自己简单的存储引擎来保存一些数据，增强对MySQL的理解；在这个过程，如果自己有兴趣，也可以考虑往DBA方向发展。MongoDB层面，可以考虑比如说在写少读多的情况开始在线上应用MongoDB，或者是做一些线上的数据分析处理的操作，具体场景可以按照工作来，不过核心是要更好的深入理解RMDBS和NoSQL的不同场景下面的应用，如果条件或者兴趣允许，可以开始深入学习一下MongoDB的工作机制。</p>

<h4>4. Redis/Memcached：</h4>

<p>在第二阶段的基础上面，能够更深入的应用和学习。因为Memcached不是特别复杂，建议可以把源码进行阅读，特别是内存管理部分，方便深入理解；Redis部分，可以多做一些复杂的数据结构的应用（zset来做排行榜排序操作/事务处理用来保证原子性在秒杀类场景应用之类的使用操作）；多涉及aof等同步机制的学习应用，设计一个高可用的Redis应用架构和集群；建议可以深入的学习一下Redis的源码，把在第二阶段积累的知识都可以应用上，特别可以阅读一下包括核心事件管理、内存管理、内部核心数据结构等充分学习了解一下。如果兴趣允许，可以成为一个Redis方面非常专业的使用者。</p>

<h4>5. PHP：</h4>

<p>作为基础核心技能，我们在第二阶段的基础上面，需要有更深入的学习和应用。从基本代码应用上面来说，能够解决在PHP开发中遇到95%的问题，了解大部分PHP的技巧；对大部分的PHP框架能够迅速在一天内上手使用，并且了解各个主流PHP框架的优缺点，能够迅速方便项目开发中做技术选型；在配置方面，除了常规第二阶段会的知识，会了解一些比较偏门的配置选项（php auto_prepend_file/auto_append_file），包括扩展中的一些复杂高级配置和原理（比如memcached扩展配置中的memcache.hash_strategy、apc扩展配置中的apc.mmap_file_mask/apc.slam_defense/apc.file_update_protection之类的）；对php的工作机制比较了解，包括php-fpm工作机制（比如php-fpm在不同配置机器下面开启进程数量计算以及原理），对zend引擎有基本熟悉（vm/gc/stream处理），阅读过基本的PHP内核源码（或者阅读过相关文章），对PHP内部机制的大部分核心数据结构（基础类型/Array/Object）实现有了解，对于核心基础结构（zval/hashtable/gc）有深入学习了解；能够进行基本的PHP扩展开发，了解一些扩展开发的中高级知识（minit/rinit等），熟悉php跟apache/nginx不同的通信交互方式细节（mod_php/fastcgi）；除了开发PHP扩展，可以考虑学习开发Zend扩展，从更底层去了解PHP。</p>

<h4>6. C/C++：</h4>

<p>在第二阶段基础上面，能够在C/C++语言方面有更深入的学习了解，能够完成中小型C/C++系统的开发工作；除了基本第二阶段的基础C/C++语法和数据结构，也能够学习一些特殊数据结构（b-tree/rb-tree/skiplist/lsm-tree/trie-tree等）方便在特殊工作中需求；在系统编程方面，熟悉多进程、多线程编程；多进程情况下面了解大部分多进程之间的通信方式，能够灵活选择通信方式（共享内存/信号量/管道等）；多线程编程能够良好的解决锁冲突问题，并且能够进行多线程程序的开发调试工作；同时对网络编程比较熟悉，了解多进程模型/多线程模型/异步网络IO模型的差别和选型，熟悉不同异步网络IO模型的原理和差异（select/poll/epoll/iocp等），并且熟悉常见的异步框架（ACE/ICE/libev/libevent/libuv/Boost.ASIO等）和使用，如果闲暇也可以看看一些国产自己开发的库（比如muduo）；同时能够设计好的高并发程序架构（leader-follow/master-worker等）；了解大部分C/C++后端Server开发中的问题（内存管理、日志打印、高并发、前后端通信协议、服务监控），知道各个后端服务RPC通信问题（struct/http/thirft/protobuf等）；能够更熟络的使用GCC和GDB来开发编译调试程序，在线上程序core掉后能够迅速追查跟踪解决问题；通用模块开发方面，可以积累或者开发一些通用的工具或库（比如异步网络框架、日志库、内存池、线程池等），不过开发后是否应用要谨慎，省的埋坑去追bug；</p>

<h4>7. 前端：</h4>

<p>深入了解HTTP协议（包括各个细致协议特殊协议代码和背后原因，比如302静态文件缓存了，502是nginx后面php挂了之类的）；除了之前的前端方面的各种框架应用整合能力，前端方面的学习如果有兴趣可以更深入，表现形式是，可以自己开发一些类似jQuery的前端框架，或者开发一个富文本编辑器之类的比较琐碎考验JavaScript功力；</p>

<h4>8. 其他领域语言学习：</h4>

<p>在基础的PHP/C/C++语言方面有基本积累，建议在当前阶段可以尝试学习不同的编程语言，看个人兴趣爱好，脚本类语言可以学学 Python/Ruby 之类的，函数式编程语言可以试试 Lisp/Haskell/Scala/Erlang 之类的，静态语言可以试试 Java/Golang，数据统计分析可以了解了解R语言，如果想换个视角做后端业务，可以试试 Node.js还有前面提到的跟Nginx结合的Nginx_Lua等。学习不同的语言主要是提升自己的视野和解决问题手段的差异，比如会了解除了进程/线程，还有轻量级协程；比如在跨机器通信场景下面，Erlang的解决方案简单的惊人；比如在不想选择C/C++的情况下，还有类似高效的Erlang/Golang可用等等；主要是提升视野。</p>

<h4>9. 其他专业方向学习：</h4>

<p>在本阶段里面，会除了基本的LNMP技能之外，会考虑一些其他领域知识的学习，这些都是可以的，看个人兴趣和长期的目标方向。目前情况能够选择的领域比较多，比如、云计算（分布式存储、分布式计算、虚拟机等），机器学习（数据挖掘、模式识别等，应用到统计、个性化推荐），自然语言处理（中文分词等），搜索引擎技术、图形图像、语音识别等等。除了这些高大上的，也有很多偏工程方面可以学习的地方，比如高性能系统、移动开发（Android/IOS）、计算机安全、嵌入式系统、硬件等方向。</p>

<ol>
<li>系统设计：
系统设计在第二阶段的基础之上，能够应用掌握的经验技能，设计出比较复杂的中大型系统，能够解决大部分线上的各种复杂系统的问题，完成类似 浏览器 -> CDN -> 负载均衡 ->接入层 -> Nginx+PHP -> 业务缓存 -> 数据库 -> 各路复杂后端RPC交互（存储后端、逻辑后端、反作弊后端、外部服务） -> 更多后端 酱紫的复杂业务；能够支撑每天数千万到数亿流量网站的正常开发维护工作。</li>
</ol>


<h1>第四阶段：架构阶段 （架构师）</h1>

<p>ps: 暂时不展开讨论，等下次专门撰文来描述补充本部分内容</p>

<p>第五阶段：专家阶段（方向领域专家）
ps：高大上，这块不展开讨论 ^_^</p>

<p>第六阶段：科学家阶段
ps：高大上，这块不展开讨论 ^_^</p>

<p>转载：<a href="http://blog.csdn.net/heiyeshuwu">黑夜路人</a>的博客</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant的网络设置]]></title>
    <link href="http://fenghan.github.io/blog/2015/08/22/vagrant-network/"/>
    <updated>2015-08-22T14:34:46+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/08/22/vagrant-network</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>今天要做Mysql主从配置，就需要两台Ubuntu的服务器，所以先要研究下Vagrant的网络配置。</p>

<p>Vagrant有三种网络配置</p>

<ol>
<li>Forwarded port</li>
<li>Private network</li>
<li>Public network</li>
</ol>


<h1>Private Network</h1>

<p>我的需求是两台Ubutu在同一网段，并且都访问主机和外部网络。所以我选择private network。 它的缺点是外部网络无法访问。</p>

<p>设定语法为：</p>

<pre><code>config.vm.network "private_network", ip: "192.168.50.4"
</code></pre>

<p>配置hostname</p>

<pre><code>config.vm.hostname = "master"
</code></pre>

<h1>参考链接</h1>

<p><a href="http://www.williamsang.com/archives/2401.html?utm_source=tuicool#private">Vagrant网络配置</a></p>
]]></content>
  </entry>
  
</feed>
