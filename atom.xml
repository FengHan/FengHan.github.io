<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[hanfeng.name]]></title>
  <link href="http://fenghan.github.io/atom.xml" rel="self"/>
  <link href="http://fenghan.github.io/"/>
  <updated>2015-07-26T15:54:51+08:00</updated>
  <id>http://fenghan.github.io/</id>
  <author>
    <name><![CDATA[HanFeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis的数据类型(一)]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/24/redis-data-type/"/>
    <updated>2015-07-24T14:54:30+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/24/redis-data-type</id>
    <content type="html"><![CDATA[<h4>Redis 的数据库内部结构</h4>

<pre><code>Redis中每个数据库，都是由一个redis.h/redisDb结构表示：
    typedef struct redisDb{
    int id: //保存着数据库以整数表示的号码
    dict *dict；   //保存着所有键值对数据，这个属性也被称为键空间（key space）
    dict *expires; //保存着键的过期信息
    dict *blocking_keys;    //实现列表阻塞原语，
    dict *watched_keys;     //用于实现WATCH命令
}redisDb
</code></pre>

<p>因为Redis是一个键值对数据库（key-value-pairs database）,所以它的数据库本身也是一个字典（俗称 key space）
- 字典的的键是一个<strong>字符串</strong>对象
- 字典的值可以是包括<strong>字符串、列表、哈希值、集合或有序集</strong>在内的任意一种Redis类型对象。</p>

<p>在 redisDb  结构的 dict  属性中，保存着数据库的所有键值对数据。
下图展示了一个包含 number 、book 、message 三个键的数据库—其中 number
 键是一个列表，列表中包含三个整数值；book  键是一个哈希表，表中包含三个键
值对；而 message  键则指向另一个字符串。</p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/redis_hash.jpg" alt="" /></p>

<ul>
<li>命令

<ul>
<li>Redis中的命令不区分大小写，SET与set效果一样。</li>
</ul>
</li>
<li>主键（key）

<ul>
<li>可以用任何二进制序列作为key值，从形如“foo”的简单字符串到一个JPEG文件的内容都可以。空字符串也是有效的key值。</li>
</ul>
</li>
<li>关于key的规则

<ul>
<li>可以用任何二进制序列作为key值</li>
<li>格式约定： object-type:id:field</li>
<li>不用太长的键值。不仅消耗内存，而且在数据查找中计算成本很高。</li>
<li>太短的键值通常也不是好主意，可读性差。

<ul>
<li>如用“user:1000:password”来代替“u:1000:pwd”</li>
</ul>
</li>
</ul>
</li>
</ul>


<h4>Redis 的 String 类型的底层实现与操作命令</h4>

<p>String是Redis最基本的类型，而且String类型是二进制安全的。意思是Redis的String可以包含任何数据。比如jpg图片或者序列化对象。从内部实现来看其实String可以看做byte数组，最大上限是1G字节。下面是String类型的定义。</p>

<pre><code>struct sdshdr{
    long len;   //len是buf数组的长度
    long free;  //free是数组中剩余可用字节数
    char buf[]; //char数组用于贮存实际的字符串内容
}String;
</code></pre>

<p>新增相关命令</p>

<pre><code>Set
语法：set key value
解释：把值value赋给key，如果key不存在，新增；否则，更新。
Setnx
语法：setnx  key  value
解释：只 insert 不 update，即，仅仅key不存在时，则设置key的值为value，并返回1，否则返回0  。setnx 是set if not exists 的缩写。
Setex
语法： setex key secondes value
解释： 设置KEY的过期时间和值。过期时间seconds单位是秒。设置过期时间和值是原子操作，如果redis仅仅当做缓存，这个命令很有用。
msetnx
语法：msetnx key value  [key value ...]
解释：所有key都不存在才执行set操作。
</code></pre>

<p>查询相关命令</p>

<pre><code>get
语法：get key
解释：获取key所set的值。
mget
语法： mget key [key]
解释：批量获取key的值。程序一次获取多个值，可以减少网络连接损耗。
getrange
语法：getrange  key star end
解释：获取存储在key中value的字串。字符串的截取有star和end决定，字符串的第一个字符编号是0，第二个是1，一次类推；如果是负数，-1是最后一个字符，-2是倒数第二个字符，一次类推。
</code></pre>

<p>修改相关命令</p>

<pre><code>getset
语法：getset key value
解释：设置key的值，并返回key的旧值。
append
语法：append key value
解释：key存在，在旧值的后面追加value；key不存在，直接set，返回长度。
setrange (替换部分子串)
语法：setrange  key offset value
解释：用value重写key值的一部分，偏移量由offset指定 。
Incr/decr
语法：incr/decr  key
解释：key中如果存储的是数字，则可以通过incr递增key的值，返回递增后的值。如果key不能存在，视为初始值为0。
Incrby/decrby
语法：incrby key increment
解释：用指定的步长增加key存储的数字。如果步长increment是负数，则减。
注意：递增递减系列的函数，只能对保存的是数字的key操作，不能是字符串。
</code></pre>

<p>删除及其它命令</p>

<pre><code>del
语法：del key [key]
解释：删除指定的key，返回删除key的个数。
</code></pre>

<p>长度</p>

<pre><code>strlen
语法：strlen key
解释：获取key中所存储值的长度。
</code></pre>

<p>场景案例</p>

<pre><code>案例：博客系统的设计与开发
需求与实现
文章的访问量：定义键 post:articleID:pageView，通过INCR命令递增
自增ID：定义键article:count，通过INCR递增
存储文章的数据：伪代码如下
首先获得新文章的ID
              $postID = INCR posts:count
将博客文章的诸多元素序列化成字符串
              $serializedPost = serialize($title,$content,$author,$time)
把序列化后的字符串存入一个字符串类型的键中
              SET post:$postID:data,$serializedPost
获取文章数据的伪代码
从Redis中读取文章的数据
              $serializePost=GET post:42:data
将文章数据反序列化成文章的各个元素
               $title,$content,$author,$time = unserialize($serializePost)
获取并递增文章的访问量
              $count=INCR post:42:pageView

post:count        最后一次的文章ID
post:42:data      序列化存储文章数据
post:42:pageView  文章访问量

组合使用多个字符串类型键来存储文章数据
Post:42:title   第一篇日志
Post:42:author  Michael
Post:42:content 今天下雨了
Post:42:time    2015-07-26
</code></pre>

<h4>Redis 的 Hash 类型的底层实现与操作命令</h4>

<p>Redis hash 是一个 string 类型的 field 和 value 的映射表，一个 key 可对应多个
field，一个 field 对应一个value。可以将 Redis 中的 Hash 类型看成具有 String
Key 和 String  Value 的 map容器。将一个对象存储为 Hash 类型，较于每个字段
都存储成 string 类型更能节省内存。每一个Hash可以存储2的32次幂 -1个键值对。</p>

<p>Hash 对应 Value 内部实际就是一个 HashMap，实际这里会有2种不同实现，这个
Hash的成员比较少时 Redis 为了节省内存会采用类似一维数组的方式来紧凑存储即
zipmap（压缩列表），而不会采用真正的 HashMap 结构，对应的value
redisObject 的 encoding为 zipmap，当成员数量增大时会自动转成真正的
HashMap,此时 encoding 为ht。
<img src="http://7xkc1x.com1.z0.glb.clouddn.com/struct_hash.png" alt="" />
dict.h/dict 给出了这个字典的定义：</p>

<pre><code>Typedef  struct  dict {
 dictType *type;  // 特定于类型的处理函数
 void *privdata;  // 类型处理函数的私有数据
 dictht ht[2];       // 哈希表（2 个）
 int rehashidx;  // 记录rehash 进度的标志，值为-1 表示rehash 未进行
 int iterators;    // 当前正在运作的安全迭代器数量
} dict;
</code></pre>

<p>字典所使用的哈希表实现由 dict.h/dictht 类型定义：</p>

<pre><code>typedef struct dictht {
     dictEntry  **table; // 哈希表节点指针数组（俗称桶，bucket）
     unsigned long size; // 指针数组的大小
     unsigned long sizemask; // 指针数组的长度掩码，用于计算索引值
     unsigned long used; // 哈希表现有的节点数量
  } dictht;
</code></pre>

<p>dictEntry 都保存着一个键值对，以及一个指向另一个 dictEntry 结构的指针:</p>

<pre><code>typedef struct dictEntry {
  void *key;// 键
  union {
     void *val;   …
    } v; // 值
  struct dictEntry *next;// 链往后继节点
} dictEntry;
</code></pre>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/redis_hash_struct_pic.png" alt="" /></p>

<p>新增相关命令</p>

<pre><code>hset
语法：hset key field value
解释：设置hash表key中的field的值。如果hash表不存在，则创建，并执行设置field的值，如果hash表存在，值field的值覆盖或新增。
hmset
语法：hash key  field  value[key value]
解释：批量设置hash表key的域。
hsetnx
语法：hsetnx key field value
解释：仅仅当field域不存在时，设置hash表field的值。
</code></pre>

<p>查询相关命令</p>

<pre><code>hget
语法：hget key field
解释：获取哈希表key的field值。
hmget
语法：hmget key
hgetall
语法：hgetall key
解释：获取hash表的所有域值。
hkeys
语法：hkeys key
解释：获取hash表的所有域。
hvals
语法：hvals key
解释：获取hash表的所有域值。
hexists
语法：hexists key field
解释：判断hash表中是否存在某个域。
</code></pre>

<p>修改相关命令</p>

<pre><code>hincrby

语法：hincrby key field increment
解释：hash表field域的数值增加步长increment，如果increment是负值，则是递减。如果域不存在，初始值视为0。
</code></pre>

<p>删除及其它命令</p>

<pre><code>hdel
语法：hdel key field[field]
解释：删除hash的域，如果指定多个field，则删除多个。
</code></pre>

<p>~</p>

<pre><code>hlen
语法：hlen key
解释：获取hash的域数量。
</code></pre>

<p>场景案例
<img src="http://7xkc1x.com1.z0.glb.clouddn.com/hash_post.jpg" alt="" /></p>

<h4>List概念与底层实现</h4>

<p>List是一个链表结构，主要功能是push、pop、获取一个范围的所有值等等，操作中key理解为链表的名字。Redis的list类型其实就是一个每个子元素都是string类型的双向链表。我们可以通过push、pop操作从链表的头部或者尾部添加删除元素， push和pop命令的算法时间复杂度都是O(1)，这样list既可以作为栈，又可以作为队列。链表的最大长度是2的32次幂-1。</p>

<h4>List常用操作命令</h4>

<p>LPUSH 与 LRANGE 命令</p>

<pre><code>LPUSH
语法：LPUSH  key   value
解释：用来向列表左边增加元素，返回值表示增加元素后列表的长度；LPUSH命令还支持同时增加多个元素。

LRANGE
语法：LRANGE  key   start  end
解释：用来获得列表中的某一片段，返回索引从 Start 到 end 之间的所有元素，索引从0开始。LRANGE 命令也支持负索引，-1表示最右边的元素，-2表示最右边倒数第2个元素。
</code></pre>

<p>RPUSH 与 LINSERT 命令</p>

<pre><code>RPUSH
语法：RPUSH  key   value
解释：用来向列表右边增加元素，返回值表示增加元素后列表的长度；RPUSH命令还支持同时增加多个元素。
LINSERT
语法：LINSERT  key   BEFORE | AFTER  pivot  value
解释：此命令首先会在列表中从左到右查找值为pivot的元素，然后根据第2个参数是BEFORE还是AFTER来决定将Value插入到前面还是后面。返回值是插入后元素的个数。
</code></pre>

<p>LPOP 与 RPOP 命令</p>

<pre><code>LPOP/RPOP
语法：LPOP/RPOP   key
解释：LPOP命令可以从列表左边弹出一个元素；RPOP从列表右边弹出一个元素。
LPOP和LPUSH配合，RPOP和RPUSH配合可以把列表当作栈使用；LPUSH和RPOP配合，RPUSH和LPOP配合可以把列表当作队列使用。
</code></pre>

<p>LREM 命令</p>

<pre><code>LREM
语法：LREM  key   count   value
解释：LREM 命令会删除列表中前 count 个值为value 的元素，返回值是实际删除的元素的个数。
当 count &gt;0时，从左边开始删除；
当 count &lt;0时，从右边开始删除；
当 count =0时，删除所有值为 value 的元素；
</code></pre>

<p>LTRIM 命令</p>

<pre><code>LTRIM
语法：LTRIM  key   start   end
解释：LTRIM 命令会删除列表中指定索引范围外的所有元素，返回值即指定索引内的元素。LTRIM 命令常和 LPUSH命令一起使用来限制列表中元素的数量，比如记录日志时我们希望只保留最近的100条记录，则每次添加日志时调用一次 LTRIM 命令即可。
</code></pre>

<p>RPOPLPUSH 命令</p>

<pre><code>RPOPLPUSH
语法：RPOPLPUSH  src   dest
解释：RPOPLPUSH 命令先从 src 列表的右边弹出一个元素，然后将其加入 dest 列表的左边，并返回这个元素的值。当把列表当作队列时，RPOPLPUSH 可以在多个队列中传递数据。当 src 与dest 相同时，此命令会不断的将队尾的元素移动到队首。
</code></pre>

<p>LINDEX 与 LSET命令</p>

<pre><code>LINDEX
语法：LINDEX  key  index
解释：LINDEX 命令用来返回指定索引的元素，索引从0开始。
LSET
语法：LSET key  index  value
解释：将索引为 index 的元素赋值为 value。
</code></pre>

<p>LLEN 命令</p>

<h4>List的应用场景</h4>

<pre><code>Redis list应用场景非常多,比如：
微博的关注列表
粉丝列表
博客评论
消息队列
取最新 N  个数据的操作
排行榜应用，取 TOP  N 操作
</code></pre>

<p>String 类型存储文章 ID 的弊端:</p>

<pre><code>如何获取文章列表
读取 post:count 键获得博客文章的最大 ID
根据 ID 进行分页（假设每页10条），第 n 页的文章 ID 范围是“最大的文章ID-(n-1)*10”到“max(最大的文章 ID – n*10+1,1)”
对每个ID使用HMGET命令来获取文章的数据，伪代码如下：

# 每页显示10篇文章
$postsPerPage  = 10
# 获得最后发表的文章 ID
$lastPostID = GET posts:count
# 当前页码范围
$start = $lastPostID – ($currentPage - 1) * $postsPerPage
$end = max( $lastPostID – $currentPage  * $postsPerPage +1，1)

# 遍历文章 ID 获取数据
For $i = $start down to $end
# 获取文章的标题和作者并打印出来
post = HMGET post:$i，title，author
         Print $post[0]
         Print $post[1]
缺点：删除文章时影响页码分布，都需要从最大文章 ID 开始遍历
</code></pre>

<p>List 类型存储文章 ID</p>

<pre><code>使用列表类型键 posts:list 记录文章 ID
LPUSH posts:list  文章ID
LREM    posts:list  1  文章 ID
# 使用 LRANGE 实现分页
$postsPerPage  = 10
$start =  ($currentPage - 1) * $postsPerPage
$end =  $currentPage  * $postsPerPage  - 1
$postsID = LRANGE posts:list，$start，$end

# 获取需要显示文章的 ID 列表
For   each   $id   in   $postsID
          $post = HGETALL post:$id
           print  文章标题：$post.title
</code></pre>

<p>缺点： 文档内容较多的时候，访问中间的内容性能比较差。因为LIST是通过链表实现的，所以访问中间元素时，效率不高； 解决方法，使用有序集合来存储文章ID.</p>

<p>List 类型存储文章评论</p>

<pre><code># 使用列表类型键post：文章 ID：comments来存储文章的评论
$serializedComment = serialize($author，$email，$time，$content)
LPUSH  post:42:comments，$serializedComment
读取评论时使用 LRANGE 命令
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis的安装与配置]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/24/redis_setup_config/"/>
    <updated>2015-07-24T10:36:56+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/24/redis_setup_config</id>
    <content type="html"><![CDATA[<h1>Redis 的历史与特性</h1>

<p>Redis 是Remote Dictionary Server的缩写，Redis是一个<strong>开源、基于C语言、基于内存可持久化</strong>的高性能NoSQL的<strong>键值对</strong>数据库。在众多场合中均可使用Redis代替传统的数据库或缓存系统。</p>

<p>与Memcache类似的NoSQL型数据库，但它的数据可以持久化的保存在磁盘上，解决了服务重启后数据不丢失的问题。</p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/show_redis.jpg" alt="" /></p>

<p>2015年Redis3.0.1 发布
    Redis 3.0 最重要的特征是对Redis集群的支持
Redis约定<strong>次版本号</strong>为偶数的版本是稳定版</p>

<p>主要特性：</p>

<ul>
<li>存储结构丰富</li>
<li>内存存储与持久化： 1s内读写10万个键值，异步写入硬盘；</li>
<li>功能丰富：可用于数据库，缓存系统，队列</li>
<li>简单稳定</li>
</ul>


<h1>安装</h1>

<p>安装最新版本的3.0， <a href="http://redis.io/download">http://redis.io/download</a></p>

<pre><code>apt-get install make gcc
wget http://download.redis.io/releases/redis-3.0.3.tar.gz
tar xzf redis-3.0.3.tar.gz
cd redis-3.0.3/src
make install
</code></pre>

<h3>Redis可执行文件</h3>

<p>redis-cli  #客户端
redis-server #服务器</p>

<pre><code>ls /usr/local/bin/redis*

cd ..
mkdir /etc/redis
cp redis.conf /etc/redis/6379.conf

cd utils/
cp redis_init_script /etc/init.d/redisd

sudo update-rc.d redisd defaults
service redisd start
</code></pre>

<h3>启动方法</h3>

<ol>
<li>redis-server&amp;

<ul>
<li>ps -ef |grep redis 检测后台进程是否存在</li>
<li>netstat -tunpl |grep 6379  检测6379端口是否在监听</li>
<li>redis-cli检测， shutdown退出</li>
</ul>
</li>
<li><p>指定配置文件启动</p>

<p> redis-server /usr/local/redis/etc/redis.conf</p>

<p> 修改配置文件 daemonize yes</p></li>
<li><p>使用Redis启动脚本设置开机启动</p></li>
</ol>


<p>启动脚本位于redis_init_script位于安装目录的/utils目录下，</p>

<pre><code>-   新建目录/etc/redis
-   复制redis.conf到/etc/redis/重命名为6379.conf
-   修改6379.conf配置
-   复制redis_init_script脚本文件复制到/etc/init.d目录中，并重命名redisd
-   执行随系统自动启动命令 
    -   sudo update-rc.d redisd defaults
    -   service redisd start
</code></pre>

<h3>停止方法</h3>

<ol>
<li>退出客户端用CTRL + C</li>
<li>在客户端下，执行SHUTDOWN，停止服务</li>
<li>kill -9 PID</li>
</ol>


<h3>redis 的配置</h3>

<p>redis.conf #redis server的配置文件</p>

<p>sentinel.conf #redis sentine配置文件，用于监控</p>

<ul>
<li>基本项配置</li>
<li><strong>持久化（Persistence）</strong>相关配置</li>
<li><strong>Replication配置</strong></li>
<li>Security配置</li>
<li>Limit配置</li>
<li>SlowLog配置</li>
<li>Advanced配置</li>
<li>INCLUEDS配置

<h5>基本配置</h5></li>
<li>daemonize 如果需要在后台运行，把该项改为yes</li>
<li>pidfile 配置多个pid地址， 默认在/var/run/redis.pid</li>
<li>bind  绑定ip， 设置后只接受来自该ip的请求</li>
<li>port 监听端口，默认6379</li>
<li>timeout 设置客户端连接的超时时间，单位为秒</li>
<li>loglevel分为4级， debug， verbose, notice, warning</li>
<li>logfile 配置log文件地址</li>
</ul>


<p>总结: 上述配置基本项中，port为必配项，其余项一般情况下保持默认即可。</p>

<h5>持久化配置项目</h5>

<ul>
<li>databases 设置数据库的个数， 默认使用的数据库为0</li>
<li>save 设置redis进行数据库镜像的频率</li>
<li>rdbcompression 在进行镜像备份时，是否进行压缩</li>
<li>Dbfilename 镜像备份文件的文件名</li>
<li>Dir 数据库镜像备份的文件放置路径

<h5>Limit配置项目</h5>

maxclients 客户端的并发连接数，默认10000
maxmemory配置Redis Server可占用的最大内存

<h5>Security配置项</h5>

<p>Requirepass 设置登录时需要使用的密码</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL数据库管理]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/23/mysql-study/"/>
    <updated>2015-07-23T17:26:01+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/23/mysql-study</id>
    <content type="html"><![CDATA[<h3>MySQL权限</h3>

<p>创建用户</p>

<pre><code>grant all privileges on *.* to dev@localhost identified by 'dev' with grant option;
grant select on jikedb.* to webuser@localhost identified by '123';
</code></pre>

<p>刷新权限</p>

<pre><code>flush privileges;
</code></pre>

<p>回收权限</p>

<pre><code>revoke select on jikedb.* from webuser@localhost;
</code></pre>

<p>删除用户</p>

<pre><code>drop user webuser@localhost;
</code></pre>

<p>查看用户权限</p>

<pre><code>show grants for root@localhost;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thinkphp]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/23/thinkphp/"/>
    <updated>2015-07-23T11:55:43+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/23/thinkphp</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>PHP 作为一种广泛用于 Web 服务器端的脚本语言，在敏捷 Web 开发方面有独特的优势，成功案例多、社区活跃、资源丰富，框架也非常多。ThinkPHP 作为一款起步较早、相对成熟的国产 PHP 框架，在国内有相当的用户量，借这个机会向大家介绍 ThinkPHP 基础知识，为后续的项目实战做好准备。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在ubuntu上安装mariadb]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/23/mariadb-setup/"/>
    <updated>2015-07-23T10:50:50+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/23/mariadb-setup</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>MySQL被SUN收购后，又被Oracle收购。它的作者从新开发了一个完全兼容MySQL的数据库，并且以他的女儿命名，叫做<a href="https://mariadb.org/">MariDB</a></p>

<h1>安装</h1>

<p>首先从 <a href="http://downloads.mariadb.org/mariadb/repositories/">MariaDB 下载页面</a> 选择贴近你的 Ubuntu 版本的资料库镜像，然后下载页面会在底部显示镜像信息（如下所示），然后执行这些命令</p>

<pre><code>sudo apt-get install software-properties-common
sudo apt-key adv --recv-keys --keyserver hkp://keyserver.ubuntu.com:80 0xcbcb082a1bb943db
sudo add-apt-repository 'deb http://mirrors.hustunique.com/mariadb/repo/5.5/ubuntu trusty main'
</code></pre>

<p>开始安装</p>

<pre><code>sudo apt-get update
sudo apt-get install mariadb-server
</code></pre>

<p>这样 MariaDB 5.5 就已经安装成功，你就可以像使用 MySQL 那样对它进行配置和使用了。</p>

<p>使用mysql -h -uroot -p1234测试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Vagrant搭建本地Ubuntu开发环境]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/22/vagrant-lnmp/"/>
    <updated>2015-07-22T14:13:27+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/22/vagrant-lnmp</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>使用PHP做Web开发已有4年，4年间只有第二年是在Ubuntu下开发，其它都是在Windows下开发，但Win下开发有如下缺点：</p>

<ol>
<li>Windows 不区分大小写，在Win下OK, 上传到服务器上有了Bug。</li>
<li>Windows 不能测试cron是否写得正确，执行php-cli麻烦</li>
<li>开发环境与生产环境不同，莫名的产生了一些Bug</li>
<li>自己的Linux水平下降，对服务器的一些配置慢慢感到了生疏。</li>
</ol>


<p>但在Ubuntu下开发，也有问题：</p>

<ol>
<li>不习惯的编辑器，那时使用IDEA作为编辑器，真心不好用。</li>
<li>当初用Word写文档，Ubuntu里没有。（现在用Markdown了）</li>
<li>团队开发使用QQ作为通讯工具，还要装一个QQ。（QQ真不适合作为沟通工具，其它无关内容总分心）</li>
</ol>


<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/cto_vagrant.png" alt="" /></p>

<h1>Vagrant优点</h1>

<p><a href="http://docs.vagrantup.com/">Vagrant</a>是用来管理虚拟机的，它有如下好处：</p>

<ol>
<li>对于开发人员来说，Vagrant可以帮你统一团队成员的开发环境。</li>
<li>对于运维人员来说，Vagrant可以给你提供一个与线上一致的测试环境。</li>
<li>对于设计人员来说，Vagrant可以让你只需要专注在设计上。</li>
</ol>


<p>Vagrant适合用来管理虚拟机，而Docker适合用来管理应用环境。</p>

<h3>需要安装的软件：</h3>

<ul>
<li>Vagrant</li>
<li>Virtual Box</li>
<li>putty</li>
<li>box <a href="https://atlas.hashicorp.com/boxes/search">虚拟机镜像查看</a></li>
</ul>


<p>添加box ubuntu/trusty64</p>

<pre><code>vagrant version
#查看版本

vagrant add box ubuntu/trusty64
# download the box named "ubuntu/trusty64" from Internet
#下载ubuntu14.04 lts(long term supporting)
</code></pre>

<p>添加的boxes会被多个项目重复利用。每个项目都会克隆它，而不会修改它。两个项目之间不会相互影响</p>

<pre><code>vagrant box list
#查看box列表

vagrant init ubuntu/trusty64; 
vagrant init

vagrant up --provider virtualbox
vagrant up

vagrant ssh
</code></pre>

<p>bootstrap.sh 文件</p>

<pre><code>#!/usr/bin/env bash

apt-get update
apt-get install -y apache2
if ! [ -L /var/www ]; then
  rm -rf /var/www
  ln -fs /vagrant /var/www
fi
</code></pre>

<p>Vagrantfile文件 配置文件</p>

<pre><code>Vagrant.configure("2") do |config|
   config.vm.box = "hashicorp/precise32"
   config.vm.provision :shell, path: "bootstrap.sh"
   config.vm.network :forwarded_port, guest: 80, host: 4567
   config.vm.network :private_network, ip: "192.168.33.10"
   #重启虚拟机，这样我们就能用 192.168.33.10 访问这台机器了，你可以把 IP 改成其他地址，只要不产生冲突就行。
end
</code></pre>

<p>vagrant load &ndash;provision</p>

<p>vagrant login
输入用户名和密码</p>

<p>vagrant share</p>

<p>将产生一个网址，互联网上的其他人能够访问</p>

<h3>停止工作</h3>

<pre><code>vagrant suspend
vagrant halt
vagrant destroy
</code></pre>

<h3>打包分发</h3>

<pre><code>vagrant package
vagrant package --output NAME 导出box (NAME.box)
</code></pre>

<p>打包完成后会在当前目录生成一个 package.box 的文件，将这个文件传给其他用户，其他用户只要添加这个 box 并用其初始化自己的开发目录就能得到一个一模一样的开发环境了。</p>

<h3>注意事项</h3>

<p>使用 Apache/Nginx 时会出现诸如图片修改后但页面刷新仍然是旧文件的情况，是由于静态文件缓存造成的。需要对虚拟机里的 Apache/Nginx 配置文件进行修改：</p>

<pre><code># Apache 配置添加:
EnableSendfile off

# Nginx 配置添加:
sendfile off;
</code></pre>

<h3>补充</h3>

<p>Putty工具连接：</p>

<p>注：虚拟机的默认IP|Port：127.0.0.1:2222   用户：vagrant | root   密码：vagrant</p>

<h3>参考链接</h3>

<p><a href="http://www.ciandt.com.cn/blog/how-to-use-vagrant-build-drupal-development-environment-windows">CI&amp;T: 使用VAGRANT构建DRUPAL本地开发环境 - WINDOWS</a></p>

<p><a href="http://segmentfault.com/a/1190000000264347">使用 Vagrant 打造跨平台开发环境</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Docker小结]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/21/docker-summary/"/>
    <updated>2015-07-21T21:07:41+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/21/docker-summary</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>这2天里，我了解Docker的初步使用, 并对本博客在<a href="http://www.daocloud.io">Daocloud</a>上的自动同步做了设置，<a href="http://hanfeng.daoapp.io">http://hanfeng.daoapp.io</a>, Daocloud正在搞活动，<a href="https://github.com/FengHan/fenghan.github.io/blob/master/Dockerfile">写Dockerfile</a>，生成镜像，部署Github代码，<a href="http://blog.daocloud.io/build-dockerfile-campaign/">免费送T-shirt！</a>。 本文主要记录两天所学，记录Docker的学习过程。</p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/cto_Tshirt.jpg" alt="" /></p>

<h1>构建镜像</h1>

<p>构建镜像的目的：</p>

<ul>
<li>保存对容器的修改， 并在此使用</li>
<li>自定义镜像的能力</li>
<li>以软件的形式打包并分发服务器及其运行环境。</li>
</ul>


<p>构建镜像的两种方法：</p>

<ol>
<li><p>docker build 通过Dockfile文件构建</p></li>
<li><p>docker commit 通过容器构建</p></li>
</ol>


<h3>Dockerfile的制作</h3>

<p>对于开发人员来说，主要是使用Dockerfile来构建镜像，现在简单讲一下Dockerfile的语法</p>

<pre><code>FROM &lt;image&gt; 已经存在的镜像（基础镜像）
FROM &lt;image:tag&gt;
</code></pre>

<p>必须是第一条</p>

<pre><code>MAINTAIER hanfeng "contact@hanfeng.name"
</code></pre>

<p>指定镜像所有者信息</p>

<pre><code>RUN
</code></pre>

<p>指定当前镜像中运行得命令</p>

<pre><code>RUN echo hello  (shell模式)

RUN ["executable", "param1", "param2"] (exec模式)

RUN["/bin/bash", "-c", "echo hello"]
</code></pre>

<p>每个RUN指令都会在当前的RUN指令上新创建一个镜像，是分层的。</p>

<pre><code>EXPOSE &lt;port&gt;[&lt;port&gt;]
EXPOSE 80
EXPOSE 80:80
EXPOSE 0.0.0.0:80:80
</code></pre>

<p>指定运行该镜像的容器使用的端口</p>

<p>只是告诉容器应该打开哪个端口，Dokcer不会自动打开。还是需要启动的时候指定端口</p>

<pre><code>CMD
CMD["executable",'param1','['param2'](exec模式)
</code></pre>

<p>能够被Docker run 后面的命令覆盖掉</p>

<pre><code>ENTRYPOINT
ENTRYPOINT COMMAND P1 P1
</code></pre>

<p>不会被docker run覆盖</p>

<p>容器运行时的指令</p>

<pre><code>ADD
</code></pre>

<p>适用于文件路径中有空格的情况</p>

<p>ADD 包含类似tar的解压功能</p>

<p>如果单独复制文件，建议使用COpy</p>

<pre><code>COPY

VOLUME
VOLUME["/data"]
</code></pre>

<p>镜像的目录和文件</p>

<pre><code>WORKDIR
WORKDIR /path/to/workdir
WORKDIR 使用绝对路径

ENV&lt;key&gt;&lt;value&gt;

USER daemon
USER nginx
USER root:root
</code></pre>

<p>环境设置</p>

<pre><code>ONBUILD
</code></pre>

<p>镜像触发器</p>

<p>当一个镜像被其他镜像作为基础镜像时执行。</p>

<p>会在构建过程中插入指令</p>

<p>简单的例子：</p>

<pre><code># First dockerfile for test
FROM ubuntu:14.04
MAINTAINER hanfeng "contact.hanfeng.name"
RUN apt-get update
RUN apt-get install -y nginx
EXPOSE 80
</code></pre>

<p>Dockerfile的构建过程</p>

<pre><code>docker build -t ="hanfeng/nginx"

docker run  --name=web01 -p 80 -d hanfeng/nginx -g "daemon off;"
</code></pre>

<p>执行Dockerfile的每一条指令，执行相当于执行了docker commit一次，每条命令都会产生一个新的镜像层
执行Dockerfile的下一条命令</p>

<pre><code>docker history image
#查看构建镜像的历史命令
</code></pre>

<h3>镜像的发布</h3>

<pre><code>docker push qthhanfeng/nginx    
</code></pre>

<h1>常用命令</h1>

<pre><code>docker run  --name=web01 -it ubuntu /bin/bash
</code></pre>

<p>为容器制定一个名字</p>

<pre><code>docker start [-i] 容器名
</code></pre>

<p>重新启动停止的容器：</p>

<p>参数 -i 以参数的方式</p>

<p>在交互式时，Ctrl + P ，然后 Ctrl + Q</p>

<p>docker attach + 容器ID</p>

<hr />

<p>查看容器日志</p>

<pre><code>docker logs -f -t --tail 容器名
</code></pre>

<p>-f 更新</p>

<p>-t 时间戳</p>

<p>&ndash;tail  显示最新的</p>

<hr />

<pre><code>docker top 容器
#查看容器内进程
docker exec -d -i -t 容器名字
#在运行中的容器启动新进程
docker stop
#发送信号给容器，等待停止

docker kill 容器
#直接停止容器
</code></pre>

<p>设置容器的端口映射</p>

<pre><code>docker run -P -it ubuntu /bin/bash
</code></pre>

<p>-P &ndash;publish-all=true|false默认为fale，所有端口映射</p>

<p>-p &ndash;publish=[]</p>

<pre><code>docker run -p 80 -it ubuntu /bin/bash
#容器端口
docker run -p 8080:80 -it ubuntu /bin/bash
#宿主机端口：容器端口
docker run -p 0.0.0.0:80 -it ubuntu /bin/bash
#IP:容器端口
docker run -p 0.0.0.0:8080:80 -it ubuntu /bin/bash
#IP:宿主机端口：容器端口

docker run -p 80 --name web -it ubuntu /bina/bash

docker port web
docker top web
</code></pre>

<p>重启后，容器没有启动nginx, IP地址和端口映射都会发生改变</p>

<pre><code>docker exec web nginx
docker top web
</code></pre>

<h1>DaoCloud提供的加速</h1>

<pre><code>vim /etc/default/docker
DOCKER_OPTS="$DOCKER_OPTS --registry-mirror=http://字符串.m.daocloud.io"
#文件末尾添加
</code></pre>

<p>常用命令：</p>

<pre><code>docker inspect +仓库名:TAG名
#查看镜像

docker rmi +仓库名:TAG名
#删除TAG

docker rmi + 镜像ID
#删除这个镜像对应的所有TAG

docker rmi $(docker images ubuntu -q)
</code></pre>

<h1>Docker Hub</h1>

<p><a href="https://registry.hub.docker.com">https://registry.hub.docker.com</a></p>

<p>搜索镜像</p>

<pre><code>docker serach
</code></pre>

<p>下载镜像</p>

<pre><code>docker pull
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[认识Docker]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/19/docker/"/>
    <updated>2015-07-19T22:09:25+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/19/docker</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>有了Docker以后，那些需要多台机器才能完成的实验就变得非常简单了。</p>

<p>以容器的方式交付软件， 是每一个程序员都需要掌握的新技能。</p>

<h1>什么是Docker，</h1>

<p><a href="http://docker.com">Docker</a>是一个<strong>容器</strong>引擎,提供了一套完整的容器解决方案。</p>

<p>Docker是2014年最火的开源项目，由Docker公司领导开发，基于Apache2.0开源授权协议发行。</p>

<p>Docker是用Go语言开发的，其源码在<a href="https://github.com/docker/docker">https://github.com/docker/docker</a>
<img src="http://7xkc1x.com1.z0.glb.clouddn.com/docker.jpg?imageView2/2/w/300/" alt="" /></p>

<h1>什么是容器</h1>

<p><strong>容器</strong>是一种历史悠久的<strong>虚拟化技术</strong>，如OpenVZ，Solaris上的Zones，Linux上的LXC等，都是容器的不同实现方式。</p>

<p>一个容器实质上就是运行在宿主机器上的一个进程。只不过在启动这个进程之前，进行了一些特殊处理，让这个进程进入了一个全新的虚拟环境，与宿主机环境分开。所以这个进程及它的子进程认为自己运行在一个独立的世界里面。</p>

<p>容器的优势：
<em>创建容器速度快</em>，速度在1秒左右，而传统虚拟机需要15s左右</p>

<p>容器运行<strong>占用的额外开销非常小</strong></p>

<p>Docker的优势：</p>

<p>Docker让容器的管理变得极其方便，不需要掌握高深的技术就能使用。</p>

<p>为什么学习Docker：</p>

<p>Docker很可能改变传统的软件“交付”方式和“运行”方式；也可能在绝大多数场合取代传统虚拟机的地位。因此整个IT界都在积极探索如何运用Docker来进行技术变革。</p>

<h1>如何安装Docker</h1>

<p>Docker可以安装到绝大多数的Linux发型版上，包括Ubuntu、CentOS、Redhat等,也可安装到Mac OS上。</p>

<p><a href="https://docs.docker.com/installation">https://docs.docker.com/installation</a>介绍了在各种操作系统上安装Docker的详细步骤。虽然Docker可以安装在Windows上，但是不推荐。</p>

<p>需要注意的是，<strong>目前Docker只支持64位操作系统</strong></p>

<h3>Ubuntu上安装稳定版</h3>

<p>本文在Ubuntu Trusty 14.04 (LTS)上安装</p>

<pre><code>uname -i   
</code></pre>

<p>x86_64则为64位系统</p>

<pre><code>uname -r 
</code></pre>

<p>内核版本要大于3.10</p>

<pre><code>sudo apt-get update
sudo apt-get install docker.io
ps axf | grep docker
docker version 
#查看docker版本
</code></pre>

<h3>安装最新版本</h3>

<pre><code>sudo apt-get remove --purge docker.io
</code></pre>

<p>先卸载稳定版的docker</p>

<pre><code>which wget
</code></pre>

<p>确保安装wget</p>

<pre><code>wget -qO- https://get.docker.com/ | sh
</code></pre>

<p>获取最新的Docker Packer</p>

<pre><code>ps axf | grep docker
docker version 
#查看docker版本

service docker stop
service docker start
service docker restart
</code></pre>

<p>Docker是一个经典的CS架构：
Docker Server：它是一个<strong>守护进程（Daemon）</strong>,一直运行在后台。
它其中嵌入了一个Web Server。</p>

<p>Docker的发展速度太快，目前最新版本到1.7.1，推荐安装到最新版</p>

<p>Docker Client： 它是一个命令行工具，通过HTTP协议与Docker Server交互</p>

<p>巧妙的是，<strong>Docker Server与Docker Client共用同一个可执行文件</strong>,通过</p>

<pre><code>which docker
</code></pre>

<p>来查看它安装后的路径</p>

<pre><code>sudo docker run hello-world
</code></pre>

<p>验证docker是否安装正确，它会下载一个测试镜像，并在容器里运行它。</p>

<h1>Docker镜像和镜像仓库</h1>

<p>每个Docker容器运行在独立的虚拟环境中，虚拟环境包括多个方面，其中最重要的就是独立的<strong>文件系统</strong>；在这个文件系统中的读写操作，既不影响宿主机的文件系统，也不影响其它容器的文件系统。</p>

<p>Docker镜像是一个比较复杂的概念。现阶段，我们可以把简单的把<strong>Docker镜像理解成一个目录</strong> Docker Server在启动容器的时候，先根据这个镜像目录，复制出一个<strong>新的目录</strong> ,然后在容器进程启动时，让这个进程chroot到这个新的目录下。这样，这个目录就成了这个容器的根文件系统（<strong>rootfs</strong>）。</p>

<pre><code>docker images
</code></pre>

<p>查看本地的images镜像</p>

<p><strong>镜像ID</strong>: 每个镜像有一个唯一的一个ID;长度为64个字符。通常只使用前12个字符就可以了。</p>

<p>镜像TAG: 每个镜像可以打上一个或多个TAG</p>

<p>镜像 Repository: 每个镜像存储在一个仓库中</p>

<p><strong>Repository:TAG</strong>: 唯一标识一个镜像</p>

<p>镜像和镜像仓库都存储在Registry中
本地Registry： 通过docker images查看的就是本地Registry
官方Registry: Docker官方维护了一个Registry,里面存储了各种各样的镜像。</p>

<p>如果从Docker官方Registry拉取镜像速度很慢，可以舱室<strong>daocloud</strong>提供的加速器服务，<a href="https://dashboard.daocloud.io/mirror">https://dashboard.daocloud.io/mirror</a>有详细的使用方法介绍</p>

<h1>Docker容器的创建、删除、停止、查看等基本命令</h1>

<pre><code>docker run
</code></pre>

<p>运行容器命令。</p>

<p>docker run是最常用也是最复杂的命令，通过docker help run  我们可以看到该命令有很多选项。</p>

<ul>
<li>-i -t 缩写为 -it,用于创建交互式容器</li>
<li>-d  让容器运行在后台，用于创建守护式容器</li>
<li>-name 为容器指定一个名称
容器运行成功后，会返回一个64字符的<strong>容器ID</strong>, 作为容器的唯一标识。类似于镜像的ID, 容器ID也可以采用简写形式。</li>
</ul>


<p>通过如下命令来运行一个<strong>交互式容器</strong></p>

<pre><code>sudo docker run -it ubuntu:latest /bin/bash
</code></pre>

<p>说明</p>

<ul>
<li>it 指定要创建交互式容器</li>
<li>ubuntu:latest   以仓库：TAG的形式指定了镜像名称</li>
<li>/bin/bash 容器对应的进程，会启动一个新的shell</li>
</ul>


<p>通过如上命令，我们启动了新的shell，并运行在容器环境中。由于是一个交互式容器，所以我们会离开当前的shell，被这个新的shell带入到容器的虚拟世界中，此后我们在这个shell里面执行的任何命令，都是相对于这个虚拟世界的。</p>

<pre><code>/cat/etc/issue.net
</code></pre>

<p>exit 回到现实世界</p>

<p>交互式容器适合一些临时性的任务，当退出bash的时候，交互式容器的生命也就结束了。大多数场合下，我们需要的是<strong>守护式容器</strong>。通过如下方式运行守护式容器：</p>

<pre><code>sudo docker run -d redis
</code></pre>

<p>说明</p>

<ul>
<li>d 创建守护式容器</li>
<li><p>redis镜像名称 这里只有仓库名称，没有指定TAG,那么久使用默认TAG <strong>&lsquo;latest&rsquo;</strong></p></li>
<li><p><strong>没有指定命令</strong> 那么会使用镜像所提供的<strong>默认命令</strong>。redis镜像的默认命令是 /entrypoint.sh redis-server</p></li>
</ul>


<p><strong>守护式容器运行在后台</strong>， 这样我们就可以继续留在当前shell中进行其它操作</p>

<pre><code>sudo docker ps
</code></pre>

<p>查看容器的基本信息，包括容器ID、命令、状态等；</p>

<pre><code>sudo docker ps -a 
</code></pre>

<p>查看之前创建的容器</p>

<pre><code>docker inspect + 镜像ID
</code></pre>

<p>查看更具体的信息
    docker rm + 镜像ID
容器停止后并不会被删除，用这个命令删除</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Ubuntu上搭建Nginx + Php5-fpm]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/19/nginx_php5-fpm/"/>
    <updated>2015-07-19T11:25:56+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/19/nginx_php5-fpm</id>
    <content type="html"><![CDATA[<p><img src="http://nginx.org/nginx.png" alt="" /></p>

<h1>前言</h1>

<p>大学开发网站的时候，大部分的时候使用的是Apache服务器，但进入工作后，服务器都使用Nginx，因为它能承载的并发数是Apache2.2的10倍。</p>

<p>Nginx只负责静态文件，通过php5-fpm调用php-cgi来解析php。</p>

<p>那CGI是干嘛的？CGI是为了保证web server传递过来的数据是标准格式的，方便CGI程序的编写者的协议。</p>

<p>Fastcgi是用来提高CGI程序性能的，也是一个协议。</p>

<p>那PHP-FPM又是什么呢？是一个实现了Fastcgi的程序，被PHP官方收了。</p>

<p>可以<a href="http://nginx.org/en/docs/">Nginx官方文档</a>深入学习，下面这些必看</p>

<ul>
<li>Installing nginx</li>
<li>Beginner’s Guide</li>
<li>Converting rewrite rules</li>
<li>ngx_http_rewrite_module</li>
<li>ngx_http_proxy_module</li>
<li>ngx_http_log_module</li>
</ul>


<h1>安装Nginx</h1>

<p><strong>安装Nginx</strong></p>

<pre><code>apt-get update
apt-get install nginx
</code></pre>

<p><strong>配置Nginx</strong></p>

<p>nginx配置文件</p>

<blockquote><p>/etc/nginx/nginx.conf中</p></blockquote>

<p>nginx.conf配置里面包括了</p>

<blockquote><p>include /etc/nginx/conf.d/*.conf;</p>

<p>include /etc/nginx/sites-enabled/*;</p></blockquote>

<p>错误日志</p>

<blockquote><p>error_log /var/log/nginx/error.log;</p></blockquote>

<p>网页的默认目录</p>

<blockquote><p>root /usr/share/nginx/html;</p></blockquote>

<p>配置目录</p>

<blockquote><p>/etc/nginx/sites-available/default</p></blockquote>

<h3>fastcgi配置</h3>

<pre><code>location ~ \.php$ {

  　　  try_files $uri =404;

  　　  fastcgi_pass 127.0.0.1:9000;

  　　  fastcgi_index index.php;

  　　  include fastcgi_params;
}
  　
</code></pre>

<p><strong>配置生效</strong></p>

<pre><code>/etc/init.d/nginx reload
</code></pre>

<p><strong>启动Nginx</strong></p>

<pre><code>/etc/init.d/nginx start
</code></pre>

<p><strong>测试Nginx</strong></p>

<p>再配置好php5-fpm后，再测试
在 /usr/share/nginx/html下新建index.php</p>

<pre><code>&lt;? php
phpinfo();
</code></pre>

<p>　　　　
nginx -t</p>

<h1>虚拟主机管理</h1>

<p>创建 tech.hanfeng.name</p>

<pre><code>cd /usr/share/nginx

mkdir tech.hanfeng.name

cd tech.hanfeng.name

echo '&lt;?php phpinfo();' &gt; index.php

cd /etc/nginx/sites-available/ 

cp default tech.hanfeng.name
#Apache需要以.conf结尾，Nginx不用

grep -v "#" tech.hanfeng.name
</code></pre>

<p>tech.hanfeng.name 虚拟主机配置：</p>

<pre><code>server {
        listen 80;
        listen [::]:80;

        root /usr/share/nginx/tech.hanfeng.name;
        index index.php index.html;

        server_name tech.hanfeng.name;

        location / {
                try_files $uri $uri/ =404;
        }




        location ~ \.php$ {
                fastcgi_split_path_info ^(.+\.php)(/.+)$;

                fastcgi_pass 127.0.0.1:9000;
                fastcgi_index index.php;
                include fastcgi_params;
        }

}
</code></pre>

<h3>生成软连接</h3>

<pre><code>ln -s /etc/nginx/sites-available/tech.hanfeng.name  /etc/nginx/sites-enabled/tech.hanfeng.name
</code></pre>

<h3>测试并且加载nginx配置</h3>

<pre><code>nginx -t

/etc/init.d/nginx reload
</code></pre>

<h1>安装PHP</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo apt-get install php5-fpm
</span><span class='line'>
</span><span class='line'>sudo apt-get install php5-gd  
</span><span class='line'># Popular image manipulation library; used extensively by Wordpress and it's plugins.
</span><span class='line'>
</span><span class='line'>sudo apt-get install php5-cli   
</span><span class='line'># Makes the php5 command available to the terminal for php5 scripting
</span><span class='line'>
</span><span class='line'>sudo apt-get install php5-curl    
</span><span class='line'># Allows curl (file downloading tool) to be called from PHP5
</span><span class='line'>
</span><span class='line'>sudo apt-get install php5-mcrypt   
</span><span class='line'># Provides encryption algorithms to PHP scripts
</span><span class='line'>
</span><span class='line'>sudo apt-get install php5-mysql   
</span><span class='line'># Allows PHP5 scripts to talk to a MySQL Database
</span><span class='line'>
</span><span class='line'>sudo apt-get install php5-readline  
</span><span class='line'># Allows PHP5 scripts to use the readline function</span></code></pre></td></tr></table></div></figure>


<p>查看php5运行进程</p>

<pre><code>ps -waux | grep php5
</code></pre>

<h1>配置PHP5-FPM</h1>

<p>配置php5监听端口</p>

<blockquote><p>/etc/php5/fpm/pool.d/www.conf</p></blockquote>

<pre><code>把
listen = /var/run/php5-fpm.sock  改为
listen = 127.0.0.1:9000
</code></pre>

<p>配置好后，重新启动php5-fpm</p>

<h3>php5-fpm命令</h3>

<pre><code>sudo service php5-fpm stop
sudo service php5-fpm start
sudo service php5-fpm restart
sudo service php5-fpm status
</code></pre>

<p>一台机器安装nginx，另一台安装php，用上面的修改</p>

<p>重新运行php进程</p>

<p>在浏览器中输入 localhost就可以看到了</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git的本地操作]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/18/git-local/"/>
    <updated>2015-07-18T10:39:26+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/18/git-local</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>我刚毕业那年，公司在开发软件项目的时候使用的是SVN，但总觉得有一些缺点，例如：版本库只保存在了中央服务器上，如果服务器离线或宕机，就无法进行版本管理；当时每天下班时，我们都会提交提交当天的代码，由于代码的合并是在服务器上完成的，所以偶尔会遇到合并的时候出现BUG;</p>

<p>之后的工作中接触到了Git，它很好的解决了我之前遇到的问题,具体学习可参考<a href="http://git-scm.com/book/en/v2">Pro Git 第二版</a></p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/cto_pro-git.jpg?imageView2/2/h/300" alt="image" /></p>

<h1>Git 简介</h1>

<p><strong>Git与SVN的比较</strong></p>

<ol>
<li>SVN是集中式的版本控制软件，而Git是分布式的。</li>
<li>SVN的版本是记录文件与上一次版本的差异，每次checkout时，要迭代这些差异；而Git每个版本会记录全部内容，所以效率更高。</li>
<li>因为Git在每台电脑上都保存了完整的Version Database， 所以Git可以离线完成大部分操作</li>
<li>Git有着更优雅的分支和实现</li>
<li>Git有着强大的撤销修改和修改版本的能力</li>
<li>Git速度更快，效率更高</li>
</ol>


<p><strong>为什么学习Git呢</strong></p>

<ol>
<li>现在越来越多的项目放在了GitHub上;</li>
<li>同时越来越来的公司开始使用Git;</li>
<li>Android和Linux的版本控制用的都是Git</li>
</ol>


<h1>Git安装与简单配置</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#在全局上配置name和email</span>
</span><span class='line'>git config --global user.name hanfeng 
</span><span class='line'>git config --global user.email contact@hanfeng.name
</span><span class='line'><span class="c">#生成秘钥和公钥，公钥放到Github或Git服务器上，私钥自己保存</span>
</span><span class='line'>ssh-keygen -t rsa -C <span class="s1">&#39;contact@hanfeng.name&#39;</span>
</span><span class='line'><span class="c">#常用快捷键</span>
</span><span class='line'>git config --global alias.co checkout
</span><span class='line'>git config --global alias.st status
</span><span class='line'>git config --global alias.ci commit
</span><span class='line'>git config --global alias.br branch
</span><span class='line'>git config --global alias.lol <span class="s2">&quot;log --oneline -- decorate --graph -all&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Git config 配置有3个优先级
local > global > system</p>

<p>git config 的增删改查</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#增</span>
</span><span class='line'>git config --global --add user.name michael
</span><span class='line'><span class="c">#删</span>
</span><span class='line'>git config --global --unset user.name michael
</span><span class='line'><span class="c">#改</span>
</span><span class='line'>git conifg --global user.name hanfeng
</span><span class='line'>查
</span><span class='line'>git config --list --global
</span></code></pre></td></tr></table></div></figure>


<h1>Git基本工作流程</h1>

<p>Git 使用40个16进制符的SHA-1的Hash来标识对象</p>

<p>Git的对象有4种：</p>

<ul>
<li>blob： 文件名，二进制文件或链接</li>
<li>tree： 目录</li>
<li>commit: 代表一个提交</li>
<li>tag： 指向一个固定的历史提交</li>
</ul>


<p>Tag -> Commit -> Tree -> Blob</p>

<p>Git只关心文件内容，如果两个文件有相同的内容，那么他们会指向相同的Blob, 文件名存储在tree里</p>

<p>创建一个裸仓库
git init &ndash;bare</p>

<p>Git有三个区域 Working directory(工作区), Staging area(暂存区), History repository(历史记录区)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rm a
</span><span class='line'>#把工作区和暂存区的a都删掉
</span><span class='line'>#如果还原 用git reset --hard HEAD a
</span><span class='line'>
</span><span class='line'>git mv a c
</span><span class='line'>#工作区和暂存区a都会改名字为c
</span><span class='line'>#相当于 mv a c 和 git add a c  </span></code></pre></td></tr></table></div></figure>


<p>vim .gitignore</p>

<blockquote><p>*.[o|a]</p>

<p>*.~</p>

<p>!test.pyc</p>

<p>foo/</p>

<p>**/res</p></blockquote>

<p>test.pyc不要被忽略</p>

<p>顶层或res子目录</p>

<p>.git/info/exclude  只针对本地仓库</p>

<p>./git/config配置下</p>

<blockquote><p>excludesfile = e:/gitignore.txt</p></blockquote>

<h1>Git本地分支与合并</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#只对本地有效
</span><span class='line'>git tag "v0" 3abefd
</span><span class='line'>
</span><span class='line'>#对全局都有效   
</span><span class='line'>git tab -a "INITIAL_COMMIT" 3abedf
</span><span class='line'>git tag
</span><span class='line'>git show v0
</span><span class='line'>git checkout -b fix -v0
</span><span class='line'>git stash = git stash svae
</span><span class='line'>
</span><span class='line'>git stash save -a "stash1"  
</span><span class='line'># -a --all 把untracked files 也stash
</span><span class='line'>
</span><span class='line'>git stash list
</span><span class='line'>
</span><span class='line'>git stash pop --index stash@{0}   
</span><span class='line'># --index, 暂存区还原到暂存区，不然还原到工作区
</span><span class='line'>
</span><span class='line'>git stash apply --index stash@{0} 
</span><span class='line'>#同时保持git stash list
</span><span class='line'>
</span><span class='line'>git stash drop stash@{0}
</span><span class='line'>
</span><span class='line'>git stash clean 
</span><span class='line'># 清楚全部 stash</span></code></pre></td></tr></table></div></figure>


<p>分支切换，就是HEAD引用的切换</p>

<p>git merge有两种： fast-forward， non-fast-forward</p>

<p>fast-forward 只合并了工作区和暂存区，不产生新的Commit对象</p>

<p>non-fast-forward 产生新的Commit对象，HEAD指向</p>

<h1>查看与对比历史记录</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git show + git对象
</span><span class='line'>git log 
</span><span class='line'>git diff
</span><span class='line'>git show HEAD~ = git show HEAD^
</span><span class='line'>git show --oneline master^2
</span><span class='line'>git diff --cached   
</span><span class='line'>#暂存区与历史记录的比较
</span><span class='line'>git diff --cached HEAD^2
</span><span class='line'>git diff --color-words
</span><span class='line'>git diff --word-diff</span></code></pre></td></tr></table></div></figure>


<h1>撤销修改</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git checkout + 分支名
</span><span class='line'>#把HEAD指向分支， 还原工作区和暂存区
</span><span class='line'>
</span><span class='line'>git reset
</span><span class='line'>git clean 
</span><span class='line'>git revert</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#根据历史记录，只还原暂存区
</span><span class='line'>git reset master.txt = git rest HEAD master.txt
</span><span class='line'>
</span><span class='line'>#将tag指向的commit对象里的内容还原到工作区和暂存区
</span><span class='line'>git checkout INITIAL_COMMIT --master.txt
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>#将tag指向的commit对象里的内容还原到暂存区
</span><span class='line'>git reset INITIAL_COMMIT --master.txt
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git clean -n
</span><span class='line'>git clean -f
</span><span class='line'>
</span><span class='line'>git clean -X -n  
</span><span class='line'>#查看清除 .gitignore里的内容
</span><span class='line'>
</span><span class='line'>git clean -X -f
</span><span class='line'>
</span><span class='line'>git clean -x -n 
</span><span class='line'>#清除所有
</span><span class='line'>
</span><span class='line'>git clean -x -f
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git revert HEAD</span></code></pre></td></tr></table></div></figure>


<h1>重写历史记录</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#修改最后一次提交
</span><span class='line'>git commit --ammend  
</span><span class='line'>
</span><span class='line'>#超强的修改历史的能力，维护一个线性的历史
</span><span class='line'>git rebase  
</span><span class='line'>
</span><span class='line'>#可以撤销merge
</span><span class='line'>git reset + commit对象
</span><span class='line'>
</span><span class='line'>#维护HEAD引用信息，配合git reset
</span><span class='line'>git reflog</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git rebase master
</span><span class='line'>git rebase --abort
</span><span class='line'>git rebase --continue</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git reset --mixed HEAD@{5}
</span><span class='line'># --mixed为默认参数，只还原暂存区，把分支名和HEAD引用直接指定到相应的commit对象上
</span><span class='line'>
</span><span class='line'>git reset --hard HEAD@{5}
</span><span class='line'>#还原暂存区和工作区
</span><span class='line'> 
</span><span class='line'>git reset --soft HEAD@{5}
</span><span class='line'>#都不还原</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Octopress在GitHub上搭建静态博客]]></title>
    <link href="http://fenghan.github.io/blog/2015/07/17/octopress-blog/"/>
    <updated>2015-07-17T12:52:50+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/07/17/octopress-blog</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p>本博客基于Octopress+Github Pages搭建，可以搭建全免费、稳定运行的个人博客。 本文将简述在Windows平台（Win7 64bit）上搭建这套系统的全流程及博客的迁移。 在继续看本文之前，请先确定你具有折腾的精神。</p>

<p><img src="http://7xkc1x.com1.z0.glb.clouddn.com/ctooctopress.jpg" alt="image" /></p>

<h1>介绍</h1>

<p><a href="https://github.com/imathis/octopress">Octopress</a>是一个基于Ruby语言的开源静态网站框架， 所谓静态，是指网站的所有内容都是生成好的静态HTML，不含任何后台处理程序，也没有数据库。 这样的好处是不会读取数据库，也不会有脚本编译，所以网站的加载速度会非常快，整体程序规模也非常轻量级。</p>

<p><a href="https://pages.github.com/">Github Pages</a>是Github上的一项服务， 注册用户可以申请一个和自己账号关联的二级域名， 在上面可以托管一个静态网站，网站内容本身就是Github的一个repository也就是项目， 维护这个项目的代码就是在维护自己的网站。
此外，用户撰写日志使用的是Markdown语法。这是一种极简化的语法， 它的好处在于可以以纯文本形式表现文章，用户不用关心排版的问题。 基本上来说它相当于HTML标签的最小子集做了一个转义。</p>

<p>综上所述，你将获得一个这样的博客</p>

<ul>
<li>命令行操作</li>
<li>纯文本写博客</li>
<li>定制性高</li>
<li>纯静态</li>
<li>尤其适合程序员</li>
<li>版本化管理</li>
<li>迁移成本低</li>
<li>简洁的 Ruby 框架</li>
<li><a href="http://www.appinn.com/markdown/">Markdown</a> 语法</li>
</ul>


<h1>安装</h1>

<ul>
<li>Git：版本管理工具，将代码托管到 GitHub</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">ruby</span> <span class="o">-</span><span class="n">v</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Ruby + DevKit：生成静态网页</li>
<li>MarkdownPad：Windows 下 Markdown 语法编辑器</li>
<li><strong>安装 Octopress</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1">#1.克隆 Octopress 至本地</span>
</span><span class='line'><span class="n">git</span> <span class="nb">clone</span> <span class="ss">git</span><span class="p">:</span><span class="sr">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">imathis</span><span class="o">/</span><span class="n">octopress</span><span class="o">.</span><span class="n">git</span> <span class="n">octopress</span>
</span><span class='line'><span class="c1">#2.参考 ruby.taobao.org, 配置RubyGems 镜像</span>
</span><span class='line'><span class="c1">#3.安装依赖项</span>
</span><span class='line'><span class="n">gem</span> <span class="n">install</span> <span class="n">bundler</span>
</span><span class='line'><span class="n">bundle</span> <span class="n">install</span>
</span><span class='line'><span class="c1">#4.安装并使用默认主题</span>
</span><span class='line'><span class="n">rake</span> <span class="n">install</span>
</span><span class='line'><span class="err">$</span> <span class="n">gem</span> <span class="n">install</span> <span class="n">rails</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Pygments: Jekyll 里默认的语法高亮插件是 Pygments

<ul>
<li>安装 Python</li>
<li>安装 ‘Easy Install’</li>
<li>安装 Pygments</li>
</ul>
</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">python</span> <span class="o">-</span><span class="n">V</span>
</span></code></pre></td></tr></table></div></figure>


<h1>部署博客至 GitHub</h1>

<p>1.新建仓库
    username.github.io</p>

<p>2.与本地 Octopress 目录绑定</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">setup_github_pages</span>
</span><span class='line'><span class="n">rake</span> <span class="n">deploy</span>
</span></code></pre></td></tr></table></div></figure>


<h2>托管源码至 GitHub</h2>

<p>将 source 目录更新到远程仓库</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">git</span> <span class="n">add</span> <span class="o">.</span>
</span><span class='line'><span class="n">git</span> <span class="n">commit</span> <span class="o">-</span><span class="n">m</span> <span class="s1">&#39;your message&#39;</span>
</span><span class='line'><span class="n">git</span> <span class="n">push</span> <span class="n">origin</span> <span class="n">source</span>
</span></code></pre></td></tr></table></div></figure>


<h1>相关配置</h1>

<p><strong>多说评论</strong></p>

<p><strong>JiaThis分享</strong></p>

<p><strong>自定义 404 页面</strong></p>

<p><strong>自定义导航</strong></p>

<p><strong>主配置文件</strong></p>

<p>在 _config.yml 文件中，设置 url、title、author 等基本信息</p>

<h2>GitHub 上找主题文件</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">install</span><span class="o">[</span><span class="s1">&#39;themename&#39;</span><span class="o">]</span>
</span><span class='line'><span class="n">rake</span> <span class="n">generate</span>
</span></code></pre></td></tr></table></div></figure>


<h2>在 GitHub 上绑定自定义域名</h2>

<p>创建 source/CNAME 文件并指定域名</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> <span class="s1">&#39;hanfeng.com&#39;</span> &gt;&gt; <span class="nb">source</span>/CNAME
</span><span class='line'><span class="c"># OR</span>
</span><span class='line'><span class="nb">echo</span> <span class="s1">&#39;tech.hanfeng.name&#39;</span> &gt;&gt; <span class="nb">source</span>/CNAME
</span></code></pre></td></tr></table></div></figure>


<p>解析域名至 GitHub</p>

<ul>
<li><p>使用子域名
对于子域名(www.hanfeng.name)，创建 CNAME 记录指向 fenghan.github.io</p></li>
<li><p>使用顶级域名
对于顶级域名(hanfeng.name)，使用 A 记录指向 192.30.252.153(154)</p></li>
</ul>


<h1>常用目录</h1>

<p>source  存放程序、博客源码
public  存放生成的静态网站</p>

<h1>国内访问加速</h1>

<p><strong>修改字体</strong>：</p>

<p>source/_includes/custom/head.html,</p>

<p>将其中的<a href="https://fonts.googleapis.com">https://fonts.googleapis.com</a> 改为 <a href="http://fonts.useso.com">http://fonts.useso.com</a> 即可。</p>

<p><strong>jquery库</strong>:</p>

<p>/source/_includes/head.html,把google的jQuery库改为libs.baidu.com的</p>

<p><strong>关闭twitter</strong>:</p>

<p>_config.yml中twitter_tweet_butto改为false即可</p>

<h1>SEO</h1>

<p>使用百度统计工具进行统计</p>

<h1>常用命令</h1>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rake</span> <span class="n">new_page</span><span class="o">[</span><span class="s1">&#39;about&#39;</span><span class="o">]</span>           
</span><span class='line'><span class="c1">#creates /source/about/index.markdown</span>
</span><span class='line'>
</span><span class='line'><span class="n">rake</span> <span class="n">new_post</span><span class="o">[</span><span class="s1">&#39;octopress-blog&#39;</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">rake</span> <span class="n">generate</span>
</span><span class='line'>
</span><span class='line'><span class="n">rake</span> <span class="n">preview</span>
</span><span class='line'><span class="c1">#本地localhost:4000</span>
</span><span class='line'>
</span><span class='line'><span class="n">rake</span> <span class="n">deploy</span>
</span><span class='line'><span class="c1">#发布代码到Git Pages上</span>
</span></code></pre></td></tr></table></div></figure>


<h1>博客迁移</h1>

<p>如果本地已经配置过octopress，只是把octopress删掉重装
将source和master分支下的内容clone到本地即可(不需要再到官网上去clone全新的octopress)，具体作法：</p>

<p>1）首先将博客源文件clone到本地的octopress文件夹内。</p>

<pre><code>$ git clone -b source git@github.com:FengHan/fenghan.github.io.git octopress
</code></pre>

<p>2）将博客源文件clone到octopress的——deploy文件夹内。</p>

<pre><code>$ cd octopress
$ git clone git@github.com:FengHan/fenghan.github.io.git _deploy 
</code></pre>

<p>执行完这两步就OK了。</p>

<h1>参考链接</h1>

<p>软件安装： <a href="http://blog.csdn.net/kong5090041/article/details/38408211">oukongli的专栏</a></p>

<p>SEO参考： <a href="http://yidao620c.github.io/blog/20150318/octopress-blog.html">笨跑的一刀</a></p>

<p> <a href="http://pan.baidu.com/s/1bndNlTl">软件下载</a>   密码: e3p3</p>
]]></content>
  </entry>
  
</feed>
