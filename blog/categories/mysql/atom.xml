<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mysql | hanfeng.name]]></title>
  <link href="http://fenghan.github.io/blog/categories/mysql/atom.xml" rel="self"/>
  <link href="http://fenghan.github.io/"/>
  <updated>2015-10-21T08:27:41+08:00</updated>
  <id>http://fenghan.github.io/</id>
  <author>
    <name><![CDATA[HanFeng]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MySQL事务与存储引擎]]></title>
    <link href="http://fenghan.github.io/blog/2015/10/19/mysql-transaction-and-storange-engine/"/>
    <updated>2015-10-19T21:15:51+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/10/19/mysql-transaction-and-storange-engine</id>
    <content type="html"><![CDATA[<h1>前言</h1>

<p><strong>事务</strong>特性是关系型数据库在各个行业领域中成为关键数据存储最主要工具的一大法宝，可以说是数据库安身立命之本，当然也包括MySQL。无论是应用开发人员还是DBA，学习掌握事务的使用和基本原理，是更好地使用和管理数据库的必由之径。</p>

<p>掌握事物的特性要达到什么样的标准呢？如下标准：</p>

<ol>
<li>事务的主要用处和基本特征</li>
<li>事务隔离级别的含义及影响</li>
<li>什么是MySQL的存储引擎，以及主要存储引擎有哪些</li>
<li>MySQL主要存储引擎的特点和适用范围</li>
<li>InnoDB存储引擎特点和优势</li>
</ol>


<h1>数据库事务</h1>

<h3>什么是事务？</h3>

<p>老张给老王转账100元。要分为两个update语句，一个语句给老张减去100元，另外一个语句给老王加上一百元。而计算系统总是不能持续稳定的运行，线上会有各种各样的故障，而这个故障恰好发生在两个SQL之间，那么这100元就废了。事务就是为了避免这样的事情发生。</p>

<ul>
<li>一系列有序的数据库操作

<ul>
<li>要么全部成功</li>
<li>要么全部回退到操作状态</li>
<li>中间状态对其它连接不可见</li>
</ul>
</li>
<li>事务的基本操作

<ul>
<li>start transaction; 开始事务  （begin）</li>
<li>commit; 提交（全部完成）</li>
<li>rollback; 回滚（回到初始状态）</li>
</ul>
</li>
</ul>


<p>宕机后，没有成功的数据都会回滚。</p>

<p>事务的中继点 savepoint</p>

<p>允许事务开启后，在事务的中段进行多次保存点的保存，在回滚的时候可以回滚到任意一个保存点，而不是选择将整个事务全部回滚。而我们提交的时候，只能将我们事务中的所有操作提交，而不能提交到任意一个保存点。</p>

<p>savepoint a1;
rollback to a1;</p>

<p>线上不经常使用savepoint</p>

<h3>自动提交</h3>

<ul>
<li>autocommit 可以在session级别设置</li>
<li>每个DML操作都自动提交(就是update, delete,insert 操作)</li>
<li>DDL永远都是自动提交，无法通过rollback回滚。(就是修改表结构的那些语句，DDL之前的DML语句， 也都会随着DDL的提交而永久持续化到数据库上。)  简单来说DDL没有后悔药吃。</li>
</ul>


<p>因为在每个insert语句后，自动加了一个commit;</p>

<pre><code>mysql&gt; show global variables like '%autocommit%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
</code></pre>

<p>mysql> set session autocommit = 0;</p>

<h3>事务的四个基本属性（ACID）</h3>

<ul>
<li>原子性（Atomicity）</li>
<li>一致性 (Consistency)</li>
<li>隔离性(Isolation)</li>
<li><p>持久性(Durability)</p>

<h4>事务的原子性</h4></li>
<li><p>包含在事务中的操作要么全部执行，要么都不执行</p></li>
<li>中途数据库或应用发生异常，未提交的事务都应该被回滚</li>
</ul>


<h4>事务的一致性</h4>

<ul>
<li>数据的正确性，合理性，完整性</li>
<li>数据一致性应该符合应用需要规则

<ul>
<li>余额不能是负数？ （int no zero）</li>
<li>交易对象必须先有账号？ (主外键约束)</li>
<li>用户账号不能重复？ （添加唯一索引）</li>
</ul>
</li>
<li>事务的结果需要满足数据的一致性约束</li>
</ul>


<h4>事务的持久性</h4>

<ul>
<li>提交完成的事务对数据库的影响必须是永久性的

<ul>
<li>数据库异常不会丢失事务更新</li>
<li>通常认为成功写入磁盘的数据即为持久化成功</li>
</ul>
</li>
</ul>


<h4>事务的持久化的实现</h4>

<p>挑战： 数据库的高性能。并不是修改一个数据，就在磁盘上马上改掉。因为数据库里的数据散步在各地。而机械磁盘的随机写是相当缓慢的过程。为保证较高效率。修改数据，不会马上记录在磁盘上，先被保存在事务日志中（顺序同步刷新，磁盘对顺序写是相当优秀的，然后异步的慢慢的刷新到磁盘上。宕机时，通过事务日志回放来保证数据持久化。</p>

<h4>事务的隔离性</h4>

<ul>
<li>数据库事务在提交完成前，中间的任何数据变化对其他的事务都是不可见的</li>
</ul>


<h4>数据库隔离现象</h4>

<ul>
<li>脏读 Dirty Read 事务B读到事务A尚未提交的数据变更</li>
<li>不可重复读 NonRepeatable Read  B事务由于A事务的提交，查询数据时，看到2种不同的结果</li>
<li>幻读 Phantom Read 幻读 （不可重复读和幻读都针对事务B能否读到事务A已经提交的变更）</li>
</ul>


<h4>数据库隔离等级</h4>

<ul>
<li>Read uncommitted 未提交读</li>
<li>Read committed   已提交读</li>
<li>Repeatable read 可重复读</li>
<li>Serializable   可串行化

<h4>MySQL的事务隔离级别</h4></li>
<li>InnoDB默认标记为可重复读（Repeatabe read）</li>
<li>InnoDB并不是标准定义上的可重复读</li>
<li><p>InnoDB默认在可重复读的基础上避免幻读
show global variables like &lsquo;%iso%&rsquo;;</p>

<h4>MySQL的事务隔离级别</h4></li>
<li><p>InnoDB默认标记为可重复读（Repeatable read）</p></li>
<li>InnoDB并不是标准意义上的可重复读</li>
<li>InnoDB默认在可重复读的基础上避免幻读</li>
</ul>


<p>set global tx_isolation = &lsquo;REPEATABLE-READ&rsquo;;</p>

<p>set global tx_isolation = &lsquo;SERIALIZABLE&rsquo;;
实验：</p>

<ul>
<li>未提交读: 有脏读
  set global tx_isolation = &lsquo;READ-UNCOMMITTED&rsquo;;</li>
<li>已提交读：没有脏读， 存在幻读和不可重复读
  set global tx_isolation = &lsquo;READ-COMMITTED&rsquo;;</li>
<li>可重复读
  set global tx_isolation = &lsquo;REPEATABLE-READ&rsquo;;</li>
</ul>


<p>不可重复读: B事务由于A事务update的提交，B事务看到两种不同的数据。
幻读: 事务B由于事务A insert 的提交，B   事务看到了之前不存在的数据。</p>

<ol>
<li>不可重复读针对（delete，update操作）</li>
<li>幻读针对insert操作</li>
</ol>


<h4>MySQL的事务隔离级别的设置</h4>

<ul>
<li>可在global/session 下分别设置事务的隔离级别</li>
<li>建议使用Read committed(同Oracle)</li>
<li>或者建议使用默认的MySQL设置Repeatable read
  -隔离级别Serializable   可串行化对线上的并发性能有影响，不会在线上设置</li>
</ul>


<h3>事务与并发写</h3>

<ul>
<li>某个正在更新的记录在提交或回滚前不能被其他事务同时更新(? update 前加排它锁X?)</li>
<li>事务修改某个记录时，会先获得这条记录的锁，其它事务会进行等待。A修改完成，会将锁释放。然后B和C会获得这把锁</li>
<li>btw,所有对数据库记录的修改都是串行的，不存在并发的概念</li>
</ul>


<h3>事务回滚的实现</h3>

<ul>
<li>回滚段（rollback segment）与数据前像</li>
</ul>


<h1>存储引擎概述</h1>

<h2>MySQL 程序层次架构</h2>

<ul>
<li>内存实例

<ul>
<li>服务层（上层）</li>
<li>存储引擎层（上层数据和上层SQL语句经过处理之后，交给存储引擎层，由存储引擎层决定如何将它记录在磁盘上）</li>
</ul>
</li>
<li>存储引擎</li>
</ul>


<h2>什么是存储引擎</h2>

<p>举例：书记员记录
书记员就是<strong>服务层</strong>，
而书记员的笔就是<strong>存储引擎</strong>（文字，图标，流程图。决定以何种格式记录。）</p>

<h2>MySQL 存储引擎</h2>

<ul>
<li>有多种方案，可拔插，可修改存储引擎。</li>
<li><strong>基于表</strong>选择使用何种存储引擎</li>
</ul>


<p>show engines;</p>

<h1>InnoDB存储引擎</h1>

<ul>
<li>索引组织表</li>
<li>支持事务</li>
<li>锁的粒度比较小，支持行级锁</li>
<li>有自己的数据块缓存</li>
<li>日志持久化</li>
<li><strong>稳定可靠，性能好，线上尽量使用InnoDB</strong>
MySQL5.5之后的默认存储引擎，我们线上绝大部分的数据都会放到InnoDB存储引擎中。

<h2>InnoDB 存储引擎架构</h2></li>
<li>InnoDB缓存池：内存空间包括： 数据块缓存 Buffer pool(更高效的操作数据文件)，日志缓存，double write缓存</li>
<li>后台线程：将内存中的数据块刷新到磁盘上，将日志写到磁盘上，监控</li>
<li>磁盘上的文件： 数据文件， redo log

<h2>MyISAM 存储引擎</h2></li>
<li>堆表</li>
<li>不支持事务</li>
<li>只维护索引缓存池， 表数据缓存交给操作系统</li>
<li>锁的力度比较大，导致并发性能非常查</li>
<li>数据文件可以直接拷贝，偶尔可能用上</li>
<li>不建议线上业务数据使用
Mysql直到5.1开始，都是MySQL的默认存储引擎
MyISAM 只能有一个连接修改数据，对数据的并发性造成很大的影响，这是被淘汰的主要原因。
系统初始化的表是MyISAM,因为不需要经常的修改和并发性操作，所以没有问题。</li>
</ul>


<h2>Memory存储引擎</h2>

<ul>
<li>数据全内存存放，无法持久化</li>
<li>性能较高</li>
<li>不支持事务</li>
<li>适合偶尔作为临时表使用</li>
<li>create temporary table tmp(id int) engine = memory;</li>
<li>temporary临时表只针对当前这个连接生效，不是全局的。</li>
</ul>


<h2>BlackHole存储引擎</h2>

<ul>
<li>数据不做任何存储-</li>
<li>利用MySQL Replicate，充当日志服务器</li>
<li>在MySQL Replicate 环境中充当代理主

<h2>TokuDB</h2></li>
<li>分形数存储结构</li>
<li>支持事务</li>
<li>行锁</li>
<li>压缩效率较高</li>
<li>适合大批量insert的场景

<h2>MySQL Cluster</h2></li>
<li>多主分布式集群</li>
<li>数据节点间冗余，高可用</li>
<li>支持事务</li>
<li>设计易于扩展</li>
<li>面向未来，线上慎用</li>
</ul>


<p>alter table m ENGINE = innodb;</p>

<h2>InnoDB物理文件</h2>

<ol>
<li>系统表空间：ibdata1  一个实例一个　（innodb_data_home_dir）</li>
<li>日志文件：ib_logfile0/1 一个实例两个（可以配置） (innodb_log_group_home_dir)</li>
<li>表定义文件：　表名.frm 每个表一个 (Schema目录下)</li>
<li>表数据文件：　表名.ibd 如果innodb_file_per_table = 1，则每个表一个(Schema目录下)
ibdata1存放了：</li>
<li>回滚段</li>
<li>所有InnoDB表元数据信息（不能想MyISAM通过拷贝数据来做表迁移。如果发生移动，ibdata1中存储信息和数据文件实际存在位置不一致，就无法打开这张表）</li>
<li>Double write, insert buffer dump等等</li>
</ol>


<p>自动扩展机制
show global variables like &lsquo;%innodb%&rsquo;;</p>

<p>参数innodb_autoextend_increment 100M 或者稍微大一点是比较合适的大小。太小的话，会造成系统表空间频繁的扩展，因为每次扩展的量不够。如果设置太大的话，会造成每次扩展的效率非常慢，在扩展期间。很多因为回滚段不够的事务将被hand住。因此建议100M或者稍微大些比较合适。
innodb_file_per_table 设为1， 表定义和表数据文件会单独存放。否者会和ibdata1放在一起。
innodb_log_file_size 100M
innodb_log_file_in_group 2  和性能相关，如果写操作过多（insert,delete,update），可以将这两个参数调大。</p>

<ul>
<li>索引组织表（聚簇表）</li>
<li>根据表逻辑主键排序</li>
<li><p>数据节点每页16k （根节点，枝节点，叶节点）</p></li>
<li><p>根据主键寻址速度很快</p></li>
<li>主键值递增的insert插入效率较好</li>
<li>主键随机insert插入效率较差</li>
</ul>


<p>因此， InnoDB表必须指定主键，建议使用自增</p>

<h2>InnoDB内存缓存</h2>

<ul>
<li>数据的读写需要经过缓存</li>
<li>数据以整页（16k）为单位读到缓存中</li>
<li>缓存中的数据以LRU策略换出（最少使用策略）</li>
<li>IO效率高，性能好。（利用缓存池减少了物理IO）
innodb_buffer_pool_size 根据总物理内存设置。 在启动实例的时候设置</li>
</ul>


<h2>InnoDB数据持久化</h2>

<ul>
<li>事务日志实时持久化</li>
<li>内存变化数据（脏数据）增量异步刷出到磁盘</li>
<li>实例故障靠重放日志恢复</li>
<li>性能好，可靠，恢复快

<h2>InnoDB行级锁</h2></li>
<li>写不阻塞读</li>
<li>不同行之间的写互相不阻塞</li>
<li>并发性能好

<h2>InnoDB事务支持</h2>

<p>事务ACID特性的完整支持
A 回滚段失败回滚
C 支持主外键约束
I 事务版本 + 回滚端 = MVCC
D 事务日志持久化</p></li>
</ul>


<p>默认可重复读隔离级别，可调整</p>

<h1>InnoDB事务锁</h1>

<h2>什么是计算机程序锁</h2>

<ul>
<li>控制对共享资源进行并发访问</li>
<li>保护数据的完整性和一致性</li>
</ul>


<h2>什么是数据库锁</h2>

<ul>
<li>事务锁 保护数据库逻辑内容， 持续时间较长</li>
<li><p>latch/mutex 保护内存数据结构， 用于临界资源的争抢，时间短
数据库事务并发：（一个串行化的过程）
更新丢失</p>

<h3>事务锁的力度</h3></li>
<li><p>行锁 InnoDB, Oracle</p></li>
<li>页锁 SQL Server； 存在锁升级的情况</li>
<li>表锁 MyISAM, Memory; 影响并发性

<h3>数据库加锁操作</h3>

<p>select 语句不加任何锁，也不会被任何事务阻塞锁。
读的隔离性由MVCC确保</p></li>
</ul>


<h3>InnoDB锁模式互斥</h3>

<ul>
<li>shared lock 读锁是共享的

<ul>
<li>手动： select * from test lock in share mode ;</li>
<li>自动： insert 前</li>
</ul>
</li>
<li>exclusive lock 写锁是排他的

<ul>
<li>自动： select * from test lock for update;</li>
<li>手动: update 和delete前</li>
</ul>
</li>
<li>一般select语句不加任何锁，也不会被任何事务阻塞</li>
</ul>


<p>等待时间，由系统参数决定
show global variables like &lsquo;%lock_wait%&rsquo;;</p>

<h4>锁粒度</h4>

<ul>
<li>table lock</li>
<li>row lock</li>
</ul>


<p>lock for update  (exclusive lock)</p>

<h2>InnoDB锁机制</h2>

<h2>InnoDB锁实现与注意事项</h2>

<h2>死锁</h2>

<h2>业务加锁</h2>

<h1>参考链接</h1>

<p><a href="http://blog.csdn.net/hguisu/article/details/7106342">MySQL架构</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL存储引擎]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/16/mysql-storage-engine/"/>
    <updated>2015-09-16T20:01:29+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/16/mysql-storage-engine</id>
    <content type="html"><![CDATA[<h3>什么是MySQL存储引擎</h3>

<p>服务层 - 存储引擎 - 文件系统层</p>

<p>MySQL5.5 以后默认为InnoDB,推荐。</p>

<p>Memory存储引擎，临时表</p>

<h4>MyISAM</h4>

<ul>
<li>堆表（插入性能好）</li>
<li>不支持事务</li>
<li>只维护索引缓存池，表数据缓存交给操作系统（表若很大，浪费内存）</li>
<li>锁粒度较大（表级锁，读写锁，读的时候不允许写，写的时候不允许读）</li>
<li>数据文件可以直接拷贝，备份数据用得上</li>
</ul>


<p>不推荐的原因：1. 不支持事务 2. 锁的颗粒度比较大 3. 表数据缓存交给操作系统，表若很大，浪费内存</p>

<h4>TokuDB</h4>

<p>社区版备份比较麻烦</p>

<h4>MySQL Cluster</h4>

<ul>
<li>多主分布式集群</li>
<li>数据节点间冗余，高可用</li>
<li>支持事务</li>
<li>设计上易于扩展</li>
<li>面向未来，线上慎用</li>
</ul>


<h4>InnoDB</h4>

<ul>
<li>缓存池 +　各种后台线程　＋ 数据文件</li>
</ul>


<p>事务ACID:</p>

<ul>
<li>回滚段失败回滚（A）</li>
<li>支持主外键（C）</li>
<li>事务版本 + 回滚段 = MVCC(I)</li>
<li>事务日志持久化（D）</li>
</ul>


<p>行级别锁：</p>

<ul>
<li>写不阻塞读</li>
<li>不同行间的写相互不阻塞</li>
<li>并发性能好</li>
<li>锁是加在索引上的</li>
</ul>


<p>InnoDB数据块缓存池</p>

<ul>
<li>数据的读写经过缓存</li>
<li>IO效率高，性能好。</li>
</ul>


<p>InnoDB数据文件存储结构：</p>

<ul>
<li>根据主键寻址速度很快</li>
<li>主键值递增的insert插入效率较好</li>
<li>主键随机insert插入效率较好</li>
<li><strong>因此，InnoDB表必须指定主键，建议使用自增数字</strong></li>
</ul>


<p>数据持久化与事务日志</p>

<ul>
<li>事务日志实时持久化</li>
</ul>


<h3>介绍MySQL主要存储引擎的特点及试用场景</h3>

<h3>Innodb存储引擎</h3>

<pre><code>show global variables like "%increment%";

+-----------------------------+-------+
| Variable_name               | Value |
+-----------------------------+-------+
| auto_increment_increment    | 1     |
| auto_increment_offset       | 1     |
| div_precision_increment     | 4     |
| innodb_autoextend_increment | 64    |
+-----------------------------+-------+
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL数据库对象与应用]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/14/mysql-db-object/"/>
    <updated>2015-09-14T11:16:22+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/14/mysql-db-object</id>
    <content type="html"><![CDATA[<h1>MySQL数据类型</h1>

<h4>经验之谈</h4>

<ul>
<li>存储性别、省份、类型等分类信息时，选择TINYINT或者ENUM</li>
<li>BIGINT存储空间更大，INT和BIGINT之间通常选择BIGINT</li>
<li>交易等高精度数据时选择使用DECIMAL</li>
</ul>


<h1>MySQL数据对象</h1>

<p>help create index</p>

<h1>MySQL权限管理</h1>

<ul>
<li><p>Data Privileges</p>

<pre><code>  DATA: SELECT, INSERT, UPDATE, DELETE
</code></pre></li>
<li>Define</li>
<li>Administrator Privileges

<ul>
<li>Shutdown Database</li>
<li>Replication</li>
</ul>
</li>
</ul>


<p>创建一个用户并赋权：</p>

<ul>
<li>使用原生的SQL</li>
<li>更改数据库记录</li>
<li>更简单的方法

<h4>查看用户权限</h4>

show grants;

<h4>如何更改用户的权限</h4></li>
</ul>


<h4>如何更改用户的密码</h4>

<h4>删除用户</h4>

<h4>With Grant Option</h4>

<h4>与权限相关的表</h4>

<ul>
<li>user</li>
<li>db</li>
<li>tables_priv</li>
<li>clomuns_priv

<h5>Mysql 权限验证的过程</h5></li>
</ul>


<h4>MySQL权限上有哪些问题</h4>

<ul>
<li>默认的test库不受权限控制，存在安全风险</li>
<li>mysql_secure_installation</li>
</ul>


<h4>小结</h4>

<ul>
<li>权限相关的操作不要直接操作表，统一使用MySQL命令</li>
<li>使用二进制安装MySQL后，需要重置管理用户（root）的密码</li>
<li>线上数据库不要留test库</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL索引]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/10/mysql-index/"/>
    <updated>2015-09-10T10:07:51+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/10/mysql-index</id>
    <content type="html"><![CDATA[<h4>什么是索引</h4>

<p>索引是值到行位置的映射。索引就是一个目录。</p>

<h4>索引的作用：</h4>

<ul>
<li>提高访问的速度。硬盘IO每秒100到150次的响应。每次10毫秒</li>
<li>实现主键、唯一键逻辑</li>
</ul>


<p>IO是个宝贵的资源，</p>

<h4>索引的使用场景：</h4>

<p>FTS 全表索引</p>

<h4>Mysql中我们可以使用的索引类型：</h4>

<ul>
<li>Btree索引：</li>
<li>B+tree： 平衡二叉树的一种改良</li>
<li>Hash索引 InnoDB</li>
<li>Innodb ： 聚簇索引，</li>
<li>二级索引： 除了主键，用户创建的索引。</li>
</ul>


<h4>索引的代价：</h4>

<p>插入修改删除每个索引都编程一个内部事务，索引越多，事务越长。(增删改)</p>

<h4>索引的优势:</h4>

<ol>
<li>减少查询IO</li>
<li>优化等值查询、范围查询</li>
<li><p>利用有序特性</p>

<p> order by , group byh , distinct, max ,min</p></li>
</ol>


<h4>如何用好索引：</h4>

<ul>
<li><p>依据where查询条件来建立索引：</p>

<pre><code>  select a,b from tab_a where c = ?;  #c上建立索引
</code></pre></li>
<li><p>使用联合索引，而不是多个单列索引。</p>

<pre><code>  select * from tab_a where a = ? AND b = ? 
  #建立a和b的索引， 把一组值作为b+tree 的索引， 在同一个树里，查询速度更高。
</code></pre></li>
<li><p>联合索引， 区分度大的放在前面。</p>

<pre><code>  name,gender 对， 因为name的区分度很大。能够更好地使用b+ TREE来定位节点

  gender,name 错
</code></pre></li>
<li><p>联合索引能为前缀单列，复列查询提供帮助。</p>

<pre><code>  where a = ? 
  wherer a = ? AND b =? 
</code></pre></li>
<li><p>合理创建联合索引，避免冗余。
      abc 包含 a ,ab</p></li>
<li><p>ORDER BY, GROUP BY, DISTINCT 字段添加索引</p></li>
<li><p>用 EXPLAIN 查看语句</p>

<pre><code>  possible_key 可以使用的索引
  key 实际的索引名字  重要
  rows  读的记录行数，才返回的结果 重要。
  typpe   index  扫描完整的索引树， 重要   
  key_len 如果只使用了一部分，为长度。  
  force index  强制使用索引 
  ignore index 
</code></pre>

<h4>其他技巧</h4></li>
<li><p>一个表，控制百万级别。如何达到了一两百G，就可以考虑分库分表了。千万级别，取决于访问方式，left join</p></li>
<li><p>WHERE查询时，  函数不要加在字段上。timestamp > func(1234)。</p></li>
<li><p>外键一般用程序使用。</p></li>
<li><p>什么事优化器： 哪个索引会更快，IO更小。生发语法数，生成一个计划。</p></li>
<li><p>纵向分表，根据业务来拆分。</p></li>
<li><p>等值查询 ，2个范围查询， 不能都覆盖到。联合查询。等值能用一个，范围查询也只能用一个。</p></li>
<li><p>通过表结构设计来避免连表。</p></li>
<li><p>触发器和存储过程不好维护，做运维手段还可以。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MySQL Foundation]]></title>
    <link href="http://fenghan.github.io/blog/2015/09/09/mysql-foundation/"/>
    <updated>2015-09-09T15:25:59+08:00</updated>
    <id>http://fenghan.github.io/blog/2015/09/09/mysql-foundation</id>
    <content type="html"><![CDATA[<h1>认识MySQL</h1>

<h4>关系与非关系型数据库</h4>

<p>关系型数据库</p>

<ul>
<li>mysql</li>
<li>oracle</li>
<li>sql server</li>
<li>postgresql</li>
</ul>


<p>非关系型数据库</p>

<ul>
<li>hadoop</li>
<li>mongoDB</li>
<li>redis</li>
<li>Cassandra</li>
</ul>


<p>区别：</p>

<p>是否使用SQL语句作为数据操作的方法和方式。</p>

<p>所以关系型数据库又叫做SQL数据库。</p>

<h4>为什么学习MySQL</h4>

<ul>
<li>基于GPL协议</li>
<li>Mysql 最流行 ，开源，但不是最先进的。</li>
<li>互联网企业中占绝对主流地位</li>
</ul>


<p>开发者学习MySQL：</p>

<ul>
<li>学习数据类型的正确使用</li>
<li>学习如何利用索引优化查询效率</li>
<li>了解分区，读写分离特性</li>
<li>了解数据库事务相关特性</li>
</ul>


<p>DBA学习MySQL：</p>

<ul>
<li>学习MySQL体系结构知识</li>
<li>学习日常运维，性能调优，故障排查</li>
<li>虚席数据层架构设计，schema优化知识</li>
</ul>


<h1>轻松安装MySQL</h1>

<p>5.6 <a href="http://www.mysql.com/downloads/">http://www.mysql.com/downloads/</a></p>

<ul>
<li>企业版</li>
<li>集群版</li>
<li>社区版 （免费）

<h4>Windows上安装</h4>

<p>安装包：300M+</p></li>
</ul>


<h4>Linux上安装</h4>

<h4>Ubuntu上安装MySQL</h4>

<pre><code>apt-cache search mysql-server
apt-get install mysql-server-5.6
#查看mysql进程
ps -ef|grep mysqld
#查看mysql状态：版本、运行时间、连接方式、查询统计
sudo /etc/init.d/mysql status
#msyql启动、停止、重启
sudo /etc/init.d/mysql start|stop|restart
</code></pre>

<h1>连接使用MySQL</h1>

<ul>
<li>应用程序驱动</li>
<li>MySQL命令行</li>
<li><p>GUI工具</p>

<p>  #查看mysql-client版本
  mysql -V</p></li>
</ul>


<p>命令行连接MySQL</p>

<ul>
<li><p>Socket连接(本地连接)</p>

<pre><code>  mysql -S/var/run/mysqld/mysqld.sock -uhomestead -p
</code></pre></li>
<li><p>TCP/IP连接（远程连接）</p>

<pre><code>   mysql -h127.0.0.1 -P3306 -uhomestead -p
</code></pre></li>
</ul>


<p>本地连接只能在MySQL服务器上创建，常作为MySQL状态检查，或程序和MySQL部署在一台机器上。</p>

<pre><code>#小技巧
Ctrl + r : 搜索之前敲过的命令
</code></pre>

<h3>两个重要的命令： status, show processlist</h3>

<h4>status</h4>

<p>关注的信息：</p>

<ul>
<li>Server version</li>
<li>characterset: utf8 (Server, Db, Client, Conn)</li>
<li>Uptime

<h4>show processlist</h4></li>
</ul>


<p>help select;</p>

<pre><code>#查看socket文件位置
show global variables like 'socket'
</code></pre>

<ul>
<li>socket权限为777</li>
<li>不要把密码直接输入在命令行里面，存在安全风险。</li>
</ul>


<p>history -c 清楚命令行历史</p>

<h4>常用的图形客户端工具</h4>

<ul>
<li>Navicat</li>
<li><p>MySQLWenkBench</p></li>
<li><p>操作简单，易于上手</p></li>
<li>支出图形化的导入导出</li>
<li>可视化的界面输出</li>
</ul>


<p>总结：</p>

<ol>
<li>应用程序使用API接口连接MySQL</li>
<li>开发工程师可以使用图形工具连接MySQL</li>
<li><strong>命令行工具才是DBA的最爱</strong></li>
</ol>


<h1>SQL语言入门</h1>

<p>DDL :
- CREATE TABLE
- DROP TABLE
- ALTER TABLE</p>

<p>DML:</p>

<ul>
<li>SELECT FROM TABLE</li>
<li>INSERT INTO TABLE</li>
<li>UPDATE TABLE SET</li>
<li>DELETE FROM TABLE</li>
</ul>


<p>DCL:</p>

<ul>
<li>GRANT</li>
<li>REVOKE</li>
</ul>


<p>TCL:</p>

<ul>
<li>COMMIT</li>
<li>ROLLBACK</li>
</ul>


<p><a href="http://www.w3school.com.cn/sql/">SQL教程</a></p>

<h1>认识DBA</h1>

<p>DBA是最后一道屏障，守门员，是业务稳定的基石。</p>

<p>监控线上，保障业务的正常运行。</p>

<p>做好实时性能监控,一旦有长的SQL语句，就会立刻接到报警，然后进行调优。</p>

<h4>小公司</h4>

<ul>
<li>没有专职DBA</li>
<li>但肯定有懂数据库的人</li>
</ul>


<p>大公司：</p>

<ul>
<li>专职DBA</li>
<li>数据存储技术专家</li>
</ul>


<p>互联网业务： 高性能、高可用、可扩展、安全性。</p>

<p>没有DBA就没有稳定的数据库，请求变慢，数据丢失，安全问题，用户投诉，无穷无尽。</p>

<h3>DBA要做哪些工作？</h3>

<ol>
<li>基础运维

<ul>
<li>安全部署</li>
<li>监控</li>
<li>故障处理</li>
</ul>
</li>
<li>安全运维工作

<ul>
<li>数据备份与恢复</li>
<li>安全访问，安全漏洞</li>
<li>审计</li>
</ul>
</li>
<li>性能调优工作

<ul>
<li>数据库优化</li>
<li>容量评估、软硬件升级</li>
</ul>
</li>
<li>开发支持工作

<ul>
<li>存储方案制定(哪些数据放在memcache，减少对数据库的访问)</li>
<li>数据库设计</li>
<li>数据库变更 SQL Review （审核业务SQL，全表扫描的SQL会把数据库跑死）</li>
</ul>
</li>
<li>流程与培训

<ul>
<li>数据库开发规范</li>
<li>运维流程与标准化</li>
<li>业务培训</li>
</ul>
</li>
</ol>


<p>练习：
mysql要做的：</p>

<p>分析MySQL慢日志请求，优化表索引</p>

<h4>DBA需要的技能</h4>

<p>专业技能：
    - 数据库原理
    - Linux与Shell
    - 计算机体系结构
    - 网络原理
    - 数据库系统与操作
    - 服务器硬件
    - 业务架构设计
软技能：</p>

<pre><code>- 责任心、执行力
- 坚韧，抗压（半夜、凌晨工作）
- 学习与沟通能力
- 正直，诚信
- 耐心，注重细节
- 分析能力
- 团队协作
- 
</code></pre>

<p>DBA如何发展？</p>

<ul>
<li>业务架构师（数据存储有深入研究，处理不同业务场景与需求的数据存储）</li>
<li>运维专家（解决mysql的任何问题，帮助数据库更稳定更高效的运行）</li>
<li>数据库研发（改进数据库系统或开发自己的数据库）</li>
</ul>

]]></content>
  </entry>
  
</feed>
